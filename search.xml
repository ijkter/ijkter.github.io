<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[计算机组成原理]]></title>
    <url>%2F2019%2F07%2F05%2Fcomputer-struct%2F</url>
    <content type="text"><![CDATA[[Updated] 本文梳理了《计算机组成原理》的基础知识 目录 Chapter 1 Chapter 2 Chapter 3 Chapter 4 Chapter 5 Chapter 6 Chapter 7 Chapter 8 总线 存储器 I/O 计算的运算方法 指令系统 CPU 控制单元 控制单元的设计 总线 判优控制 ！当总线上各个主设备同时请求占用总线时，总线控制器按一定优先等级确定某个设备可以占用总线。 ？总线特点为某一刻时刻只允许一个设备向总线发送信息，若两个以上部件同时向总线发送信息，势必导致信号冲突传输无效。 链式查询 1 BR、1 BS、1 BG 优：优先级固定；结构简单、易扩充 缺：电路故障敏感，第i个有故障，第i个以后皆无法工作 计数器定时查询 1 BR、1 BS、1bN设备地址线 优：优先级可不固定；电路故障不如链式查询敏感 缺：控制比链式查询复杂 独立请求 N BR、N BS、N BG 优：响应速度快；优先级控制灵活，可预先固定，也可通过程序改变；可屏蔽设备请求 缺：仲裁线路复杂 通信控制 ！解决通信双方如何获知传输开始和传输结束，以及通信双方如何协调配合。 ？因为总线由众多部件共享，在传送时间上只能用分时方式解决，故通信双方必须按某种约定的方式进行通信。 同步通信 采用公共时钟信号控制，统一传输周期（必须按最慢速度部件设计） 适用：总线长度较短，各部件存取时间相较一致 异步通信 没有公共时钟，采用应答式通信，无固定传输周期 全互锁（完全制约，可靠性最高）/半互锁（简单制约）/不互锁（无制约） 适用：总线各部件速度不一致 分离式通信 总线传输周期分为两个子周期供不同模块占用，总线上无等待时间，最充分发挥了总线的有效占用 半同步通信 既有公共时钟，又允许速度不同的模块和谐工作，采用插入等待周期的措施协调通信双方的配合问题 串行传输与并行传输 串行传输 数据在一条线路上按位依次传输 成本低，但速度慢，适合远距离的传输 并行传输 每个数据位都有一条独立传输线路，所有数据按位同时传输 成本高，速度快，适合近距离、高速传输 总线复用 不同信号（数据/地址）共用同一组物理线路，分时使用 需先给地址信号，然后用地址锁存信号将其保存 总线带宽（MBps）：单位时间总线上可传输数据位数，也称“数据传输率” 影响因素：总线宽度、传输距离、主频 总线带宽 = 一个传输周期传输字节数/时钟周期 | 一个传输周期传输字节数*时钟频率 存储器 芯片：16K×8位/16KB 地址线 = 14根 数据线 = 32根 引出线最少数目 = 数据线+地址线+2 多体结构存储器 将存储器分成若干个（n个）独立的模块，每个模块的容量和存取周期均相等，且可独立进行读写操作。将独立模块： 高位交叉编址 各模块分别响应不同请求源，实现多体并行 高位–存体号，低位–选择存储体内的字 低位交叉编址， 不改变存取周期的前提下，增加存储器带宽，n个模块则带宽提高至n倍 高位–选择存储体内的字，低位–存体号 存取周期T，总线传输周期t，连续读取n个字时间=T+（n-1）t 提高访存的措施 采用高速器件，选用存取周期短的芯片，提高存储器速度 采用缓存，CPU将近期要用的信息先调入缓存，而缓存速度比主存快得多，CPU从缓存存取信息则缩短访存时间，提高了访存速度 调整主存结构，如采用单体多字结构或多体结构（都增加存储器带宽） 程序访问的局部性原理 由于指令和数据在主存的地址分布不是随机的，而是相对地聚簇，故程序执行时对存储器的访问使不均匀的 利用该原理：对缓存-主存，把CPU最近期执行的程序放在容量较小速度较高的缓存中；对主存-辅存，把程序中访问频度高、比较活跃的部分放在主存中。既提高了访存速度又扩大了存储器容量 地址映射（硬件完成） 直接 假设C块缓存，每个主存块j只与一个缓存块i对应：i = j mod C 映射简单，但主存块只能固定对应某个缓存块，不够灵活、命中率低 全相联 主存任一块都可以映射到缓存中的任一块上 灵活、命中率高，但所需电路多、成本高 组相联 把缓存分Q组，组内分R块，主存块号j映射到缓存组号i内任一块：i = j mod Q，缓存内1~R任一块 比直接灵活、命中率高，比全相联成本低，是两者的折中，广泛应用 三级存储系统（平衡–速度、容量、价格） 高速缓存 解决：CPU和主存速度匹配，提高访存速度缓存 管理：硬件和操作系统完成 地址对用户透明 虚存 解决：扩大存储容量 管理：硬件和操作系统完成 CPU不直接访问二级存储器 RAM刷新 方式：集中/分散/异步 原因：存储电荷电容放电 I/O I/O编址方式 独立编址：I/O地址与主存地址分开，不占主存容量，但需要专用I/O指令访I/O 统一编址：在主存地址划出一定范围作I/O地址，通过访存指令访问I/O，但减少了主存容量 主机与I/O交换信息的控制方式 程序查询 主机与I/O串行工作 程序中断 主机与I/O并行工作,主程序和信息传送串行 DMA 主机与I/O并行工作,主程序和信息传送并行 通道 I/O处理机 程序查询 CPU启动I/O后停止现行程序，插入一段程序时刻查询I/O设备准备状况，等待I/O准备就绪时可实现信息交换，存在“踏步”现象 程序中断 管理（多重）中断硬件 中断请求触发器（INT）：标志中断源向CPU提出中断请求 中断屏蔽触发器（MASK）：为“1”表示屏蔽该中断源 排队器：中断判优 向量地址形成部件：产生中断源向量地址 允许中断触发器（EINT）：为“1”允许处理中断 中断标志触发器（INTR）：标志进入中断周期 堆栈：保护现场 中断查询信号电路：每条指令执行周期结束时刻，向各中断源发查询信号 过程： 中断请求：CPU启动I/O设备，I/O准备就绪后向CPU提出中断请求 中断判优：中断判优逻辑选择优先级最高的中断请求，待CPU处理 中断响应：若INT（中断请求触发器）为”1”且请求中断设备未被屏蔽，系统进入中断响应周期–CPU自动执行中断隐指令[ 硬件完成：保护程序断点(即PC内容)、硬件关中断、向量地址送PC（硬件向量法）或中断识别程序入口地址送PC（软件查询法） ] 中断服务：中断响应周期结束，CPU转入取指周期，按向量地址取出无条件转移指令（或按向量地址查入口地址表）；转至向量地址对应的中断程序服务入口地址，开始执行中断服务程序[ 保护现场（PC内容–中断隐指令；寄存器内容–软件编程）、与I/O传送信息、恢复现场 ] 中断返回：中断服务程序最后一条即中断返回指令（返回程序断点） 响应条件和时间： 条件：EINT为“1”（即开中断）；中断请求未被屏蔽，且排队后被选中 时间：指令执行阶段的结束时刻，CPU发出中断查询信号，才能获取中断请求信号 向量地址 存放服务程序入口地址的存储单元地址，由硬件形成 当有中断请求且排队选中时，通过自由组合逻辑电路组成的向量地址形成部件可形成向量地址 输入：排队器；输出：中断周期送至PC；传送：数据总线 开/关中断 EINT为“1”时，允许CPU响应中断；EINT为“0”时，CPU不能响应中断 关中断即将EINT置“0”；开中断即置“1” 多重中断(主要区别在中断服务程序)：CPU处理中断过程中出现新的中断请求，暂停现行中断处理转至处理新的中断 多重中断条件 必须重新开中断 优先级更高的中断请求才能中断现行程序（内部中断&gt;不可屏蔽中断&gt;可屏蔽中断） 单重中断：保护现场-&gt;设备服务-&gt;恢复现场-&gt;开中断-&gt;中断返回 多重中断：保护现场-&gt;开中断-&gt;设备服务-&gt;恢复现场-&gt;中断返回 中断服务程序与调用子程序区别 中断服务程序与中断时CPU正在运行程序相互独立；子程序与CPU正在运行程序是同一程序的两部分 除了软中断，中断通常随机产生；子程序调用由CALL指令引起 中断服务程序入口地址可通过硬件向量法产生向量地址，再由向量地址找到入口地址；子程序调用入口地址由CALL指令地址码给出 中断需要对多个同时发生的中断进行裁决；子程序调用无此操作 都要保护程序断点：前者中断隐指令完成；后者CALL指令完成 都要保护寄存器内容的操作 中断和DMA区别 数据传送：中断靠程序传送；DMA靠硬件传送 CPU响应时间：中断在一条指令执行结束时响应；DMA在存取周期结束时响应 异常处理能力：中断有；DMA无 保护现场：中断需中断现行程序，需保护现场；DMA不需中断现行程序，无需保护现场 优先级：DMA高于中断 DMA 特点： I/O和CPU并行工作 主存和I/O接口间有一条直接数据通路 不中断现行程序，无需保护、恢复现场 DMA请求占用总线时，若采用周期挪用，CPU暂停一个存取周期访问主存，但可继续自身内部操作（如乘法），即DMA传送和主程序并行 硬件：数据缓存寄存器、DAR、AR、WC、中断机构、DMA控制逻辑 过程： 预处理 指明数据传送方向输入（读）/输出（写） 设备地址送DAR（设备地址寄存器） 主存地址送AR（主存地址计数器） 传送数据字数送WC（字计数器） 启动设备 数据传送 主存地址送总线 数据送I/O设备（或主存） 修改主存地址和WC 重复直至数据块传送结束 后处理 由中断服务程序作DMA结束处理（测试传送过程是否出错、决定是否继续使用DMA传送数据） DMA和CPU分时使用主存： 停止CPU访存 DMA在传送数据时独占主存，CPU放弃总线使用权，基本处于不工作或保持原状态，直至DMA传送结束 周期挪用 一旦I/O有DMA请求，由I/O设备挪用一个存取周期。此时CPU可完成自身操作，但要停止访存 DMA和CPU交替访存 适用CPU工作周期比主存存取周期长时。CPU工作周期的上下半周期由DMA和CPU交替使用访存，使DMA传送和CPU工作效率最高，但硬件逻辑复杂 计算的运算方法 判溢出 定点机 参与运算的两个操作数符号相同，结果的符号与原操作数符号不同，则溢出 求和时最高进位与次高进位异或结果为1，则溢出 浮点机判溢出 当阶码大于最大正阶码时，则溢出 当阶码小于最小负阶码时，则按机器零处理 进位：影响加减运算速度的关键 进位链：传递进位的逻辑电路 先行进位：高位进位和低位进位同时产生 单重分组跳跃进位 n位全加器分若干小组，组内进位同时产生，组间串行进位 多重分组跳跃进位 n位全加器分若干大组，若干大组内又包含若干小组，大组内各小组进位同时产生，小组内进位同时产生，大组间串行进位 快于单重，但线路更复杂 指令系统 不同地址格式指令 地址格式 访存次数 备注 四地址 4 A4指出下条指令地址 三地址 4 PC指出下条指令地址 二地址 4 操作结果存回A1、A2或ACC 一地址 4 ACC存放操作数和结果 数据存放方式。存储字长32位，可按字节、半字、字寻址： 边界对准：数据字地址一定是4的整数倍。所存数据不满足该要求时，填充一个或多个空白字节（浪费存储空间） 边界不对准：数据字跨两个存储字时需两次访存，并对高低字节位置进行调整后才能取得数据字（影响取数时间） 间址/基址/变址：可扩大寻址范围 通过访存（多次间址多次访存）得到有效地址 间址 访存导致时间较长（T一次访存 &gt;&gt; T一次寄存器） 地址变换（R+A）得到有效地址 基址 基址寄存器内容由操作系统给定，且在程序执行过程中不可变 支持多道程序技术的应用 变址 变址寄存器内容由用户给定，且在程序执行过程中可变 适用于处理数组问题 相对/堆栈寻址 相对：EA = (PC) + A A为位移量（字节），决定寻址范围；可正可负，补码表示 便于程序浮动，用于转移指令 堆栈：SP +/- ▲ -&gt; PC 有效地址在SP中，指令中可少一个指令字段 ▲与主存编址方式相关：按字编址，▲取1；按字节编址，字长16位时▲取2，字长32时▲取4 RISC（CISC） 选用频度高简单指令，复杂指令功能由简单指令实现（指令系统复杂庞大） 指令长度固定，指令格式种类少，寻址方式种类少（不固定、多、多） 只有LOAD/STORE访存，其余指令皆在寄存器进行（可访存指令不受限制） CPU中有多个通用寄存器（设专用寄存器） 控制器采用组合逻辑控制（微程序） 采用流水技术，大部分指令1个时钟周期内完成（各指令执行时间相差大，大部分需多个时钟周期） 采用优化的编译程序（难以用优化编译生成高效代码） 与CISC比较： 提高指令执行速度 便于设计，可降低硬件设计复杂度 简化指令功能，有利于编译程序代码优化 不易实现指令系统兼容 CPU CPU 功能 指令控制：控制程序的顺序执行 操作控制：产生完成每条指令所需控制命令 时间控制：对各种操作加以时间上的控制 数据加工：对数据进行算术和逻辑运算 中断处理：处理计算机在运行过程中出现的异常情况和特殊请求 组成 寄存器 PC：存放现行指令地址，位数取决于存储器容量 IR：存放现行指令，位数取决于指令字长 通用寄存器：存放数据和地址，位数取决于机器字长 指令译码器 + 控制单元CU：根据指令译码在规定时间发出操作命令 ALU：算术逻辑运算 中断系统：处理中断 指令周期：取指+（间址）+执行+（中断） 执行 -&gt; 中断周期 -&gt; 取值 存取周期 -&gt; DMA周期 -&gt; 存取周期（指令周期任一阶段皆可） 指令流水 结构相关 硬件资源满足不了指令重叠执行的要求，发生资源冲突 如：同一时间，几条重叠的指令分别取值、取数、存数，发生访存冲突 数据相关 指令重叠执行，可能改变操作数的读写访问顺序，导致数据相关冲突 如：某条指令需要用到前面指令的执行结果，而这些指令在流水线中重叠执行，可能改变对操作数读写访问顺序 控制相关 流水线遇到分支指令或其他改变程序计数器PC的指令，造成指令执行顺序的改变 如：某条指令需等前面指令做出转移方向的决定才能进入流水线 流水线多发技术 超标量流水：每个时钟周期内可同时并发多条独立指令，处理器中需配置多个功能部件和指令译码电路，以便同时执行多个操作 超流水线：在原来的时钟周期内，功能部件被使用多次 超长指令字：对编译器要求高，充分挖掘指令间潜在并行性（一个时钟周期内，各功能部件无数据相关），把能并行的指令合成一条具有多个操作码（需相应个数功能部件）的超长指令 中断系统 INTR 与 EINT INTR 中断标志触发器：指示CPU是否进入中断周期 EINT 允许中断触发器：开放或关闭中断系统 置“1”：系统开放，允许中断（开中断指令） 置“0”：关中断（关中断指令、中断隐指令、硬件自动复位） 中断判优：在某一时刻可能有多个中断源（中断源请求随机）提出请求，而CPU只能响应一个，故须判优已解决响应优先次序 硬件排队：组合逻辑电路实现 软件排队：程序按优先级（从高至低）顺序查询各中断源 中断服务程序入口地址寻找 硬件向量法（向量中断）：当有中断请求时，由硬件产生该中断源对应的向量地址，再由向量地址找到服务程序的入口地址，然后暂停现行程序转至中断服务程序 排队器输出 -&gt; 向量地址形成部件 -&gt; 输出向量地址 向量地址寻找入口地址方式 向量地址单元内存放一条无条件转移指令 在向量地址单元内直接存放入口地址，形成一个中断向量地址表 软件查询法：编写中断识别程序实现 屏蔽 屏蔽触发器：内容即屏蔽字，每个中断源对应一个屏蔽字，为“1”时CPU不响应该中断源请求 优先级 响应优先级：CPU响应各中断源请求的优先次序，通常硬件线路已设置好，不便改动（不采用屏蔽时） 处理优先级：CPU实际对各中断源请求的处理优先次序（采用屏蔽） 采用屏蔽技术的中断服务流程 保护现场 -&gt; 置屏蔽字 -&gt; 开中断 -&gt; 中断服务 -&gt; 关中断 -&gt; 恢复现场 -&gt; 恢复屏蔽字 -&gt; 开中断 -&gt; 中断返回 作用 改变处理优先级 为实现多重中断，屏蔽低级别中断请求对现行中断处理程序的干扰 封锁部分中断请求，使程序控制更灵活 控制单元 控制单元CU 功能：发出各种操作命令(即控制信号) 受控制：指令寄存器(操作码)、时钟、标志、系统总线控制信号(中断) 多级时序 指令周期：完成（取出并执行）一条指令所需的时间 机器周期：指令执行过程中一个基准时间，通常以存取周期作为机器周期（因为完成指令都需取指，而一次访存时间固定）。一个机器周期内完成若干微操作，可通过节拍控制产生每一个微操作命令 时钟周期：主频（时钟信号的频率）的倒数，也可称为节拍（时钟信号控制产生，每个节拍宽度对应一个时钟周期）。一个节拍内完成若干需同时执行的操作，是控制计算机操作的最小时间单位 三者关系：每个指令周期含若干个机器周期，可不相等；每个机器周期含若干个时钟周期（节拍），可不相等 机器速度：同主频下， 机器周期中时钟周期数和指令周期中机器周期数不同，机器速度不同。（机器周期中含时钟周期少的机器速度更快） 控制方式 同步控制：微操作受统一基准时标时序信号控制。存取周期不统一时，取最长存取周期作为机器周期 采用定长的机器周期：采用完全统一、具有相同时间间隔和相同数目节拍 采用不定长的机器周期：机器周期内节拍数可不等；大多数微操作一个机器周期内完成，复杂微操作延长机器周期或增加节拍 采用中央控制和局部控制相结合的方法：大部分中央控制，少数局部控制 局部控制每一个节拍T*宽度与中央控制节拍宽度相同 局部控制节拍作为中央控制中机器节拍的延续，插入中央控制的执行周期 异步控制：不存在基准时标信号，微操作时序由专用的应答线路控制。控制器发出某一个微操作命令后，等待执行部件完成该操作时所发回的应答信号，再开始执行下一个操作 联合控制：同步与异步结合。即大多数微操作在同步时序信号控制下进行，而对时间难以确定的微操作（如I/O相关）采用异步控制 控制单元设计 组合逻辑控制器 采用硬连线逻辑：一个微操作命令对于一个逻辑电路 思路清晰，简单明了 结构复杂，线路复杂。一旦构成，除非物理上重新连线，否则无法增加新的控制功能 组合逻辑与微程序控制组成异同 同：均有PC、IR、时序电路、中断系统、状态条件 异： 微操作命令序列形成部件不同。组合逻辑核心部件–门电路；微程序核心部件–控制存储器ROM(存放全部微程序) 微操作命令及节拍安排的主要差别： 取指阶段 12OP(IR) -&gt; ID //组合逻辑：指令操作码送指令译码器OP(IR) -&gt; 微地址形成部件 //微程序：指令操作码送微地址形成部件 微程序每条指令都要增加一个将微指令下地址字段送CMAR的微操作 1Ad(CMDR) -&gt; CMAR 微程序控制器 采用存储逻辑：每条机器指令编写成一个微程序，每一个微程序包含若干条微指令（操作控制字段+顺序控制字段），每一条微指令对应一个或几个微操作命令 优点：规整形、灵活性、可维护性 控制器中微程序个数 = 机器指令数 + 3（取指/间址/中断周期) 组成 控存：存放全部微程序 CMAR（控存地址寄存器）：存放欲读出微指令地址。采用增量计数器法形成后续微指令地址时，有计数功能 CMDR（控存数据寄存器）：存放取出的微指令 顺序逻辑：控制微指令序列 输入：微地址形成部件、微指令下地址字段、外来标志 输出：CPU内部和系统总线的控制信号 微指令编码方式 直接编码（直接控制）：操作控制字段每一位代表一个微命令 简单直观，输出直接用于控制，执行速度快 微指令字较长，使控存容量大 字段直接编码（显示编码）：操作控制字段分段，每个字段经译码发出微操作命令，且互斥 缩短字长，以较少二进制信息表示较多微命令信号 增加译码电路，执行速度降低 字段间接编码（隐式编码）：一个字段某些命令需由另一字段某些微命令解释 更能缩短微指令字长，但速度更慢 微指令序列地址形成 直接由微指令的下地址字段给出 根据机器指令的操作码形成 增量计数器法，即 （CMAR）+ 1 -&gt; CMAR 根据各钟标志决定微指令分支转移的地址 测试网络形成 硬件直接产生微程序入口地址 微指令格式 水平型：一次能定义多个并行操作的微命令。直接编码、字段直接编码、字段间接编码以及直接及混合编码都属于水平型指令格式 大多数微命令可直接控制对象，故每条微指令执行时间短 微指令字长较长，故可用较少微指令数实现一条机器指令的功能 垂直型：采用类似机器指令操作码方式，在微指令中设置微操作码字段，由微操作码规定微指令功能 经过译码控制对象，影响执行时间 微指令字长较短，实现一条机器指令微程序比水平型微指令长的多，以较长微程序结构换取较短微指令结构]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL基础]]></title>
    <url>%2F2019%2F07%2F02%2Fsql%2F</url>
    <content type="text"><![CDATA[[Updating] 本文梳理了 SQL 相关知识（基于《SQL基础教程》）]]></content>
      <categories>
        <category>data analysis</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github + Hexo 搭建博客]]></title>
    <url>%2F2019%2F06%2F30%2Fhexo%2F</url>
    <content type="text"><![CDATA[[Updating] 本文记录了使用Github和Hexo搭建该博客的过程 环境 系统：ubuntu 18.04 nodejs:： Hexo 的安装Node.js 的安装Hexo 的安装Git 的安装初步优化]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + NexT 的问题]]></title>
    <url>%2F2019%2F06%2F30%2Fhexo_problem_list%2F</url>
    <content type="text"><![CDATA[[Updating] 本文记录了 Hexo + NexT 使用过程中的一些问题 版本声明 hexo: 3.9.0 next: 7.0.1 local_search 不能用打开首页（本地or线上），打开浏览器开发工具 Network 选项卡，点击首页“搜索”按钮，观察 search.xml 状态： 200 问题：Algolia 问题 解决：主题配置文件中关闭 Algolia 404 其他 问题：存在非法字符 解决：sublime 排查 .md 文件中所存在非法字符 post_meta 不显示更新时间修改主题配置文件，post_meta 模块中设置： 123updated: enable: true anotherday: false]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
</search>
