<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Excel 快捷与函数]]></title>
    <url>%2F2019%2F09%2F21%2FExcel%E5%BF%AB%E6%8D%B7%E4%B8%8E%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[Updated] 本文记录了 EXCEL 的高频快捷用法和常用函数 Excel 快捷与函数1 快捷1.1 常用快捷操作 快捷键 功能 Ctrl+方向键 跳转至选中方向边缘的数据 Ctrl+Shift+方向键 框选当前位置到选中方向边缘的所有数据 Ctrl+空格键 框选当前列 Shift+空格键 框选当前行 Ctrl+f 查找 Ctrl+h 替换 Ctrl+Alt+v 选择性粘贴 Ctrl+t 隔行上色 1.2 自动填充自动填充数据和函数： 选中单元格，瞄准右下角时鼠标变为十字准星，向某一方向框选区域进行自动填充 选中单元格，瞄准右下角时鼠标变为十字准星，双击自动填充至边缘 框选区域，输入填充内容，快捷键 Ctrl+Enter 自动填充 智能填充： 在第一个单元格手工输入目标值； 框选填充区域； 快捷键 Ctrl+E，自动识别填充规则并进行填充。 1.3 锁定：$锁定行或列，常配合自动填充使用。 2 函数2.1 假设函数2.1.2 IF根据条件进行真假判断，返回真假对应结果： IF(判断条件, 条件为“真”的返回值， 条件为“假”的返回值) 判断条件可以为： 单个条件 AND(条件 1， 条件 2，……) OR(条件 1， 条件 2，……) 示例 说明 =IF(AND(A1 &gt; 1, A2 &gt; 1), 1, 0) A1、A2 都大于 1 则返回 1，否则返回0 2.1.3 COUNT计算包含数字的单元格个数以及参数列表中数字的个数: COUNT(value1, [value2], …) 示例 说明 =COUNT(A1:A5) 返回单元格区域 A1 到 A5 中包含数字的单元格的个数 2.1.4 COUNTIFS统计满足所有条件的次数： COUNTIFS(criteria_range1, criteria1, [criteria_range2, criteria2],…) 示例 说明 =COUNTIFS(A2:A17, “=1”, B2:B17, “&gt;1/1/2010”, C2:C17, “&lt;” &amp; D2) 返回满足“A=1，B 日期晚于 2010-1-1，C &lt; 单元格 D2 数字”条件的单元格的个数 2.1.5 SUMIF对范围中符合指定条件的值求和： SUMIF(range, criteria, [sum_range]) 示例 说明 =SUMIF(A1:A5, “&gt;100”) 返回 A1:A5 区域大于 100 的数值之和 =SUMIF(A1:A5, “=” &amp; C1, B1:B5) 返回 A1:A5 中等于 C1 对应的 Bi 之和 2.1.6 SUMIFS计算满足多个条件的全部参数的总量： SUMIFS(sum_range, criteria_range1, criteria1, [criteria_range2, criteria2], …) 示例 说明 =SUMIFS(A1:B5, B1:B5, “=A*”, C1:C5, “B”) 返回 A1:B5 区域中满足条件“Bi 为 ‘Axx..’ 且 Ci 为 ‘B’” 的 Ai 之和 2.2 数值函数2.2.1 SUM对选中区域数值求和： SUM(number1, [number2], …) 示例 说明 =SUM(A1:B5, D1:F5) 返回 A1:B5 和 D1:F5 区域值之和 快捷键：Alt+= 2.2.2 SUMPRODUCT返回对应的区域或数组的乘积（默认乘法，还可通过公式指定加、减、除）之和（执行完所有操作，最终操作总为求和）： SUMPRODUCT(array1, [array2], [array3], …) 示例 说明 =SUMPRODUCT(A1:A5, B1:B5) 对 A1:A5, B1:B5 对应乘积求和（常见：加权平均） 2.2.3 ROUND（UP/DOWN）对数字按指定位数（向上/向下）四舍五入： ROUND(number, num_digits) num_digits 大于 0（零），则将数字四舍五入到指定的小数位数。 num_digits 等于 0，则将数字四舍五入到最接近的整数。 num_digits 小于 0，则将数字四舍五入到小数点左边的相应位数。 示例 说明 =ROUND(3.14, 1) 四舍五入到一个小数位，返回 3.1 =ROUND(13.14, -1) 四舍五入到小数点左侧一位，返回 10 2.2.4 SUBTOTAL返回列表或数据库中的分类汇总： SUBTOTAL(function_num, ref1, [ref2],…) 其中，function_num 与函数对应表如下： Function_num 对应函数 1 101 AVERAGE 2 102 COUNT 3 103 COUNTA 4 104 MAX 5 105 MIN 6 106 PRODUCT 7 107 STDEV 8 108 STDEVP 9 109 SUM 10 110 VAR 11 111 VARP 示例 说明 =SUBTOTAL(9/109, A1:A5) 对 A1:A5 执行 9/109 代表的函数（求和） 2.2.5 LARGE返回数据集中第 k 个最大值： LARGE(array, k) 示例 说明 =LARGE(A1:B5, 5) 返回 A1:B5 区域第 5 大的值 2.3 定位查找函数2.3.1 VLOOKUP按行查找项目： VLOOKUP （查阅值、查阅值所在的区域、区域中包含返回值的列号、匹配模式） 查阅值：要查找的值 查阅值所在的区域：包含查阅值。查阅值应该始终位于所在区域的第一列 区域中包含返回值的列号：以 A2:C5 区域为例，A 为第一列，B 为第二列进行计数，依此类推 匹配模式：近似匹配（TRUE）或完全匹配（FALSE） 示例 说明 =VLOOKUP(A1, B1:D5, 2, FALSE) 在 Bi 列中找到精确等于 A1 的行，返回对应的 Ci（以 B 为首列，C 为第 2 列） =IF(VLOOKUP(A1, B1:D5, 2, FALSE)=’C’, ‘找到’, ‘未找到’) 在 Bi 列中找到精确等于 A1 的行，取出对应的 Ci，若 Ci 为 ‘C’，返回’找到’, 否则返回’未找到’。 2.3.2 LOOKUP在单行区域或单列区域（称为“向量”）中查找值，然后返回第二个单行区域或单列区域中相同位置的值： LOOKUP(lookup_value, lookup_vector, [result_vector]) lookup_value：LOOKUP 在第一个向量中搜索的值，可以是数字、文本、逻辑值、名称或对值的引用 lookup_vector：只包含一行或一列的区域 注： lookup_vector 中的值必须按升序排列：…, -2, -1, 0, 1, 2, …, A-Z, FALSE, TRUE；否则，LOOKUP 可能无法返回正确的值。 文本不区分大小写。 如果 LOOKUP 函数找不到 lookup_value，则该函数会与 lookup_vector 中小于或等于 lookup_value 的最大值进行匹配。 如果 lookup_value 小于 lookup_vector 中的最小值，则 LOOKUP 会返回 #N/A 错误值 result_vector：只包含一行或一列的区域，与 lookup_vector 大小必须相同 示例 说明 =LOOKUP(C1, A1:A5, B1:B5) 返回 A1:A5 中等于 C1 的行对应的 Bi 2.3.3 MATCH在选中单元格中搜索特定的项，然后返回该项在此区域中的相对位置： MATCH(lookup_value, lookup_array, [match_type]) Match_type 说明 1 或缺省 查找小于或等于 lookup_value 的最大值。 lookup_array 参数中的值必须以升序排序 0 查找完全等于 lookup_value 的第一个值。 lookup_array 参数中的值可按任何顺序排列 -1 查找大于或等于 lookup_value 的最小值。 lookup_array 参数中的值必须按降序排列 示例 说明 =MATCH(“b”, {“a”,”b”,”c”}, 0) 返回 “b” 在 {“a”,”b”,”c”} 中的相对位置 2.3.4 INDEX返回表格或区域中的值或值的引用： INDEX(array, row_num, [column_num]) 数组只包含一行或一列：相应的 row_num 或 column_num 参数是可选的 数组具有多行和多列, 并且仅使用 row_num 或 column_num：返回数组中整个行或列的数组 同时使用 row_num 和 column_num 参数：返回 row_num 和 column_num 交叉处的单元格中的值。该值必须在数组中，否则将返回 #REF! 错误。 示例 说明 =INDEX(A1:B5, 2, 3) 返回 A1:B5 区域第 2 行第 3 列交叉处的值 2.4 格式函数2.4.1 IS检验指定值并根据结果返回 TRUE 或 FALSE： IS**(value) 函数 | 说明-|-|-ISBLANK | 值为空白单元格ISERR | 值为任意错误值（除去 #N/A）ISERROR | 值为任意错误值（#N/A、#VALUE!、#REF!、#DIV/0!、#NUM!、#NAME? 或 #NULL!）ISLOGICAL | 值为逻辑值ISNA | 值为错误值 #N/A（值不存在）ISNONTEXT | 值为不是文本的任意项。 （请注意，此函数在值为空单元格时返回 TRUE）ISNUMBER | 值为数字ISREF | 值为引用ISTEXT | 值为文本 2.4.2 LEFT/RIGHT/MID文本字符串[从左起 | 从右起 | 字符串中的指定位置]第一个字符开始返回指定个数的字符： LEFT/RIGHT(text, [num_chars])MID(text, start_num, num_chars) 示例 说明 =LEFT/RIGHT(A1, 3) A1 左/右边第 1 个字符起，返回 3 个字符 =MID(A1, 3, 5) A1 第 3 个字符起，返回 5 个字符]]></content>
      <categories>
        <category>Excel</category>
      </categories>
      <tags>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL基础速览]]></title>
    <url>%2F2019%2F07%2F02%2Fsql%2F</url>
    <content type="text"><![CDATA[[Updated] 本文梳理了 SQL 相关基础知识（基于《SQL基础教程》） SQL 基础 SQL 概要标准 SQL国际标准化组织（ISO）为 SQL 制定的相应标准，适用于各种 RDBMS SQL 语句及其种类由关键字、表名、列名等组合而成一条 SQL 语句描述操作的内容 DDL（Data Definition Language，数据定义语言）用来创建或者删除存储数据用的数据库以及数据库中的表等对象。包含指令： CREATE： 创建数据库和表等对象 DROP： 删除数据库和表等对象 ALTER： 修改数据库和表等对象的结构 DML（Data Manipulation Language，数据操纵语言）用来查询或者变更表中的记录。包含指令： SELECT：查询表中的数据 INSERT：向表中插入新数据 UPDATE：更新表中的数据 DELETE：删除表中的数据 DCL（Data Control Language，数据控制语言）用来确认或者取消对数据库中的数据进行的变更。除此之外，还可以对 RDBMS 的用户是否有权限操作数据库中的对象（数据库表等）进行设定。包含指令： COMMIT： 确认对数据库中的数据进行的变更 ROLLBACK： 取消对数据库中的数据进行的变更 GRANT： 赋予用户操作权限 REVOKE： 取消用户的操作权限 SQL 的基本书写规则 以分号（；）结尾 SQL 不区分关键字大小写；表中数据区分大小写 SQL 一般书写原则： 关键字大写 表名首字母大写 其余（列名）小写 SQL 子句的顺序不能改变，也不能互相替换 表的创建数据库的创建（CREATE DATABASE语句）1CREATE DATABASE &lt;数据库名&gt;; 表的创建（CREATE TABLE语句）123456CREATE TABLE &lt;表名&gt;(&lt;列名1&gt; &lt;数据类型&gt; &lt;该列所需约束&gt;, &lt;列名2&gt; &lt;数据类型&gt; &lt;该列所需约束&gt;, …… &lt;列名n&gt; &lt;数据类型&gt; &lt;该列所需约束&gt;, &lt;该表约束1&gt;, &lt;该表约束2&gt;, ……); NOT NULL 约束只能以列为单位进行设置 列的数据类型必须指定 列的约束可以定义时设置，也可以语句末尾设置 命名规则 数据库/表/列名：半角英文字母、数字、下划线(_) 标准 SQL 中名称必须以半角英文字母开头 名称不能重复 数据类型的指定 INTEGER：整数 CHAR：定长字符串 括号中指定可存储字符串长度 超出部分无法输入到列中 不足部分由半角空格进行补足。如：char(10)存”123”，存储字符占10个字节。取数据的时候，char类型的要用trim()去掉多余的空格 比 VARCHAR 效率高，空间换时间 VARCHAR：可变长字符串 括号指定最大长度 不足部分不会使用半角空格进行补足，会自动裁剪。如：varchar(10)存”123”，存储字符占3个字节 比 CHAR 节省空间 DATE：日期 含年/月/日 Oracle 中 DATE 型还包含时分秒 约束的设置 键：指定特定数据时使用的列的组合 主键（primary key）：可以唯一确定一行数据的列（故无法重复） 表的删除和更新表的删除（DROP TABLE语句）1DROP TABLE &lt;表名&gt;; 删除表无法回复，只能重建 避免到需要恢复数据的场景 表定义的更新（ALTER TABLE语句）添加列 1ALTER TABLE &lt;表名&gt; ADD COLUMN &lt;列的定义&gt;; 删除列 1ALTER TABLE &lt;表名&gt; DROP COLUMN &lt;列名&gt;; 表定义变更（ALTER TABLE）之后无法恢复 不同数据库提供不同变更表名（RENAME）（非标准 SQL）指令。如：MySQL 中， 1RENAME TABLE &lt;原表名&gt; to &lt;新表名&gt;; 查询基础SELECT语句基础列的查询12SELECT &lt;列名&gt;，…… FROM &lt;表名&gt;； &lt; * &gt; 按表定义列的顺序列出所有列 不建议使用 &lt; * &gt;；建议列出所有列名，以提高 SQL 可读性 为列或表设定别名123SELECT 列名1 AS 别名1, 列名2 AS 别名2 FROM 表名 AS 表别名; 别名可使用中文，使用时将中文用双引号 &lt;” “&gt; 括起来 别名中空格建议用下划线取代。使用双引号可以设定包含空格的别名，但若忘记使用双引号可能导致错误 Oracle 的 FROM 子句中不能使用 AS（会发生错误），表别名直接跟在表名后即可（即不加 AS） 从结果中删除重复行使用 DISTINCT 实现删除由选择列出的列合成的数据中的重复行 12SELECT DISTINCT &lt;列名&gt;, …… FROM Product; 使用 DISTINCT 时， NULL 也被视为一类数据（显示为空白） DISTINCT 关键字只能用在第一个列名之前 通过 WHERE 子句来指定查询数据的条件123SELECT &lt;列名&gt;, …… FROM &lt;表名&gt; WHERE &lt;条件表达式&gt;; 书写顺序：WHERE 子句必须紧跟在 FROM 子句之后，否则会造成执行错误 执行顺序：首先通过 WHERE 子句查询出符合指定条件的记录，然后再选取出 SELECT 语句指定的列 注释的书写方法 英汉字皆可 单行注释：书写在 “–” 之后 多行注释：书写在 “/“ 和 “/“ 之间 算术运算符和比较运算符算术运算符SELECT 子句中可以使用常数或者表达式：+ - * ÷ () 所有包含 NULL 的计算，结果肯定是 NULL（包括“NULL/0”的情况，不会报错） FROM 子句在 SELECT 语句中并不是必不可少的，只使用SELECT子句进行计算也是可以的，但使用场景很少。如： 1SELECT (1 + 2) * 3 AS calculation; 存在不允许省略 SELECT 语句中的 FROM 子句的 RDBMS。如：Oracle 比较运算符 =、&lt;、&gt;：等于、小于、大于 &lt;&gt;:不相等。“!=” 非标准 SQL，考虑可移植性和安全问题 , 不建议使用 &lt;=、&gt;=：不大于、不小于。必须不等号在左，等号在右 字符串类型的数据原则上按照字典顺序进行排序。该规则对定长字符串和可变长字符串都适用 SQL 用“IS NULL”和“IS NOT NULL”判断数据是否为NULL。因为SQL 不识别“= NULL”和“&lt;&gt; NULL”，所以不能对 NULL 使用比较运算符 逻辑运算符NOT运算符 NOT 不能单独使用，必须组合其他查询条件表“不是该条件” 为保持程序清晰可读，不滥用 NOT AND 运算符和 OR 运算符 AND 运算符在其两侧的查询条件都成立时整个查询条件才成立，其意思相当于“并且” OR 运算符在其两侧的查询条件有一个成立时整个查询条件都成立，其意思相当于“或者” AND 运算符的优先级高于 OR 运算符 建议使用括号强化优先级，使语句更清晰可读 真值 真值：值为真（TRUE） 或假（FALSE） 其中之一的值 AND 运算的结果与乘法运算（积）的结果一样，称逻辑积 OR 运算的结果与加法运算（和）的结果一样，称逻辑和 SQL 特有情况 – 三值逻辑：除真值外，还存在“不确定”（UNKNOWN）这样的值： P Q P AND Q P OR Q 真 不确定 不确定 真 假 不确定 假 不确定 不确定 真 不确定 真 不确定 假 假 不确定 不确定 不确定 不确定 不确定 建议尽量不使用 NULL，为列设置 NOT NULL 约束，以避免繁琐的条件判断 聚合与排序对表进行聚合查询聚合函数将多行输入汇总为一行输出 COUNT： 计算表中的记录数（行数） COUNT() 特性：不会排除 NULL。故 COUNT()会得到包含 NULL 的数据行数，而 COUNT(&lt;列名&gt;) 会得到 NULL 之外的数据行数 所有的聚合函数，如果以列名为参数，那么在计算之前会把 NULL 排除在外，与“等价为 0”并不相同 SUM： 计算表中 数值列 中数据的合计值 AVG： 计算表中 数值列 中数据的平均值 会事先删除 NULL 同时减少相应数据条数再计算。但也可以选择将 NULL 改变为 0 进行计算 MAX： 求出表中 任意列（如日期） 中数据的最大值 MIN： 求出表中 任意列（如日期）中 数据的最小值 使用聚合函数删除重复值（关键字DISTINCT）12SELECT COUNT(DISTINCT &lt;列名&gt;) FROM &lt;表名&gt;; DISTINCT 必须写在聚合函数参数（即括号）中，因为必须要在执行之前删除列中的重复数据 计算值的种类：在 COUNT() 的参数中使用 DISTINCT 对表进行分组GROUP BY1234SELECT &lt;列名1&gt;, &lt;列名2&gt;, &lt;列名3&gt;, …… FROM &lt;表名&gt; WHERE GROUP BY &lt;列名1&gt;, &lt;列名2&gt;, &lt;列名3&gt;, ……; 聚合键/分组列：GROUP BY 子句中指定的列 书写顺序：SELECT → FROM → WHERE → GROUP BY 执行顺序：FROM → WHERE → GROUP BY → SELECT 聚合键中包含 NULL 时，在结果中会以“不确定”行（空行）的形式表现出来 使用聚合函数和 GROUP BY 注意事项 使用聚合函数时， SELECT 子句中只能存在以下三种元素： 常数 聚合函数 GROUP BY 子句中指定的列名（也就是聚合键） 虽然 MySQL 支持使用GROUP BY子句时， SELECT 子句中出现聚合键之外的列名，但是 MySQL 以外的 DBMS 都不支持这样的语法，因此不建议使用 在 GROUP BY子 句中不能使用 SELECT 子句中定义的别名。根据执行顺序，执行 GROUP BY 子句时，DBMS 还不知道 SELECT 子句中定义的别名 GROUP BY子句结果的显示是无序的。可在 SELECT 语句中进行指定特定顺序 只有 SELECT 子句和 HAVING 子句（以及 ORDER BY 子句）中能够使用聚合函数 DISTINCT 和 GROUP BY：都是通过数据的内部排序处理实现的（执行速度相近），可删除重复数据。根据使用场景，选择能清晰表明语义的写法 为聚合结果指定条件HAVING 子句WHERE 子句只能指定记录（行）的条件，而不能用来指定组的条件。对集合指定条件使用 HAVING 子句： 1234SELECT &lt;列名1&gt;, &lt;列名2&gt;, &lt;列名3&gt;, …… FROM &lt;表名&gt;GROUP BY &lt;列名1&gt;, &lt;列名2&gt;, &lt;列名3&gt;, ……HAVING &lt;分组结果对应的条件&gt; 书写顺序：SELECT → FROM → WHERE → GROUP BY → HAVING 执行顺序：FROM → WHERE → GROUP BY → SELECT HAVING 注意事项 HAVING 子句中只能存在以下三种元素： 常数 聚合函数 GROUP BY 子句中指定的列名（即聚合键） 聚合键所对应的条件应该书写在 WHERE 子句当中，而不应该书写在 HAVING 子句当中。理由如下： HAVING 子句是用来指定“组”的条件的。因此，“行”所对应的条件还是应该写在 WHERE 子句当中，便于理解区分功能 通常情况下，为了得到相同的结果，将条件写在 WHERE 子句中要比写在 HAVING 子句中的处理速度更快，返回结果所需的时间更短 为了理解其中原因，就要从 DBMS 的内部运行机制来考虑。使用 COUNT 函数等对表中的数据进行聚合操作时，DBMS 内部就会进行排序处理。排序处理是会大大增加机器负担的高负荷的处理 A。因此，只有尽可能减少排序的行数，才能提高处理速度。通过 WHERE 子句指定条件时，由于排序之前就对数据进行了过滤，因此能够减少排序的数据量。但 HAVING 子句是在排序之后才对数据进行分的，因此与在 WHERE 子句中指定条件比起来，需要排序的数据量就会多得多。虽然 DBMS 的内部处理不尽相同，但是对于排序处理来说，基本上都是一样的。此外， WHERE 子句更具速度优势的另一个理由是，可以对 WHERE 子句指定条件所对应的列创建索引，这样也可以大幅提高处理速度。创建索引是一种非常普遍的提高 DBMS 性能的方法，效果也十分明显，这对 WHERE 子句来说也十分有利。 对查询结果进行排序ORDER BY子句123SELECT &lt;列名1&gt;, &lt;列名2&gt;, &lt;列名3&gt;, …… FROM &lt;表名&gt; ORDER BY &lt;排序基准列1&gt;, &lt;排序基准列2&gt;, ……; 书写顺序：SELECT → FROM → WHERE → GROUP BY → HAVING → ORDER BY ORDER BY 子句通常写在 SELECT 语句的末尾 未指定 ORDER BY子句中排列顺序时会默认使用升序进行排列；使用 DESC 关键字降序排列 ORDER BY 注意事项 多键排序规则：优先使用左侧的键，如果该列存在相同值的话，再接着参考右侧的键 排序键中包含 NULL 时，会在开头或末尾进行汇总（因为不能对 NULL 使用比较运算符） 在 ORDER BY 子句中可以使用 SELECT 子句中定义的别名。因为 SELECT 子句的执行顺序在 GROUP BY 子句之后， ORDER BY 子句之前 在 ORDER BY 子句中可以使用 SELECT 子句中未使用的列和聚合函数 不要使用列编号指定排序键： 可读性差 SQL-92A 中明确该功能将来会被删除 列编号 – SELECT 子句中的列按照从左到右的顺序进行排列时所对应的编号（1, 2, 3, …） 数据更新数据的插入（INSERT语句的使用方法）INSERT 语句1INSERT INTO &lt;表名&gt; (列1, 列2, 列3, ……) VALUES (值1, 值2, 值3, ……); 原则上，执行一次INSERT语句会插入一行数据,表名后面的列清单和 VALUES 子句中的值清单的列数必须保持一致 很多 RDBMS 都支持多行 INSERT： 1INSERT INTO &lt;表名&gt; (列1, 列2, 列3, ……) VALUES (值1, 值2, 值3, ……), (值1, 值2, 值3, ……) …… ; 列清单的省略 1INSERT INTO &lt;表名&gt; VALUES (值1, 值2, 值3, ……), (值1, 值2, 值3, ……) …… ; 插入NULL：插入 NOT NULL 约束的列会报错 INSERT， DELETE 和 UPDATE 等更新语句也一样，SQL 语句执行失败时都不会对表中数据造成影响 默认插入值在创建表的 CREATE TABLE 语句中设置 DEFAULT 约束来设定默认值： 1234CREATE TABLE ProductIns(&lt;列名&gt; CHAR(4) NOT NULL, &lt;列名&gt; INTEGER DEFAULT 0, -- 销售单价的默认值设定为0;……); 显式方法插入默认值：在 VALUES 中指定 DEFAULT 关键字 1INSERT INTO &lt;表名&gt; (&lt;列名1&gt;, &lt;列名2&gt;, ……) VALUES (DEFAULT, DEFAULT, ……); 隐式方法插入默认值：在列清单和 VALUES 中省略要设定默认值的列 1INSERT INTO &lt;表名&gt; (&lt;列名1&gt;, &lt;列名3&gt;, ……) VALUES (DEFAULT, DEFAULT, ……); -- 列2设定默认值 从其他表中复制数据 创建一张结构一样的表 旧表数据插入新表： 123INSERT INTO 旧表 (&lt;列名1&gt;, &lt;列名2&gt;, ……)SELECT &lt;列名1&gt;, &lt;列名2&gt;, ……FROM 新表; INSERT 语句的 SELECT 语句中，可以使用 WHERE 子句或者 GROUP BY 子句等何 SQL 语法（除 ORDER BY） 指定 ORDER BY 子句也没有任何意义，因为无法保证表内部记录的排列顺序 数据的删除（DELETE语句的使用方法）DELETE语句1234DELETE FROM &lt;表名&gt;; -- 保留数据表，清空表全部数据DELETE FROM &lt;表名&gt; -- 删除表中指定条件数据 WHERE &lt;条件&gt;; 注意事项 DELETE 语句中只能使用 WHERE，而不能使用 GROUP BY、HAVING 和 ORDER BY。因为： GROUP BY 和 HAVING 是从表中选取数据时用来改变抽取数据形式的 ORDER BY 是用来指定取得结果显示顺序的 TRUNCATE：删除表中全部数据1TRUNCATE &lt;表名&gt;; 非标准SQL；Oracle、SQL Server、PostgreSQL、MySQL 和 DB2 不能通过 WHERE 子句指定条件来删除部分数据 数据的更新（UPDATE语句的使用方法）UPDATE 语句123UPDATE &lt;表名&gt; SET &lt;列名&gt; = &lt;表达式/NULL&gt; -- NULL 只限于未设置 NOT NULL 约束的列 WHERE &lt;条件&gt;; 多列更新 法一：所有 DBMS 通用 12345-- 使用逗号对列进行分隔排列UPDATE &lt;表名&gt; SET &lt;列名1&gt; = &lt;表达式1&gt;, &lt;列名2&gt; = &lt;表达式2&gt; WHERE &lt;条件&gt;; 法二：非通用 1234-- 将列用()括起来的清单形式UPDATE Product SET (列名1, 列名2) = (表达式1, 表达式2) WHERE &lt;条件&gt;; 事务什么是事务需要在同一个处理单元中执行的一系列更新处理的集合。例如： 现要求完成往表1插入新数据并更新一些旧数据的任务。要完成该任务，插入和更新两种操作都要完成，则一定要使用事务进行处理（将一起要完成的操作打包进一个事务中进行处理） 创建事务12345事务开始语句;DML语句①;DML语句②;……事务结束语句（ COMMIT或者ROLLBACK） ; 在标准 SQL 中并没有定义事务的开始语句，而是由各个 DBMS 自己来定义的 SQL Server、PostgreSQL： BEGIN TRANSACTIONBEGIN TRANSACTION MySQL： START TRANSACTION Oracle、DB2：无 实际上，几乎所有的数据库产品的事务都无需开始指令。因为大部分情况下，事务在数据库连接建立时就已经开始，并不需要用户再明确发出开始指令 事务结束语句在所有的 RDBMS 中都是通用，只有 COMMIT 和 ROLLBACK 两种： COMMIT – 是提交事务包含的全部更新处理的结束指令，相当于文件处理中的覆盖保存。一旦提交，就无法恢复到事务开始前的状态了 ROLLBACK – 是取消事务包含的全部更新处理的结束指令，相当于文件处理中的放弃保存。一旦回滚，数据库就会恢复到事务开始之前的状态 在不使用指令而悄悄开始事务的情况下，区分各个事务有以下两种模式（通常 DBMS 都可以设置任选其一）： 自动提交模式 – 每条SQL语句就是一个事务（MySQL、SQL Server 和 PostgreSQL 默认使用） 直到用户执行 COMMIT 或者 ROLLBACK 为止算作一个事务（Oracle 默认使用） 若使用 DELETE 语句删除了数据表： 自动提交模式下，无法回滚恢复 非自动提交模式下，可以通过 ROLLBACK 命令取消该事务的处理，恢复表中的数据。但这仅限于明示开始事务，或者关闭自动提交的情况 ACID特性 原子性（Atomicity） 原子性是指在事务结束时，其中所包含的更新处理要么都执行，要么都不执行 一致性（Consistency）/完整性 一致性指的是事务中包含的处理要满足数据库提前设置的约束 隔离性（Isolation） 隔离性指的是保证不同事务之间互不干扰的特性。该特性保证了事务之间不会互相嵌套。此外，在某个事务中进行的更改，在该事务结束之前，对其他事务而言是不可见的 持久性（Durability） 持久性指的是在事务（不论是提交还是回滚）结束后， DBMS 能够保证该时间点的数据状态会被保存的特性。即使由于系统故障导致数据丢失，数据库也一定能通过某种手段进行恢复，如日志系统 复杂查询视图视图：保存好的 SELECT 语句 视图和表区别：表中存储的是实际数据，而视图中保存的是从表中取出数据所使用的SELECT语句 视图的优点： 无需保存数据，节省存储设备的容量 将频繁使用的 SELECT 语句保存成视图，不用重写重新执行，以提高效率 创建视图123CREATE VIEW 视图名称(&lt;视图列名1&gt;, &lt;视图列名2&gt;, ……)AS&lt;SELECT语句&gt; SELECT 语句中列的排列顺序和视图中列的排列顺序相同 多重视图：以视图为基础创建视图。多重视图会降低 SQL 的性能应尽量避免 使用视图查询 首先执行定义视图的 SELECT 语句 根据得到的结果，再执行在 FROM 子句中使用视图的 SELECT 语句 视图的限制 定义视图时不能使用 ORDER BY 子句 视图和表一样， 数据行都是没有顺序的 对视图进行更新 标准 SQL 中规定，想要视图可以被更新，定义视图的 SELECT 语句需要满足某些条件（非通过汇总）： SELECT 子句中未使用 DISTINCT FROM 子句中只有一张表 未使用 GROUP BY 子句 未使用 HAVING 子句 原因：视图和表需要同时进行更新，以保持数据一致性，因此通过汇总得到的视图无法进行更新 删除视图1DROP VIEW 视图名称(&lt;视图列名1&gt;, &lt;视图列名2&gt;, ……)； 子查询子查询和视图子查询就是将用来定义视图的 SELECT 语句直接用于 FROM 子句当中（为查询结果命别名） 子查询作为内层查询会首先执行 原则上子查询必须设定名称（使用 AS 关键字） 标量子查询标量子查询就是返回单一值的子查询 优点：返回的是单一值，可以用在 = 或者 &lt;&gt; 等比较运算符之中 书写位置：能够使用常数或者列名的地方 注意事项：子查询中只能返回单一值 关联子查询（建议刷题理解）与普通的子查询的区别在子查询中添加的 WHERE 子句的条件 为区别表对应不同的场景，在表所对应的列名之前加上表的别名，形式为“&lt;表名&gt;.&lt;列名&gt;” 适合在细分的组内进行比较时使用 结合条件一定要写在子查询中 函数、谓词、CASE表达式函数函数的种类 算术函数：数值计算 字符串函数：字符串操作 日期函数：日期操作 转换函数：转换数据类型和值 聚合函数：数据聚合 算术函数 绝对值函数 1ABS(数值) 求余 1MOD(被除数，除数) [注] SQL Server 不支持 MOD()，而使用 “%” 求余 四舍五入 1ROUND(对象数值，保留小数的位数) 字符串函数 拼接 1字符串1 || 字符串2 || 字符串3 || …… [注] SQL Server 不支持 ||，而使用 “+” 拼接字符串 MySQL 不支持 ||，而使用 CONCAT() 拼接字符串 字符串长度 1LENGTH(字符串) [注] SQL Server 不支持 LENGTH()，而使用 LEN() 拼接字符串 同样是 LENGTH 函数，不同 DBMS 的执行结果也不尽相同。MySQL 中的 LENGTH() 以字节为单位的函数进行计算,此外还存在计算字符串长度的自有函数 CHAR_LENGTH() 大小写转换 1UPPER/LOWER(字符串) [注] UPPER/LOWER 函数只能针对英文字母使用，将参数中的字符串全都转换为大/小写 字符串替换 1REPLACE(对象字符串，替换前的字符串，替换后的字符串) 字符串截取 1SUBSTRING（对象字符串 FROM 截取的起始位置 FOR 截取的字符数） [注] 标准 SQL，但只有 PostgreSQL 和 MySQL 支持该语法 SQL Server 版本： SUBSTRING(对象字符串，截取的起始位置，截取的字符数) Oracle 版本： SUBSTR(对象字符串，截取的起始位置，截取的字符数) 日期函数 当前日期 1CURRENT_DATE [注] SQL Server 不支持 CURRENT_DATE，而使用 CAST(CURRENT_TIMESTAMP AS DATE) 获取当前日期 当前时间 1CURRENT_TIME [注] SQL Server 不支持 CURRENT_TIME，而使用 CAST(CURRENT_TIMESTAMP AS TIME) 获取当前时间 当前日期和时间 1CURRENT_TIMESTAMP 截取日期元素 1EXTRACT(日期元素 FROM 日期) [注] 日期元素： YEAR MONTH DAY HOUR MINUTE SECOND SQL Server 不支持 EXTRACT 函数，而使用 DATEPART 函数 获取当前时间 DATEPART(日期元素 , CURRENT_TIMESTAMP) 转换函数 CAST —— 数据类型转换 1CAST（转换前的值 AS 想要转换的数据类型） [注] 使用场景： 插入与表中数据类型不匹配的数据 在进行运算时由于数据类型不一致发生了错误 进行自动类型转换会造成处理速度低下 COALESCE —— 将NULL转换为其他值 返回可变参数 A 中左侧开始第 1个不是 NULL 的值 1COALESCE(数据1，数据2，数据3……) 谓词 – 返回值是真值的函数LIKE – 模糊查询123SELECT * FROM &lt;表名&gt; WHERE &lt;列名&gt; LIKE '模式'; % 代表“0 个字符以上的任意字符串” _（下划线）代表了“任意 1 个字符” 模式 匹配 abc% abcqwe %abc% qweabcqwe %abc qweabc abc__ abcqw abc eabcq _abc qabc BETWEENT —— 范围查询123SELECT * FROM &lt;表名&gt; WHERE &lt;列名&gt; BETWEEN &lt;上限&gt; AND &lt;下限&gt;; 数据可以是数值、文本或者日期 BETWEEN 的结果包含 &lt;上限&gt; 和 &lt;下限&gt;。不想让结果包含临界值则使用 &lt; 和 &gt; IS (NOT) NULL —— 判断是否为NULL选取出某些值为（不为） NULL 的列的数据只能使用特定的谓词 IS (NOT) NULL 123SELECT * FROM &lt;表名&gt; WHERE &lt;列名&gt; IS (NOT) NULL; IN 谓词 —— OR 的简便用法123SELECT * FROM &lt;表名&gt; WHERE &lt;列名&gt; (NOT) IN (集合元素……/子查询); 使用 IN 和 NOT IN 无法选取出 NULL 数据，因为 NULL 只能使用 IS (NOT) NULL 选取 EXIST 谓词判断是否存在满足某条件的记录 123SELECT * FROM &lt;表名&gt; WHERE &lt;列名&gt; (NOT) EXIST (集合元素……/子查询); 通常指定关联子查询作为 EXIST 的参数 由于 EXIST 只关心记录是否存在，因此子查询中返回哪些列都没有关系（建议统一在 EXIST 的子查询中书写 SELECT *） 与 in 执行时的区别：in 先执行子查询中的查询，再执行主查询；exists 先执行主查询，即外层表的查询，再执行子查询。效率视情况而定 CASE 表达式 – 区分情况执行CASE表达式 搜索 CASE 表达式语法 123456CASE WHEN &lt;求值表达式&gt; THEN &lt;表达式&gt; WHEN &lt;求值表达式&gt; THEN &lt;表达式&gt; WHEN &lt;求值表达式&gt; THEN &lt;表达式&gt; …… ELSE &lt;表达式&gt;END 执行过程： 第一条 WHEN 子句中的“&lt; 求值表达式 &gt;”求值 结果为真（TRUE），返回 THEN 子句中的表达式， 执行完毕；结果不为真，顺次转到下一条 WHEN 子句进行求值…… 若到最后一条 WHEN 子句为止返回结果都不为真，则返回 ELSE 中的表达式 执行完毕 ELSE 子句也可以省略不写，这时会被默认为 ELSE NULL，但不建议省略 END 不能省略 集合运算表的集合运算（以行方向为单位进行操作）Def进行这些集合运算时，会导致记录行数的增减，但不会导致列数的改变 UNION（并集）表 a 和 表 b 的并集 12345SELECT &lt;列名&gt;, …… FROM &lt;a 表名&gt; UNION （ALL）SELECT &lt;列名&gt;, …… FROM &lt;b 表名&gt;; INTERSECT（交集）表 a 和 表 b 的交集 12345SELECT &lt;列名&gt;, …… FROM &lt;a 表名&gt;INTERSECT （ALL）SELECT &lt;列名&gt;, …… FROM &lt;b 表名&gt;; EXCEPT（差集）表 a 和 表 b 的差集，即表 a 除去与表 b 交集部分所剩余的部分 12345SELECT &lt;列名&gt;, …… FROM &lt;a 表名&gt;EXCEPTSELECT &lt;列名&gt;, …… FROM &lt;b 表名&gt;; MySQL 不支持 EXCEPT Oracle 中求差集将 “EXCEPT” 改为 “MINUS” 集合运算注意事项 集合运算符会除去重复的记录。使用 ALL 选项，可以保留重复行 作为运算对象的记录的列数必须相同 作为运算对象的记录中列的类型必须一致 可以使用任何 SELECT 语句，但 ORDER BY 子句只能在最后使用一次 联结（以列为单位对表进行联结）Def将其他表中的列添加过来，进行“添加列”的运算 内联结——INNER JOIN以两张表中都包含的列（联结键）作为桥梁，将只存在于一张表内的列汇集到同一结果之中 12345SELECT &lt;表1别名&gt;.&lt;列名&gt;, …， &lt;表2别名&gt;.&lt;列名&gt;, … FROM &lt;表1&gt; AS &lt;表1别名&gt; INNER JOIN &lt;表2&gt; AS &lt;表2别名&gt; ON 表1.&lt;共同列&gt; = 表2.&lt;共同列&gt; WHERE …… 外联结——OUTER JOIN通过 ON 子句的联结键将两张表进行联结，并从两张表中同时选取相应的列 12345SELECT &lt;表1别名&gt;.&lt;列名&gt;, …， &lt;表2别名&gt;.&lt;列名&gt;, … FROM &lt;表1&gt; AS &lt;表1别名&gt; LEFT/RIGHT JOIN &lt;表2&gt; AS &lt;表2别名&gt; ON 表1.&lt;共同列&gt; = 表2.&lt;共同列&gt; WHERE …… 与内联结区别 内联结只能选取出同时存在于两张表中的数据 对于外联结，只要数据存在于某一张表当中，就能够读取出来 外联结中使用LEFT、RIGHT来指定主表，最终的结果中会包含主表内所有的数据 多表联结通过 ON 子句的联结键将多张表进行联结。 1234567SELECT &lt;表1别名&gt;.&lt;列名&gt;, …， &lt;表2别名&gt;.&lt;列名&gt;, … FROM &lt;表1&gt; AS &lt;表1别名&gt; INNER JOIN &lt;表2&gt; AS &lt;表2别名&gt; ON 表1.&lt;共同列&gt; = 表2.&lt;共同列&gt; INNER JOIN &lt;表3&gt; AS &lt;表3别名&gt; ON 表1.&lt;共同列&gt; = 表3.&lt;共同列&gt; WHERE …… 如下例子中表 1 与表 2 联结，表 1 与表 3 联结，则表 2 与表 3 无需再联结 “表 1 与表 3 联结”改为“表 2 与表 3 联结”，效果一样 SQL 高级处理窗口函数窗口函数的语法12&lt;窗口函数&gt; OVER (PARTITION BY &lt;列清单&gt;) ORDER BY &lt;排序用列清单&gt;) 通过 PARTITION BY 分组后的记录集合称为“窗口”（意指“范围”）。PARTITION BY 并非必需，不指定 PARTITION BY 时，将整个表作为一个大的窗口来使用 OVER 子句中的 ORDER BY 只是用来决定窗口函数按照什么样的顺序进行计算的，对结果的排列顺序并没有影响。对结果排序需要在 SELECT 语句的最后使用 ORDER BY 子句，此时两个 ORDER BY 功能完全不同 窗口函数兼具分组和排序两种功能 能够作为窗口函数使用的函数 能够作为窗口函数的聚合函数（SUM、AVG、COUNT、MAX、MIN） RANK、DENSE_RANK、ROW_NUMBER 等专用窗口函数 以专用窗口函数 RANK 为例 1234SELECT &lt;列1&gt;, &lt;列2&gt;, &lt;列3&gt;， … RANK () OVER (PARTITION BY &lt;列2&gt; ORDER BY &lt;列3&gt;) AS ranking FROM &lt;表名&gt;; PARTITION BY 能够设定排序的对象范围 ORDER BY 能够指定按照哪一列、何种顺序进行排序 专用窗口函数 RANK函数 计算排序时，如果存在相同位次的记录，则会跳过之后的位次。 例：有 3 条记录排在第 1 位时：1 位、1 位、1 位、4 位…… DENSE_RANK函数 同样是计算排序，即使存在相同位次的记录，也不会跳过之后的位次。 例：有 3 条记录排在第 1 位时：1 位、1 位、1 位、2 位…… ROW_NUMBER函数 赋予唯一的连续位次。 例：有 3 条记录排在第 1 位时：1 位、2 位、3 位、4 位…… 专用窗口函数无需参数，因此通常参数括号中都是空的 作为窗口函数使用的聚合函数以专用 AVG() 为例 123SELECT &lt;列1&gt;, &lt;列2&gt;, &lt;列3&gt;， …， AVG (指定列) OVER (ORDER BY &lt;指定列&gt;) AS ranking FROM &lt;表名&gt;; 得到的结果按照 ORDER BY 子句指定列的升序排列，一行一行逐渐添加计算对象，累计进行聚合函数运算 聚合函数作为窗口函数时的最大特征：以当前记录作为基准进行统计 窗口函数的适用范围原则上，窗口函数只能书写在 SELECT 子句中。 在 DBMS 内部，窗口函数是对 WHERE 子句或者 GROUP BY 子句处理后的“结果”进行的操作。大家仔细想一想就会明白，在得到用户想要的结果之前，即使进行了排序处理，结果也是错误的。在得到排序结果之后，如果通过 WHERE 子句中的条件除去了某些记录，或者使用 GROUP BY 子句进行了汇总处理，那好不容易得到的排序结果也无法使用了。反之，之所以在 ORDER BY 子句中能够使用窗口函数，是因为 ORDER BY 子句会在 SELECT 子句之后执行，并且记录保证不会减少。 因此，在 SELECT 子句之外“使用窗口函数是没有意义的。 计算移动平均移动平均（moving average）常用于希望实时把握“最近状态”的场景，如数据的实时跟踪 123SELECT &lt;列1&gt;, &lt;列2&gt;, &lt;列3&gt;， …， AVG &lt;指定列&gt; OVER (ORDER BY &lt;指定列&gt; ROWS n PRECEDING)FROM &lt;表名&gt;; 使用了 ROWS（“行”）和 PRECEDING（“之前”）两个关键字，将框架指定为“截止到之前 n 行”，即：自身（当前记录）、之前第 1 行、 ……、 之前第 ~ 行，共 n+1 行 框架:在窗口中指定更加详细的汇总范围 FOLLOWING（“之后”）可替换 PRECEDING，指定“截止到之后 ~ 行”作为框架 GROUPING 运算符ROLLUP123SELECT GROUPING(聚合键)， SUM(求和列) AS sum_指定列 FROM &lt;表名&gt; GROUP BY ROLLUP(聚合键); 可一次计算出按不同聚合键组合的求和结果 此处聚合键和 GROUP BY 子句使用一样，可以为 NULL，可以指定多列 GROUP BY 不指定聚合键时会默认使用 NULL 作为聚合键（相当于没有使用 GROUP BY），此时会得到全部数据的合计行的记录，称超级分组 GROUPING 函数在其参数列的值为超级分组记录所产生的 NULL 时返回 1，其他情况返回 0，以分辨出原始数据中的 NULL 和超级分组记录中的 NULL 在 MySQL 中 GROUP BY 子句应改写为“GROUP BY &lt;指定列&gt; WITH ROLLUP;” CUBECUBE 将 GROUP BY 子句中聚合键的“所有可能的组合”的汇总结果集中到一个结果中。因此，组合的个数就是 $2^n$（n 是聚合键的个数） 123SELECT GROUPING(聚合键)， SUM(求和列) AS sum_指定列 FROM &lt;表名&gt; GROUP BY CUBE(聚合键); 可以把 CUBE 理解为将使用聚合键进行切割的模块堆积成一个立方体 GROUPING SETSCUBE 的结果就是根据聚合键的所有可能的组合计算而来的，使用 GROUPING SETS 可以取得部分组合的结果 123SELECT GROUPING(聚合键)， SUM(求和列) AS sum_指定列 FROM &lt;表名&gt; GROUP BY GROUPING SETS(&lt;聚合键组合1&gt;, &lt;聚合键组合2&gt;, …);]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + NexT 的问题]]></title>
    <url>%2F2019%2F06%2F30%2Fhexo_problem_list%2F</url>
    <content type="text"><![CDATA[[Updating] 本文记录了 Hexo + NexT 使用过程中的一些问题 版本声明 hexo: 3.9.0 next: 7.0.1 local_search 不能用打开首页（本地or线上），打开浏览器开发工具 Network 选项卡，点击首页“搜索”按钮，观察 search.xml 状态： 200 问题：Algolia 问题 解决：主题配置文件中关闭 Algolia 404 其他 问题：存在非法字符 解决：sublime 排查 .md 文件中所存在非法字符 post_meta 不显示更新时间修改主题配置文件，post_meta 模块中设置： 123updated: enable: true anotherday: false]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github + Hexo 搭建博客]]></title>
    <url>%2F2019%2F05%2F30%2Fhexo%2F</url>
    <content type="text"><![CDATA[[Updating] 本文记录了使用Github和Hexo搭建该博客的过程 环境 系统：ubuntu 18.04 nodejs:： Hexo 的安装Node.js 的安装Hexo 的安装Git 的安装初步优化]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 数学公式语法]]></title>
    <url>%2F2018%2F01%2F28%2Fmarkdown-formula%2F</url>
    <content type="text"><![CDATA[[Updated] 本文记录了 Markdown 数学公式语法 Markdown 数学公式语法公式公式类型行内公式将公式插入到本行内。使用一个 “$” 包裹数学公式。 极限：$\displaystyle \lim_{n \to +\infty}{x_n = \alpha}$ 独行公式将公式插入到新的一行内，并且居中。使用两个 “$$” 包裹数学公式。极限： $$\displaystyle \lim_{n \to +\infty}{x_n = \alpha}$$ 上下标 上下标 语法 预览 ^ x^2 $x^2$ _ x_1 $x_1$ 运算符普通运算 运算 语法 预览 加 + $+$ 减 - $-$ 乘 \times $\times$ 除 \div $\times$ 开方 \sqrt[n]{x} $\sqrt[n]{x}$ 加减 \pm $\pm$ 减加 \mp $\mp$ 绝对值 | | $ 分数 \frac{b}{a} $\frac{b}{a}$ 分数 {b} \voer {a} ${b} \over {a}$ 对数运算 运算 语法 预览 对数 \log $\log$ ln \ln $\ln$ lg \lg $\lg$ 集合运算 运算 语法 预览 空集 \emptyset $\emptyset$ 属于 \in $\in$ 不属于 \notin $\notin$ ⊂ \subset $\subset$ ⊃ \supset $\supset$ ⊆ \subseteq $\subseteq$ ⊇ \supseteq $\supseteq$ ⊇ \bigcap $\bigcap$ ⋃ \bigcup $\bigcup$ ⋁ \bigvee $\bigvee$ ⋀ \bigwedge $\bigwedge$ 逻辑运算 运算 语法 预览 因为 \because $\because$ 所以 \therefore $\therefore$ 任取 \forall $\forall$ 存在 \exists $\exists$ 不等于 \neq $\neq$ 不属于 \not\subset $\not\subset$ 微积分运算 运算 语法 预览 极限 \lim $\lim$ 无穷 \infty $\infty$ 积分 \int $\int$ 重积分 \int（i 的个数为重数） $\iiint$ 曲线积分 \oint $\oint$ 三角函数 运算 语法 预览 度数 90^\circ $90^\circ$ ∠ \angle $\angle$ sin \sin $\sin$ cos \cos $\cos$ tan \tan $\tan$ 希腊字母 字母 语法 预览 Δ \Delta $\Delta$ Θ \Theta $\Theta$ Σ \Sigma（’S’ 大写） $\Sigma$ Ω \Omega（’O’ 大写） $\Omega$ α \alhpa $\alpha$ β \beta $\beta$ γ \gamma $\gamma$ δ \delta $\delta$ ϵ \epsilon $\epsilon$ η \eta $\eta$ θ \theta $\theta$ κ \kappa $\kappa$ λ \lambda $\lambda$ μ \mu $\mu$ ν \nu $\nu$ π \pi $\pi$ σ \sigma（’s’ 小写） $\sigma$ τ \tau $\tau$ ω \omega（’o’ 小写） $\omega$ ξ \xi $\xi$ ρ \rho $\rho$ 栗子求和公式\displaystyle \sum_{i=1}^n \frac{1}{i}预览： $$\displaystyle \sum_{i=1}^n \frac{1}{i}$$ 求积公式\displaystyle \prod_{i=1}^n i预览： $$\displaystyle \prod_{i=1}^n i$$ 求积分\displaystyle \int_0^{1} x dx预览： $$\displaystyle \int_0^{1} x dx$$ 求极限\displaystyle \lim_{n \rightarrow +\infty} \frac{1}{n(n+1)}预览： $$\displaystyle \lim_{n \rightarrow +\infty} \frac{1}{n}$$]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 基础语法]]></title>
    <url>%2F2018%2F01%2F22%2Fmarkdown-basic%2F</url>
    <content type="text"><![CDATA[[Updated] 本文记录了 Markdown 基础语法 Markdown 基础语法标题语法123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 预览一级标题二级标题三级标题四级标题五级标题六级标题 字体语法123456*这是斜体*_这是斜体_**这是粗体**__这是粗体__***这是粗斜体***___这是粗斜体___ 预览这是斜体 这是斜体 这是粗体 这是粗体 这是粗斜体 这是粗斜体 列表语法无序列表12345678* 第一项* 第二项+ 第一项+ 第二项- 第一项- 第二项 有序列表1231. 第一项2. 第二项3. 第三项 嵌套列表1234567891. 第一项2. 第二项 - 第一项 - 第二项- 第一项 - 第一项 - 第二项- 第二项 预览无序列表 第一项 第二项 第一项 第二项 第一项 第二项 有序列表 第一项 第二项 第三项 嵌套列表 第一项 第二项 第一项 第二项 第一项 第一项 第二项 第二项 区块语法12345678910111213&gt; 最外层&gt;&gt; 第一层嵌套&gt;&gt;&gt; 第二层嵌套&gt; 区块列表&gt; 1. 第一项&gt; 2. 第二项&gt; 3. 第三项- 第一项 &gt; 外层区块 &gt; 内外层区块- 第二项 预览 最外层 第一层嵌套 第二层嵌套 区块列表 第一项 第二项 第三项 第一项 区块 第二项 代码块语法单行代码1`import sys` 多行代码123```python &lt;-指定语言`import sys````. 或 1import sys &lt;-一个Tab指定代码区块 预览单行代码import sys 多行代码1import sys 或 import sys 表格语法1234col1 | col2 | col3- | - | -row1_1 | row1_2 | row1_3row2_1 | row2_2 | row2_3 预览 col1 col2 col3 row1_1 row1_2 row1_3 row2_1 row2_2 row2_3 插入链接/图片语法插入普通链接123[本站地址](https://xhzs.github.io/)这是本站地址：&lt;[链接地址](https://xhzs.github.io/)&gt; 插入图片1&lt;img src="图片的本地/线上地址" width="50%"&gt; 预览普通链接这是本站地址 这是本站地址：&lt;链接地址&gt; 图片]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决 chrome 下 jupyter-notebook 异常问题]]></title>
    <url>%2F2018%2F01%2F16%2Fchrome-jupyter-exception%2F</url>
    <content type="text"><![CDATA[[Updated] 本文记录了 chrome 运行 jupyter-notebook 所出现的异常及解决方法 解决 chrome 下 jupyter-notebook 异常问题问题chrome 下使用 jupyter-notebook 出现以下问题： 按 tab 键补全后自动移至下一单元格 括号自动补全出问题。如：按 “(“ 打印 “(()” 原因开启了某些 chrome 扩展程序所致 解决方法采用排除法测试出引起问题的 chrome 拓展程序，将其关闭]]></content>
      <categories>
        <category>chrome 使用问题</category>
      </categories>
      <tags>
        <tag>chrome</tag>
        <tag>jupyter-notebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决 chrome 安装插件失败问题]]></title>
    <url>%2F2018%2F01%2F14%2Fchrome-install-extension%2F</url>
    <content type="text"><![CDATA[[Updated] 本文记录了 chrome 离线安装插件失败的问题及解决方法 解决 chrome 安装插件失败问题问题chrome 离线安装插件失败。页面左上角显示： Package is invalid:’CRX_HEADER_INVALID’ 解决以安装 example.crx 为例： 备份 example.crx，以防误操作或错误情况 将 example.crx 更改后缀名为 .rar 或 .zip 解压 example.rar(.zip) 到 example 文件夹，文件夹内包含：example.js、icon.png、manifest.json 打开 chrome 拓展页面，右上角开关开启开发者模式后，左上角点击“加载已解压拓展程序”，选择步骤 3 中解压的 example 文件夹，安装成功]]></content>
      <categories>
        <category>chrome 使用问题</category>
      </categories>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理]]></title>
    <url>%2F2018%2F01%2F06%2Fcomputer-struct%2F</url>
    <content type="text"><![CDATA[[Updated] 本文梳理了《计算机组成原理》的基础知识 目录 Chapter 1 Chapter 2 Chapter 3 Chapter 4 Chapter 5 Chapter 6 Chapter 7 Chapter 8 总线 存储器 I/O 计算的运算方法 指令系统 CPU 控制单元 控制单元的设计 总线 判优控制 ！当总线上各个主设备同时请求占用总线时，总线控制器按一定优先等级确定某个设备可以占用总线。 ？总线特点为某一刻时刻只允许一个设备向总线发送信息，若两个以上部件同时向总线发送信息，势必导致信号冲突传输无效。 链式查询 1 BR、1 BS、1 BG 优：优先级固定；结构简单、易扩充 缺：电路故障敏感，第i个有故障，第i个以后皆无法工作 计数器定时查询 1 BR、1 BS、1bN设备地址线 优：优先级可不固定；电路故障不如链式查询敏感 缺：控制比链式查询复杂 独立请求 N BR、N BS、N BG 优：响应速度快；优先级控制灵活，可预先固定，也可通过程序改变；可屏蔽设备请求 缺：仲裁线路复杂 通信控制 ！解决通信双方如何获知传输开始和传输结束，以及通信双方如何协调配合。 ？因为总线由众多部件共享，在传送时间上只能用分时方式解决，故通信双方必须按某种约定的方式进行通信。 同步通信 采用公共时钟信号控制，统一传输周期（必须按最慢速度部件设计） 适用：总线长度较短，各部件存取时间相较一致 异步通信 没有公共时钟，采用应答式通信，无固定传输周期 全互锁（完全制约，可靠性最高）/半互锁（简单制约）/不互锁（无制约） 适用：总线各部件速度不一致 分离式通信 总线传输周期分为两个子周期供不同模块占用，总线上无等待时间，最充分发挥了总线的有效占用 半同步通信 既有公共时钟，又允许速度不同的模块和谐工作，采用插入等待周期的措施协调通信双方的配合问题 串行传输与并行传输 串行传输 数据在一条线路上按位依次传输 成本低，但速度慢，适合远距离的传输 并行传输 每个数据位都有一条独立传输线路，所有数据按位同时传输 成本高，速度快，适合近距离、高速传输 总线复用 不同信号（数据/地址）共用同一组物理线路，分时使用 需先给地址信号，然后用地址锁存信号将其保存 总线带宽（MBps）：单位时间总线上可传输数据位数，也称“数据传输率” 影响因素：总线宽度、传输距离、主频 总线带宽 = 一个传输周期传输字节数/时钟周期 | 一个传输周期传输字节数*时钟频率 存储器 芯片：16K×8位/16KB 地址线 = 14根 数据线 = 32根 引出线最少数目 = 数据线+地址线+2 多体结构存储器 将存储器分成若干个（n个）独立的模块，每个模块的容量和存取周期均相等，且可独立进行读写操作。将独立模块： 高位交叉编址 各模块分别响应不同请求源，实现多体并行 高位–存体号，低位–选择存储体内的字 低位交叉编址， 不改变存取周期的前提下，增加存储器带宽，n个模块则带宽提高至n倍 高位–选择存储体内的字，低位–存体号 存取周期T，总线传输周期t，连续读取n个字时间=T+（n-1）t 提高访存的措施 采用高速器件，选用存取周期短的芯片，提高存储器速度 采用缓存，CPU将近期要用的信息先调入缓存，而缓存速度比主存快得多，CPU从缓存存取信息则缩短访存时间，提高了访存速度 调整主存结构，如采用单体多字结构或多体结构（都增加存储器带宽） 程序访问的局部性原理 由于指令和数据在主存的地址分布不是随机的，而是相对地聚簇，故程序执行时对存储器的访问使不均匀的 利用该原理：对缓存-主存，把CPU最近期执行的程序放在容量较小速度较高的缓存中；对主存-辅存，把程序中访问频度高、比较活跃的部分放在主存中。既提高了访存速度又扩大了存储器容量 地址映射（硬件完成） 直接 假设C块缓存，每个主存块j只与一个缓存块i对应：i = j mod C 映射简单，但主存块只能固定对应某个缓存块，不够灵活、命中率低 全相联 主存任一块都可以映射到缓存中的任一块上 灵活、命中率高，但所需电路多、成本高 组相联 把缓存分Q组，组内分R块，主存块号j映射到缓存组号i内任一块：i = j mod Q，缓存内1~R任一块 比直接灵活、命中率高，比全相联成本低，是两者的折中，广泛应用 三级存储系统（平衡–速度、容量、价格） 高速缓存 解决：CPU和主存速度匹配，提高访存速度缓存 管理：硬件和操作系统完成 地址对用户透明 虚存 解决：扩大存储容量 管理：硬件和操作系统完成 CPU不直接访问二级存储器 RAM刷新 方式：集中/分散/异步 原因：存储电荷电容放电 I/O I/O编址方式 独立编址：I/O地址与主存地址分开，不占主存容量，但需要专用I/O指令访I/O 统一编址：在主存地址划出一定范围作I/O地址，通过访存指令访问I/O，但减少了主存容量 主机与I/O交换信息的控制方式 程序查询 主机与I/O串行工作 程序中断 主机与I/O并行工作,主程序和信息传送串行 DMA 主机与I/O并行工作,主程序和信息传送并行 通道 I/O处理机 程序查询 CPU启动I/O后停止现行程序，插入一段程序时刻查询I/O设备准备状况，等待I/O准备就绪时可实现信息交换，存在“踏步”现象 程序中断 管理（多重）中断硬件 中断请求触发器（INT）：标志中断源向CPU提出中断请求 中断屏蔽触发器（MASK）：为“1”表示屏蔽该中断源 排队器：中断判优 向量地址形成部件：产生中断源向量地址 允许中断触发器（EINT）：为“1”允许处理中断 中断标志触发器（INTR）：标志进入中断周期 堆栈：保护现场 中断查询信号电路：每条指令执行周期结束时刻，向各中断源发查询信号 过程： 中断请求：CPU启动I/O设备，I/O准备就绪后向CPU提出中断请求 中断判优：中断判优逻辑选择优先级最高的中断请求，待CPU处理 中断响应：若INT（中断请求触发器）为”1”且请求中断设备未被屏蔽，系统进入中断响应周期–CPU自动执行中断隐指令[ 硬件完成：保护程序断点(即PC内容)、硬件关中断、向量地址送PC（硬件向量法）或中断识别程序入口地址送PC（软件查询法） ] 中断服务：中断响应周期结束，CPU转入取指周期，按向量地址取出无条件转移指令（或按向量地址查入口地址表）；转至向量地址对应的中断程序服务入口地址，开始执行中断服务程序[ 保护现场（PC内容–中断隐指令；寄存器内容–软件编程）、与I/O传送信息、恢复现场 ] 中断返回：中断服务程序最后一条即中断返回指令（返回程序断点） 响应条件和时间： 条件：EINT为“1”（即开中断）；中断请求未被屏蔽，且排队后被选中 时间：指令执行阶段的结束时刻，CPU发出中断查询信号，才能获取中断请求信号 向量地址 存放服务程序入口地址的存储单元地址，由硬件形成 当有中断请求且排队选中时，通过自由组合逻辑电路组成的向量地址形成部件可形成向量地址 输入：排队器；输出：中断周期送至PC；传送：数据总线 开/关中断 EINT为“1”时，允许CPU响应中断；EINT为“0”时，CPU不能响应中断 关中断即将EINT置“0”；开中断即置“1” 多重中断(主要区别在中断服务程序)：CPU处理中断过程中出现新的中断请求，暂停现行中断处理转至处理新的中断 多重中断条件 必须重新开中断 优先级更高的中断请求才能中断现行程序（内部中断&gt;不可屏蔽中断&gt;可屏蔽中断） 单重中断：保护现场-&gt;设备服务-&gt;恢复现场-&gt;开中断-&gt;中断返回 多重中断：保护现场-&gt;开中断-&gt;设备服务-&gt;恢复现场-&gt;中断返回 中断服务程序与调用子程序区别 中断服务程序与中断时CPU正在运行程序相互独立；子程序与CPU正在运行程序是同一程序的两部分 除了软中断，中断通常随机产生；子程序调用由CALL指令引起 中断服务程序入口地址可通过硬件向量法产生向量地址，再由向量地址找到入口地址；子程序调用入口地址由CALL指令地址码给出 中断需要对多个同时发生的中断进行裁决；子程序调用无此操作 都要保护程序断点：前者中断隐指令完成；后者CALL指令完成 都要保护寄存器内容的操作 中断和DMA区别 数据传送：中断靠程序传送；DMA靠硬件传送 CPU响应时间：中断在一条指令执行结束时响应；DMA在存取周期结束时响应 异常处理能力：中断有；DMA无 保护现场：中断需中断现行程序，需保护现场；DMA不需中断现行程序，无需保护现场 优先级：DMA高于中断 DMA 特点： I/O和CPU并行工作 主存和I/O接口间有一条直接数据通路 不中断现行程序，无需保护、恢复现场 DMA请求占用总线时，若采用周期挪用，CPU暂停一个存取周期访问主存，但可继续自身内部操作（如乘法），即DMA传送和主程序并行 硬件：数据缓存寄存器、DAR、AR、WC、中断机构、DMA控制逻辑 过程： 预处理 指明数据传送方向输入（读）/输出（写） 设备地址送DAR（设备地址寄存器） 主存地址送AR（主存地址计数器） 传送数据字数送WC（字计数器） 启动设备 数据传送 主存地址送总线 数据送I/O设备（或主存） 修改主存地址和WC 重复直至数据块传送结束 后处理 由中断服务程序作DMA结束处理（测试传送过程是否出错、决定是否继续使用DMA传送数据） DMA和CPU分时使用主存： 停止CPU访存 DMA在传送数据时独占主存，CPU放弃总线使用权，基本处于不工作或保持原状态，直至DMA传送结束 周期挪用 一旦I/O有DMA请求，由I/O设备挪用一个存取周期。此时CPU可完成自身操作，但要停止访存 DMA和CPU交替访存 适用CPU工作周期比主存存取周期长时。CPU工作周期的上下半周期由DMA和CPU交替使用访存，使DMA传送和CPU工作效率最高，但硬件逻辑复杂 计算的运算方法 判溢出 定点机 参与运算的两个操作数符号相同，结果的符号与原操作数符号不同，则溢出 求和时最高进位与次高进位异或结果为1，则溢出 浮点机判溢出 当阶码大于最大正阶码时，则溢出 当阶码小于最小负阶码时，则按机器零处理 进位：影响加减运算速度的关键 进位链：传递进位的逻辑电路 先行进位：高位进位和低位进位同时产生 单重分组跳跃进位 n位全加器分若干小组，组内进位同时产生，组间串行进位 多重分组跳跃进位 n位全加器分若干大组，若干大组内又包含若干小组，大组内各小组进位同时产生，小组内进位同时产生，大组间串行进位 快于单重，但线路更复杂 指令系统 不同地址格式指令 地址格式 访存次数 备注 四地址 4 A4指出下条指令地址 三地址 4 PC指出下条指令地址 二地址 4 操作结果存回A1、A2或ACC 一地址 4 ACC存放操作数和结果 数据存放方式。存储字长32位，可按字节、半字、字寻址： 边界对准：数据字地址一定是4的整数倍。所存数据不满足该要求时，填充一个或多个空白字节（浪费存储空间） 边界不对准：数据字跨两个存储字时需两次访存，并对高低字节位置进行调整后才能取得数据字（影响取数时间） 间址/基址/变址：可扩大寻址范围 通过访存（多次间址多次访存）得到有效地址 间址 访存导致时间较长（T一次访存 &gt;&gt; T一次寄存器） 地址变换（R+A）得到有效地址 基址 基址寄存器内容由操作系统给定，且在程序执行过程中不可变 支持多道程序技术的应用 变址 变址寄存器内容由用户给定，且在程序执行过程中可变 适用于处理数组问题 相对/堆栈寻址 相对：EA = (PC) + A A为位移量（字节），决定寻址范围；可正可负，补码表示 便于程序浮动，用于转移指令 堆栈：SP +/- ▲ -&gt; PC 有效地址在SP中，指令中可少一个指令字段 ▲与主存编址方式相关：按字编址，▲取1；按字节编址，字长16位时▲取2，字长32时▲取4 RISC（CISC） 选用频度高简单指令，复杂指令功能由简单指令实现（指令系统复杂庞大） 指令长度固定，指令格式种类少，寻址方式种类少（不固定、多、多） 只有LOAD/STORE访存，其余指令皆在寄存器进行（可访存指令不受限制） CPU中有多个通用寄存器（设专用寄存器） 控制器采用组合逻辑控制（微程序） 采用流水技术，大部分指令1个时钟周期内完成（各指令执行时间相差大，大部分需多个时钟周期） 采用优化的编译程序（难以用优化编译生成高效代码） 与CISC比较： 提高指令执行速度 便于设计，可降低硬件设计复杂度 简化指令功能，有利于编译程序代码优化 不易实现指令系统兼容 CPU CPU 功能 指令控制：控制程序的顺序执行 操作控制：产生完成每条指令所需控制命令 时间控制：对各种操作加以时间上的控制 数据加工：对数据进行算术和逻辑运算 中断处理：处理计算机在运行过程中出现的异常情况和特殊请求 组成 寄存器 PC：存放现行指令地址，位数取决于存储器容量 IR：存放现行指令，位数取决于指令字长 通用寄存器：存放数据和地址，位数取决于机器字长 指令译码器 + 控制单元CU：根据指令译码在规定时间发出操作命令 ALU：算术逻辑运算 中断系统：处理中断 指令周期：取指+（间址）+执行+（中断） 执行 -&gt; 中断周期 -&gt; 取值 存取周期 -&gt; DMA周期 -&gt; 存取周期（指令周期任一阶段皆可） 指令流水 结构相关 硬件资源满足不了指令重叠执行的要求，发生资源冲突 如：同一时间，几条重叠的指令分别取值、取数、存数，发生访存冲突 数据相关 指令重叠执行，可能改变操作数的读写访问顺序，导致数据相关冲突 如：某条指令需要用到前面指令的执行结果，而这些指令在流水线中重叠执行，可能改变对操作数读写访问顺序 控制相关 流水线遇到分支指令或其他改变程序计数器PC的指令，造成指令执行顺序的改变 如：某条指令需等前面指令做出转移方向的决定才能进入流水线 流水线多发技术 超标量流水：每个时钟周期内可同时并发多条独立指令，处理器中需配置多个功能部件和指令译码电路，以便同时执行多个操作 超流水线：在原来的时钟周期内，功能部件被使用多次 超长指令字：对编译器要求高，充分挖掘指令间潜在并行性（一个时钟周期内，各功能部件无数据相关），把能并行的指令合成一条具有多个操作码（需相应个数功能部件）的超长指令 中断系统 INTR 与 EINT INTR 中断标志触发器：指示CPU是否进入中断周期 EINT 允许中断触发器：开放或关闭中断系统 置“1”：系统开放，允许中断（开中断指令） 置“0”：关中断（关中断指令、中断隐指令、硬件自动复位） 中断判优：在某一时刻可能有多个中断源（中断源请求随机）提出请求，而CPU只能响应一个，故须判优已解决响应优先次序 硬件排队：组合逻辑电路实现 软件排队：程序按优先级（从高至低）顺序查询各中断源 中断服务程序入口地址寻找 硬件向量法（向量中断）：当有中断请求时，由硬件产生该中断源对应的向量地址，再由向量地址找到服务程序的入口地址，然后暂停现行程序转至中断服务程序 排队器输出 -&gt; 向量地址形成部件 -&gt; 输出向量地址 向量地址寻找入口地址方式 向量地址单元内存放一条无条件转移指令 在向量地址单元内直接存放入口地址，形成一个中断向量地址表 软件查询法：编写中断识别程序实现 屏蔽 屏蔽触发器：内容即屏蔽字，每个中断源对应一个屏蔽字，为“1”时CPU不响应该中断源请求 优先级 响应优先级：CPU响应各中断源请求的优先次序，通常硬件线路已设置好，不便改动（不采用屏蔽时） 处理优先级：CPU实际对各中断源请求的处理优先次序（采用屏蔽） 采用屏蔽技术的中断服务流程 保护现场 -&gt; 置屏蔽字 -&gt; 开中断 -&gt; 中断服务 -&gt; 关中断 -&gt; 恢复现场 -&gt; 恢复屏蔽字 -&gt; 开中断 -&gt; 中断返回 作用 改变处理优先级 为实现多重中断，屏蔽低级别中断请求对现行中断处理程序的干扰 封锁部分中断请求，使程序控制更灵活 控制单元 控制单元CU 功能：发出各种操作命令(即控制信号) 受控制：指令寄存器(操作码)、时钟、标志、系统总线控制信号(中断) 多级时序 指令周期：完成（取出并执行）一条指令所需的时间 机器周期：指令执行过程中一个基准时间，通常以存取周期作为机器周期（因为完成指令都需取指，而一次访存时间固定）。一个机器周期内完成若干微操作，可通过节拍控制产生每一个微操作命令 时钟周期：主频（时钟信号的频率）的倒数，也可称为节拍（时钟信号控制产生，每个节拍宽度对应一个时钟周期）。一个节拍内完成若干需同时执行的操作，是控制计算机操作的最小时间单位 三者关系：每个指令周期含若干个机器周期，可不相等；每个机器周期含若干个时钟周期（节拍），可不相等 机器速度：同主频下， 机器周期中时钟周期数和指令周期中机器周期数不同，机器速度不同。（机器周期中含时钟周期少的机器速度更快） 控制方式 同步控制：微操作受统一基准时标时序信号控制。存取周期不统一时，取最长存取周期作为机器周期 采用定长的机器周期：采用完全统一、具有相同时间间隔和相同数目节拍 采用不定长的机器周期：机器周期内节拍数可不等；大多数微操作一个机器周期内完成，复杂微操作延长机器周期或增加节拍 采用中央控制和局部控制相结合的方法：大部分中央控制，少数局部控制 局部控制每一个节拍T*宽度与中央控制节拍宽度相同 局部控制节拍作为中央控制中机器节拍的延续，插入中央控制的执行周期 异步控制：不存在基准时标信号，微操作时序由专用的应答线路控制。控制器发出某一个微操作命令后，等待执行部件完成该操作时所发回的应答信号，再开始执行下一个操作 联合控制：同步与异步结合。即大多数微操作在同步时序信号控制下进行，而对时间难以确定的微操作（如I/O相关）采用异步控制 控制单元设计 组合逻辑控制器 采用硬连线逻辑：一个微操作命令对于一个逻辑电路 思路清晰，简单明了 结构复杂，线路复杂。一旦构成，除非物理上重新连线，否则无法增加新的控制功能 组合逻辑与微程序控制组成异同 同：均有PC、IR、时序电路、中断系统、状态条件 异： 微操作命令序列形成部件不同。组合逻辑核心部件–门电路；微程序核心部件–控制存储器ROM(存放全部微程序) 微操作命令及节拍安排的主要差别： 取指阶段 12OP(IR) -&gt; ID //组合逻辑：指令操作码送指令译码器OP(IR) -&gt; 微地址形成部件 //微程序：指令操作码送微地址形成部件 微程序每条指令都要增加一个将微指令下地址字段送CMAR的微操作 1Ad(CMDR) -&gt; CMAR 微程序控制器 采用存储逻辑：每条机器指令编写成一个微程序，每一个微程序包含若干条微指令（操作控制字段+顺序控制字段），每一条微指令对应一个或几个微操作命令 优点：规整形、灵活性、可维护性 控制器中微程序个数 = 机器指令数 + 3（取指/间址/中断周期) 组成 控存：存放全部微程序 CMAR（控存地址寄存器）：存放欲读出微指令地址。采用增量计数器法形成后续微指令地址时，有计数功能 CMDR（控存数据寄存器）：存放取出的微指令 顺序逻辑：控制微指令序列 输入：微地址形成部件、微指令下地址字段、外来标志 输出：CPU内部和系统总线的控制信号 微指令编码方式 直接编码（直接控制）：操作控制字段每一位代表一个微命令 简单直观，输出直接用于控制，执行速度快 微指令字较长，使控存容量大 字段直接编码（显示编码）：操作控制字段分段，每个字段经译码发出微操作命令，且互斥 缩短字长，以较少二进制信息表示较多微命令信号 增加译码电路，执行速度降低 字段间接编码（隐式编码）：一个字段某些命令需由另一字段某些微命令解释 更能缩短微指令字长，但速度更慢 微指令序列地址形成 直接由微指令的下地址字段给出 根据机器指令的操作码形成 增量计数器法，即 （CMAR）+ 1 -&gt; CMAR 根据各钟标志决定微指令分支转移的地址 测试网络形成 硬件直接产生微程序入口地址 微指令格式 水平型：一次能定义多个并行操作的微命令。直接编码、字段直接编码、字段间接编码以及直接及混合编码都属于水平型指令格式 大多数微命令可直接控制对象，故每条微指令执行时间短 微指令字长较长，故可用较少微指令数实现一条机器指令的功能 垂直型：采用类似机器指令操作码方式，在微指令中设置微操作码字段，由微操作码规定微指令功能 经过译码控制对象，影响执行时间 微指令字长较短，实现一条机器指令微程序比水平型微指令长的多，以较长微程序结构换取较短微指令结构]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计组</tag>
      </tags>
  </entry>
</search>
