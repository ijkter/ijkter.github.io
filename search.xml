<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>new_template</title>
      <link href="/2020/10/07/new-template/"/>
      <url>/2020/10/07/new-template/</url>
      
        <content type="html"><![CDATA[<p><font color="#008000"> [Updated] </font> 已完成</p><p><font color="#FF0000"> [Updating] </font> 更新中</p><a id="more"></a>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2020/10/06/test-2341/"/>
      <url>/2020/10/06/test-2341/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>test_2340</title>
      <link href="/2020/09/30/test-2340/"/>
      <url>/2020/09/30/test-2340/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据分析思维</title>
      <link href="/2020/09/30/active-data/"/>
      <url>/2020/09/30/active-data/</url>
      
        <content type="html"><![CDATA[<p><font color="#008000"> [Updated] </font> 本文基于《活用数据》整理了数据分析思维的相关内容。</p><a id="more"></a><h1 id="数据分析思维"><a href="#数据分析思维" class="headerlink" title="数据分析思维"></a>数据分析思维</h1><h2 id="先行概念"><a href="#先行概念" class="headerlink" title="先行概念"></a>先行概念</h2><h3 id="市场营销"><a href="#市场营销" class="headerlink" title="市场营销"></a>市场营销</h3><p>企业在<strong>现有营销环境</strong>下，根据<strong>目标消费者的需求</strong>，利用<strong>现有的资源和能力</strong>，<strong>比竞争对手更快捷、更有效</strong>地向目标消费者提供产品和服务，实现企业盈利以及可持续发展的生产和经营活动。 <em>— 现代市场营销学之父 菲利普·科特勒</em></p><p>为更好地驱动企业营销业务，围绕市场营销的定义展开作数据分析。</p><div class="table-container"><table><thead><tr><th>案例</th><th>角度</th></tr></thead><tbody><tr><td>企业战略分析</td><td>现有营销环境</td></tr><tr><td>用户偏好分析</td><td>目标消费者的需求</td></tr><tr><td>STP</td><td>目标消费者的需求</td></tr><tr><td>品牌建设分析</td><td>让消费者选择自己</td></tr><tr><td>营销组合分析</td><td>比竞争对手更快捷、更有效</td></tr></tbody></table></div><h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><p>定义：数据分析是实现研究目的与研究内容的闭环。</p><p>做法：首先<a href="#分析哪些内容---开启分析思路">将研究目的分解为内容</a>，然后再<a href="#分析到什么程度---打开分析视角">通过研究内容实现研究目的</a>。</p><p>具体流程：</p><ol><li>明确分析思路</li><li>获取数据</li><li>处理数据</li><li>分析数据</li><li>解读数据</li></ol><h3 id="定性分析与定量分析"><a href="#定性分析与定量分析" class="headerlink" title="定性分析与定量分析"></a>定性分析与定量分析</h3><div class="table-container"><table><thead><tr><th></th><th>特点</th></tr></thead><tbody><tr><td>定性分析</td><td>关注意义，能做梳理，不能作为选择</td></tr><tr><td>定量分析</td><td>关注频率，<strong>量化</strong>成具体数据作为指导</td></tr></tbody></table></div><h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><p>预测是推断的过程：</p><ul><li><p>由已知推断未知</p><p>条件：已知和未知具有相似性（类推原则）或相关性（相关原则）。</p></li><li><p>由过去推断未来</p><p>条件：市场具有惯性（惯性原则）。</p></li></ul><p>预测的类型：</p><ul><li>定性预测：基于经验和判断推断，主观性强。</li><li>定量预测：基于数据和模型推断，客观性强。基于同样的数据和模型，结论一定相同。</li></ul><p>推断思路：</p><ol><li>类推原则：</li><li>相关原则</li><li>惯性原则</li></ol><h2 id="解决什么问题-明确分析思维"><a href="#解决什么问题-明确分析思维" class="headerlink" title="解决什么问题 - 明确分析思维"></a>解决什么问题 - 明确分析思维</h2><ul><li>识别机会</li><li>规避风险</li><li>问题诊断</li><li>营销效果评价</li><li>量化管理</li></ul><h2 id="分析哪些内容-开启分析思路"><a href="#分析哪些内容-开启分析思路" class="headerlink" title="分析哪些内容 - 开启分析思路"></a>分析哪些内容 - 开启分析思路</h2><h3 id="学会提问"><a href="#学会提问" class="headerlink" title="学会提问"></a>学会提问</h3><ol><li><p>发散思维，头脑风暴，罗列出关键问题</p></li><li><p>MECE 原则（mutually exclusive collectively exhausted）</p><p>分解出的各项内容相互独立，交集为空集；汇总在一起完全穷尽，并集是全集。</p><ul><li>核心：不重不漏</li><li>方法：二分法…等</li></ul></li><li><p>使用模型或结构化思维对罗列的关键问题进行归纳划分</p></li></ol><h3 id="熟悉模型"><a href="#熟悉模型" class="headerlink" title="熟悉模型"></a>熟悉模型</h3><blockquote><p>模型是经过长期检验的成熟的分析思路，灵活运用可以事半功倍。</p></blockquote><p>熟悉常用模型及其适用场景：</p><div class="table-container"><table><thead><tr><th>适用场景</th><th>模型</th></tr></thead><tbody><tr><td>顾客满意度</td><td><a href="#RATER">RATER</a></td></tr><tr><td>产品属性优先度</td><td><a href="#KANO">KANO</a></td></tr><tr><td>战略选择</td><td><a href="#SWOT">SWOT</a></td></tr><tr><td>战略选择</td><td><a href="#IEF内外因素评价矩阵">IEF 内外因素评价矩阵</a></td></tr><tr><td>用户行为</td><td><a href="#用户行为五阶段、5W2H">用户行为五阶段、5W2H</a></td></tr><tr><td>品牌形象</td><td><a href="#品牌知觉图">品牌知觉图</a></td></tr><tr><td>品牌知名度</td><td><a href="#Graveyard">Graveyard</a></td></tr><tr><td>定价决策</td><td><a href="#PSM">PSM</a></td></tr><tr><td>营销组合</td><td><a href="#4P营销理论">4P营销理论</a></td></tr><tr><td>用户转化</td><td><a href="#AARRR">AARRR</a></td></tr><tr><td>环境分析</td><td><a href="#PEST">PEST</a></td></tr><tr><td>市场分析</td><td><a href="#波特五力">波特五力</a></td></tr></tbody></table></div><h3 id="结构化思维"><a href="#结构化思维" class="headerlink" title="结构化思维"></a>结构化思维</h3><h4 id="时间与结构思维"><a href="#时间与结构思维" class="headerlink" title="时间与结构思维"></a>时间与结构思维</h4><blockquote><p>“四方上下曰宇，往古来今曰宙。”</p></blockquote><ul><li>时间：事务的过程，即发展阶段</li><li>结构：事务的方面，即构成要素</li></ul><h4 id="演绎思维"><a href="#演绎思维" class="headerlink" title="演绎思维"></a>演绎思维</h4><blockquote><p>演绎而不是归纳。</p></blockquote><p>原因</p><ol><li>演绎：由共性原理（或假设）推出个性结论</li><li>归纳：由个性推出共性</li></ol><p>标准式演绎 — 三段式</p><ul><li>大前提：已知共性原理（或假设），该原理（或假设）具有一般性和普遍性。</li><li>小前提：关于对所研究对象的个性情况的描述。小前提应与大前提有关。</li><li>结论：从共性原理（或假设）推出对所研究对象的具体判断。</li></ul><p>例如：（大前提）18 岁以上为成年人，（小前提）叶某今年 20 岁，（结论）那么叶某是成年人。</p><p>常见式演绎 — 4W</p><ol><li>What’s going on? 描述现象</li><li>Why did thits happen? 分析原因</li><li>What lies ahead? 判断趋势</li><li>Which course of action should i take? 提出对策</li></ol><h3 id="重要性思维"><a href="#重要性思维" class="headerlink" title="重要性思维"></a>重要性思维</h3><blockquote><p>将资源花在关键改进点上。</p></blockquote><h2 id="分析到什么程度-打开分析视角"><a href="#分析到什么程度-打开分析视角" class="headerlink" title="分析到什么程度 - 打开分析视角"></a>分析到什么程度 - 打开分析视角</h2><h3 id="对比视角"><a href="#对比视角" class="headerlink" title="对比视角"></a>对比视角</h3><h4 id="对比类型"><a href="#对比类型" class="headerlink" title="对比类型"></a>对比类型</h4><ul><li><p>参照物</p><ul><li>与自身纵向对比：过去和现在对比</li><li>与其他横向对比：与同类或相似的其他对象对比</li></ul></li><li><p>对比指标性质</p><ul><li>频数统计：分类型数据</li><li>均值分析：数值型数据</li></ul></li></ul><h4 id="对比可信度"><a href="#对比可信度" class="headerlink" title="对比可信度"></a>对比可信度</h4><ul><li><p>时间可比性：刨除特殊时段/时间粒度和长度一致。例如：夏天卖棉袄和冬天卖棉袄。</p></li><li><p>空间可比性：刨除特殊环境。例如：北极卖棉袄和赤道卖棉袄。</p></li><li><p>数量可比性：同量纲</p><ol><li><p>统一单位，使数据可比。例如：身高（cm）和体重(kg)。</p><p>方法：变异系数法 — $v = \frac{\sigma}{\bar x}$，刻画单位平均水平下的差异。</p></li><li><p>剔除数量量级差异，使变量统一可比。例如：手掌长度与身高（接近 10 倍）。</p><p>方法：变量标准化 — $Z = \frac{x - \mu}{\sigma}$，各变量均值和标准差都化为 0 和 1。</p></li></ol></li></ul><h3 id="分类视角"><a href="#分类视角" class="headerlink" title="分类视角"></a>分类视角</h3><h4 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h4><p>同类共性，异类区别，针对性营销。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>以客户分类为例：</p><ol><li>分类维度处理：标准化、<a href="#因子分析">因子分析</a></li><li>客户细分检验：<a href="#聚类分析">聚类分析</a>、方差分析</li><li>目标市场分析：<a href="#矩阵分析">矩阵分析</a></li><li>目标客户定位：方差分析、交叉分析、比较分析、对应分析</li></ol><h3 id="相关视角"><a href="#相关视角" class="headerlink" title="相关视角"></a>相关视角</h3><h4 id="相关定义"><a href="#相关定义" class="headerlink" title="相关定义"></a>相关定义</h4><p>A 与 B 相关有以下情况：</p><ol><li>因果：A -&gt; B 或 B -&gt; A；</li><li>共存：C -&gt; A <strong>且</strong> C -&gt; B。</li></ol><p><strong>注：要判断因果，先证相关性。</strong></p><h4 id="相关判定"><a href="#相关判定" class="headerlink" title="相关判定"></a>相关判定</h4><ul><li><p>数值型：相关系数 — $r(X, Y) = \frac{Cov(X ,Y)}{\sqrt{Var|X| Var|Y|}} = \frac{E|XY| - E|X|E|Y|}{\sqrt{Var|X| Var|Y|}}$</p></li><li><p>分类型：方差分析 — $SST（总体信息） = SSR（组间） + SSE（组内）$</p><ul><li>SSR 大 =&gt; 分组属性引起差异，相关</li><li>SSE 大 =&gt; 分组属性以外的属性引起差异，无关</li><li>综上，SSR 小，SSE 大 =&gt; 无关，不存在显著差异</li><li>若 P(SSR = 0) &lt; 0.05，拒绝假设“SSR = 0”，即拒绝“无关”，则表明“相关”，即“存在差异”</li></ul></li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ol><li><p>规模预测</p><p>例如：道格拉斯生产函数 $y = A K^\alpha L^\beta \mu，A-技术，K-资本，L-劳动力，\alpha 、\beta-弹性系数，\mu-干扰因子$</p></li><li><p>精准预测</p><p>例如：方差分析（验证相关） + 交叉分析（偏好差异），对不同用户群体进行精准营销。</p></li></ol><h3 id="描述视角"><a href="#描述视角" class="headerlink" title="描述视角"></a>描述视角</h3><h4 id="整体趋势"><a href="#整体趋势" class="headerlink" title="整体趋势"></a>整体趋势</h4><ul><li>集中趋势：加权平均分 $\bar x = \frac{\sum x_i f_i}{i}$</li><li>离中趋势：变异系数 $v = \frac{\sigma}{x}$</li></ul><h4 id="个体波动"><a href="#个体波动" class="headerlink" title="个体波动"></a>个体波动</h4><ol><li>研究单独个体</li><li>离群、异常发现</li><li>研究个体间差异</li></ol><h3 id="具体业务中的视角选择"><a href="#具体业务中的视角选择" class="headerlink" title="具体业务中的视角选择"></a>具体业务中的视角选择</h3><p>不同层次组合应用。</p><hr><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><h3 id="RATER"><a href="#RATER" class="headerlink" title="RATER"></a>RATER</h3><p>客户满意度模型：</p><ul><li><p>硬实力</p><ul><li><p>外在：Tangible 有形度</p><p>有形的服务设施、环境、服务人员的仪表以及对客户的帮助和关怀的有形表现。</p></li><li><p>内在：Assurances 专业度</p><p>企业的服务人员所具备的专业知识、技能和职业素质。</p></li></ul></li><li><p>软实力</p><ul><li><p>外在：Responsiveness 反应度</p><p>服务人员对于客户的需求给予及时反应并能迅速提供服务的愿望。</p></li><li><p>内在：</p><ul><li><p>Reliability 信赖度</p><p>企业是否能够始终如一地履行自己对客户所做出的承诺，获得良好的口碑与客户的信赖。</p></li><li><p>Empathy 同理度</p><p>服务人员能够随时设身处地地为客户着想，真正地同情理解客户的处境，了解客户的需求。</p></li></ul></li></ul></li></ul><h3 id="KANO"><a href="#KANO" class="headerlink" title="KANO"></a>KANO</h3><p>属性分类：</p><div class="table-container"><table><thead><tr><th>属性</th><th>含义</th><th>用户情绪</th><th>重要性</th><th>示例</th></tr></thead><tbody><tr><td>必备属性 M（Must be）</td><td>产品或服务的最核心的属性</td><td>有则无感，无则厌恶</td><td>1 +</td><td>手机能打电话</td></tr><tr><td>一维属性 O（One-dimensional）</td><td>与用户态度线性正相关的属性</td><td>有则好感，无则厌恶</td><td>2 \</td><td></td><td>手机电池快充</td></tr><tr><td>魅力属性 A（Attractive）</td><td>用户期望的属性</td><td>有则喜，无无感</td><td>3 \</td><td></td><td>手机高刷新率</td></tr><tr><td>可有可无属性 I（Inessential）</td><td>无论是否具备该属性，用户都无所谓</td><td>有无皆无感，无关紧要</td><td>4 -</td><td>手机编程</td></tr><tr><td>厌恶属性 R（Repugnant）</td><td>具备了反而让用户不满</td><td>有则厌恶，无则无感</td><td>× 不该有</td><td>手机上传隐私数据</td></tr></tbody></table></div><p>两大原则确定新产品的属性开发顺序：</p><ol><li><p>优先原则（M &gt; O &gt; A &gt; I）</p><p>产品研发人员的优先研发顺序：必备属性 &gt; 一维属性 &gt; 魅力属性 &gt; 可有可无属性。</p></li><li><p>组合原则(M + O + A)</p><p>有竞争力的产品应尤三部分组成：必须满足用户的必备属性 + 领先竞争对手的一维属性 + 差异化的魅力属性。</p></li></ol><p>注意事项：</p><ol><li><p>用户的差异性</p><p>对于同一个属性，不同用户的态度是不同的。</p><ul><li>在已知产品细分市场的前提下，针对不同的细分市场进行 KANO 分析</li><li>在不清楚细分市场的前提下，根据 KANO 分析结果对用户需求进行市场细分，以便对不同细分市场提供不同功能的产品或服务</li></ul></li><li><p>用户需求的发展性</p><p>对于同一个属性，其属性不可能恒定不变。即使是创新属性也可能随业界发展变成通用标准，变成一维属性或必备属性。因此，产品或服务的设计者需要进行连续性的 KANO 调查，以把握用户需求的发展和变化。</p></li></ol><h3 id="SWOT"><a href="#SWOT" class="headerlink" title="SWOT"></a>SWOT</h3><div class="table-container"><table><thead><tr><th>内部\外部</th><th>Strength（优势）</th><th>Weakness（弱势）</th></tr></thead><tbody><tr><td>Opportunity（机会）</td><td>SO</td><td>WO</td></tr><tr><td>Threaten（威胁）</td><td>ST</td><td>WT</td></tr></tbody></table></div><h3 id="IEF内外因素评价矩阵"><a href="#IEF内外因素评价矩阵" class="headerlink" title="IEF内外因素评价矩阵"></a>IEF内外因素评价矩阵</h3><p>IEF 内外因素评价矩阵用来对于 SWOT 分析中的数据进行量化：</p><ol><li>分别计算割割因素的评分和权重</li><li>分别计算机会、威胁、优势、劣势的加权平均数</li><li>用加权平均数的大小判断市场吸引力和企业竞争力，并给出相应的战略建议</li></ol><p>评分数据来源:</p><ul><li>专家访谈：专家适合对具体研究的<strong>企业外部因素</strong>（<a href="#pest">PEST</a>）进行评分。</li><li>市场调研：消费者对产品或服务有切身体验，适合对<strong>企业内部因素</strong>评分。</li></ul><div class="table-container"><table><thead><tr><th><strong>权重确定法</strong></th><th>主观赋权法</th><th>客观赋权法</th></tr></thead><tbody><tr><td>思路与优缺点</td><td>专家经验主观判断；定性；简单</td><td>历史数据研究评价；定量；复杂</td></tr><tr><td>常用方法</td><td>层次分析法</td><td>主成分分析法（或因子分析法）</td></tr><tr><td>其他方法</td><td>环比评分法、最小平方法</td><td>变异系数法、回归分析</td></tr></tbody></table></div><p>权重计算：</p><ol><li>计算平均分：$\bar{x} = \frac{\sum x_i}{n}$</li><li>计算频率：$p_i = \frac{n_i}{n}$</li><li>计算方差：$\sigma_i = \frac{\sum(x_i - \bar{x})^2 p_i}{n}$</li><li>计算变异系数：$v_i = \frac{v_i}{\sigma_i}$</li><li>计算权重：$\omega_i = \frac{v_i}{\sum v_i}$</li></ol><div class="table-container"><table><thead><tr><th>内部\外部</th><th>Strength（优势）</th><th>Weakness（弱势）</th></tr></thead><tbody><tr><td>Opportunity（机会）</td><td>SO</td><td>WO</td></tr><tr><td>Threaten（威胁）</td><td>ST</td><td>WT</td></tr></tbody></table></div><h3 id="用户行为五阶段、5W2H"><a href="#用户行为五阶段、5W2H" class="headerlink" title="用户行为五阶段、5W2H"></a>用户行为五阶段、5W2H</h3><p>用户行为五阶段：</p><ol><li>产生需求</li><li>信息收集</li><li>方案比选</li><li>购买决策</li><li>购后行为</li></ol><p>5W2H：</p><ul><li>When 时间</li><li>Where 地点</li><li>Who 对象</li><li>What 事件</li><li>Why 原因</li><li>How 方式</li><li>How much 程度</li></ul><h3 id="品牌知觉图"><a href="#品牌知觉图" class="headerlink" title="品牌知觉图"></a>品牌知觉图</h3><p>品牌知觉图用于品牌形象分析，是指基于<strong>品牌形象数据</strong>用距离远近反映品牌与精神价值相关程度的图形。距离越近，表示相关程度越大。</p><p>解读方法：</p><ul><li><p>圆心定理 - 最符合品牌的形象</p><p>以各品牌为圆心，最先圈进去的指标就是最符合该品牌定位的精神价值。</p></li><li><p>向量分析 - 品牌具有某形象的程度</p><ol><li>从原点向任一指标画一条射线，构成一个向量；</li><li>然后将所有品牌对这个向量做垂线；</li><li>垂点越靠近向量箭头指向的指标，表明该产品越具有该指标描述的形象。</li></ol></li><li><p>余弦定理 - 品牌定位相似性/竞争性</p><p>从原点向任意两品牌分别画一条射线，构成两个向量。向量夹角越小，则夹角余弦越大，表明两个品牌相关性越强，定位相似性高，具有竞争关系。</p></li><li><p>原点定理 - 品牌差异性</p><ul><li>越远离原点的品牌，消费者越容易识别，说明品牌的特征越明显；</li><li>越靠近原点的品牌，消费者越不容易识别，说明品牌没有显著特征，越缺乏差异化认知。</li></ul></li></ul><h3 id="Graveyard"><a href="#Graveyard" class="headerlink" title="Graveyard"></a>Graveyard</h3><p>Graveyard 模型能够反映提示前知名度和提示后知名度之间的内在关系。</p><ol><li>提示后知名度为横坐标，提示前知名度为纵坐标。</li><li><p>回归拟合曲线体现了品牌变化发展的总体趋势和平均发展水平，分布在该回归拟合线周围的品牌则体现了各品牌相对于平均发展水平的波动和差异。</p><ul><li>正常品牌：位于回归曲线<strong>周围</strong>，品牌知名度与市场上的平均水平比较一致。</li><li>衰退品牌：位于回归曲线<strong>右下方</strong>，其提示前知名度明显低于提示后知名度，显现出该品牌被消费者淡忘的趋势。</li><li>利基品牌：位于回归曲线<strong>左上方</strong>，其提示前知名度高于提示后知名度，虽然品牌认知率相对不高，但是品牌回忆率较高，消费者对其忠诚度较高。</li><li>强势品牌：位于回归曲线<strong>右上方</strong>，其提示前知名度和提示后知名度都很高，消费者对其忠诚度很高，这些大都是市场上的强势品牌。</li></ul></li></ol><p>制作方法:</p><ol><li>先计算各品牌提示前知名度和提示后知名度；</li><li>以提示后知名度为 X 轴、提示前知名度为 Y 轴绘制散点图，每个点代表一个品牌；</li><li>对散点做回归拟合线。 </li></ol><h3 id="PSM"><a href="#PSM" class="headerlink" title="PSM"></a>PSM</h3><p>PSM（Price Sensitivity Measurement）模型即价格敏感度测试模型。利用 PSM 模型测试价格，不需要预先给出价格，而是让受访者自己表示他们可接受的价格范围。</p><p>模型搭建</p><ol><li>出示新品 demo 或概念后，询问 4 个问题：<ol><li>哪个价格让你开始觉得便宜？</li><li>哪个价格让你开始觉得贵？</li><li>哪个价格让你开始觉得太贵而不买？</li><li>哪个价格让你觉得太便宜，不相信它的质量而不买?</li></ol></li><li>根据受访者回答，统计出每个价格在上述 4 个问题上的累计人数百分比</li><li>根据每个价格（X 轴）的累计人数百分比（Y 轴）绘图，得到四条相交曲线</li><li><p>由图可确定</p><ul><li><p>两条相交曲线与其交点所构成的上方区域表示接受该交点对应的价格水平的市场规模</p></li><li><p>最优价格点</p><p>两条曲线与交点构成的上方区域面积最大的交点价格即最优价格点。</p></li><li><p>可接受价格点</p><p>“开始觉得便宜”曲线和“开始觉得贵”曲线的交点。</p></li><li><p>可接受价格区间</p><p>曲线所谓区域的左右端点价格。</p><p>证明：</p><ol><li>最优价格点和可接受价格点都在该区域内；</li><li>对于端点，“觉得太贵而不买”和“觉得太便宜而不买”的人数增幅大于“开始觉得便宜”和“开始觉得贵”，导致整体市场规模减小；</li><li>因此端点价格即可接受价格区间。</li></ol></li><li><p>不同市场的规模</p><p>设：</p><ul><li>A = 开始觉得便宜的累计人数百分比</li><li>B = 觉得太便宜而不买的累计人数百分比</li><li>C = 开始觉得贵的累计人数百分比</li><li>D = 觉得太贵而不买的累计人数百分比</li></ul><p>有：</p><ul><li>$可接受者 = 1 - A - C$：对于该价格不觉得贵也不觉得便宜的人数比例</li><li>$保留接收者 = A - B + C - D$：对于该价格觉得贵但是不太贵或者觉得便宜但是不太便宜的人数比例。</li><li>$不接受者 = B + D$：觉得该价格太贵或太便宜而不买的人数比例。</li></ul></li></ul></li></ol><h3 id="4P-营销理论"><a href="#4P-营销理论" class="headerlink" title="4P 营销理论"></a>4P 营销理论</h3><p>产品、价格、渠道、促销合成营销组合。通过营销组合，企业引导商品或服务从生产者到达消费者的决策活动成为营销决策。做出科学的营销决策就需要平衡好<em>做好产品</em>、<em>定好价格</em>、<em>铺好渠道</em>、<em>打好促销</em>这四个方面。</p><ul><li><p>Product 产品</p><ul><li><p>规模预测分析：季节分解法</p><p>如何决定生产规模？</p><ol><li><p>该生产多少？</p><p>在市场经济环境下，该生产多少由市场需求决定，需要预测市场规模。</p></li><li><p>能生产多少？</p><p>在资源约束环境下，能生产多少是由企业所拥有的生产要素决定的，需要预测产出规模。</p></li></ol><p>市场规模预测和产出规模预测统称“规模预测”。</p></li><li><p>产品属性分析：<a href="#kano">KANO 模型</a></p><p>根据市场所需要的产品属性及其需求程度，挖掘消费者对产品的核心需求与偏好，明确产品属性开发优先级。</p></li></ul></li><li><p>Price 定价</p><p>定价既是产品优劣的反映，也是顾客眼中的产品价值，是产品的竞争性定位和销售力的体现。</p><p>定佳决策分析：<a href="#psm">PSM</a></p></li><li><p>Place 渠道</p><p>渠道价值分析 - “渠道为王”，是影响企业能否赢得市场的一个重要竞争力。在多渠道共同发生作用时，只有准确地对每个渠道的价值进行评价，才能做好渠道资源分配，实现效益最大化。</p></li><li><p>Promotion 促销</p><p>营销者向消费者传递有关本企业及产品的各种消息，说服或吸引消费者购买其产品，以达到扩大销售量的目的。为了达到促销目的，通常会在约束条件下搭配媒体组合使传播效果最优，常用线性规划解决。</p><p>资源配置三要素：</p><ol><li>目标函数</li><li>约束条件</li><li>决策变量</li></ol><p>资源配置方法：线性规划</p></li></ul><h3 id="AARRR"><a href="#AARRR" class="headerlink" title="AARRR"></a>AARRR</h3><p>用户生存周期可归纳为 AARRR 漏斗模型。</p><h4 id="Acquisition-获取"><a href="#Acquisition-获取" class="headerlink" title="Acquisition 获取"></a>Acquisition 获取</h4><p>关键：降低用户的使用门槛，结合不同阶段用户群体的特征，制定最适合的拉新策略，同时时刻关注各个核心数据指标；而不是考虑各种渠道推广引流。</p><ul><li><p>产品角度</p><ol><li><p>简化注册登录流程</p><p>账号强相关产品可采取手机+短信验证码快捷注册登陆；非账号强相关产品可在用户体验核心功能时才要求注册登录。</p></li><li><p>滞后权限授权</p><p>体验相关功能时才进行授权；安装后第一时间授权影响体验。</p></li></ol></li><li><p>用户初次进行产品介绍/操作指引</p><p>适量（&lt;=4）的页面/流程介绍核心/优质内容，复杂功能进行操作指引降低使用门槛；忌繁琐冗长。</p></li><li><p>运营角度</p><p>产品不同阶段中用户群体的特征不同，可从冷启动期/增长期/稳定期/衰退期四个阶段看：</p><ol><li><p>冷启动期</p><p>现状：只有第一批少量用户。</p><p>措施：关注用户质量而非数量，打造用户交流社区，评估核心用户的反馈，对产品进行打磨。</p><p>关注指标: DAU、留存、活跃时长。</p></li><li><p>增长期</p><p>现状：产品经过冷启动期的打磨得到核心用户认证，开始进入飞速增长阶段。</p><p>措施：结合目标群体的普遍特征，寻找合适的渠道进行推广引流。</p><p>关注指标：ROI — 以以尽可能少的成本，获取高质量的用户。</p></li><li><p>稳定期</p><p>现状：由于产品用户群体的不同，产品的用户规模达到增长瓶颈。</p><p>措施：寻找产品是否有延展方向，通过需求的延展获取更多用户。</p><p>关注指标: 用户留存。</p></li><li><p>衰退期</p><p>现状：产品早晚会步入衰退期，用户慢慢转移至其他替代产品，用户数量逐渐降低。流失用户的召回存在于每个时期，在此阶段则尤为重要，往往需要面临较大的困难与成本守住用户流量。</p><p>措施：召回流失用户，减缓产品的衰退。可从四个角度召回：</p><ol><li>利益驱动召回：优惠券、礼品、抽奖等活动；</li><li>社交属性召回：社交联动（关注、评论、邀请）；</li><li>产品核心需求召回：周期性收益产品查看/获取收益；</li><li>新功能刺激召回：版本重大更新、新功能。</li></ol><p>关注指标: 召回率，流失指标。</p></li></ol></li></ul><h4 id="Activation-激活"><a href="#Activation-激活" class="headerlink" title="Activation 激活"></a>Activation 激活</h4><p>注：激活 != 用户注册。对于账号强相关的产品，可以将注册作为用户激活的一个参考依据。从整体上来讲，用户激活更应该考虑的是<strong>用户对于产品核心功能的使用情况</strong>。比如：微博用户活跃情况、抖音用户短视频观看情况。</p><p>关键：</p><ol><li>找到自己产品用户激活的标准。</li><li>根据产品的类型特点，做对应的产品模块设计，同时辅以运营活动，创造用户可触达的需求场景，进而达成目标，激活用户。</li><li>关注核心指标，而非一味提高用户注册量。</li></ol><p>不同类型的产品用户群体不同，用户激活的方法也不尽不同，整体上可分为三种类型进行讨论：</p><ul><li><p>单用户产品</p><p>单用户产品：服务于个人用户，没有过多的不同用户之间的接触以及不同角色的产品。大致可分为两类：</p><ul><li><p>工具类</p><p>核心：便捷使用，舒适体验。</p><ol><li>工具产品需要拿来即用，所以必须简化流程，让用户速上手。</li><li>工具产品设计应该符合生活中的逻辑，降低使用门槛，增强用户体验。</li></ol></li><li><p>游戏</p><p>核心：提升代入感。</p><ol><li>合适的玩家指引：无论单人还是网络游戏，玩家在游戏初期都存在认知的过程，应该尽快让玩家了解规则，体验游戏。</li><li>由浅入深的体验：游戏初期应该给予玩家适应的过程，初期可以降低游戏的难度和复杂度，先保证游戏体验，待其适应再逐步放开。</li></ol></li></ul></li><li><p>多用户产品</p><p>多用户产品：多用户接触的产品。根据用户关系，分为两个不同的类型：</p><ul><li><p>熟人产品</p><p>核心：获取熟人的联系。</p><p>作为通讯类产品若不能及时联系到熟人，就没有沟通对象，则失去使用意义。例如：微信能够通过手机通讯录和 QQ 好友快速建立起与熟人之间的联系，开启新的通讯体验，所以很快获取了大量的用户。若新的通讯 APP 需要通过一套新的 ID 标识（与原本的联系方式无关联）去相互添加才能使用，这无疑增加了使用成本。</p></li><li><p>陌生人产品</p><p>核心：搭建起陌生人之间的联系，即用户品配。</p><ol><li><p>水军：投放一定的虚拟用户，用于激活前期为用户创造需求场景。但随着用户体验的深入，水军会被用户察觉并反感，因此只适用于激活前期。</p></li><li><p>用户匹配：通过为用户匹配或者推荐用户，促成用户之间的联系，进一步沉浸于产品中，达成用户激活。常见的匹配策略：LBS 匹配/用户属性匹配/个性化推荐匹配。</p></li></ol></li></ul></li><li><p>多角色产品</p><p>多角色产品：多用户产品且用户存在不同角色。如：美团 — 既有商家也有买家；Uber — 既有司机也有乘客。</p><p>核心：激活各方用户，并达成多角色之间的平衡连接。以 Uber 为例：通过首次免单吸引乘客；通过算法实现多订单下司机与乘客的合理匹配，保证供需的稳定；通过司机补助、乘客优惠促成订单的产生。</p><p>可通过核心指标进行用户的激活与连接情况：</p><ol><li>用户激活率：即用户使用核心功能的占比。各产品的激活定义规则不尽相同，每个产品都必须找到适合自己的激活定义；</li><li>用户激活花费时长：用用户从进入产品，到被激活所花费的时间。时间越短，证明激活效果越明显；</li><li>DAU/MAU：用户日活跃/月活跃的比值。不同类型的产品的 DAU/MAU 存在一定的基准线，如移动游戏的基准线为20%，工具类APP为40%。比值越大，说明用户对于产品的粘性越强，激活效果越明显；</li><li>DAOT：用户日均使用时长。使用时长越长，说明用户的粘性越强，但同时需结合其他指标，评估是否产品流程过长导致的时长增加。</li></ol></li></ul><h4 id="Retention-留存"><a href="#Retention-留存" class="headerlink" title="Retention 留存"></a>Retention 留存</h4><p>用户留存在任何时期都是评估产品是否真正具有价值的重要因素。只有用户感到了价值，才会选择留下了。</p><p>关键：使用户持续使用产品，形成稳定的依赖。</p><p>有效地评估产品的留存水平的指标：</p><ol><li><p>第 N 天计算法</p><ul><li>次日留存：统计日新增用户次日仍然使用产品的用户数量占总新增用户数量的比例；</li><li>7 天留存：统计日新增用户第七天仍然使用产品的用户数量占总新增用户数量的比例；</li><li>30 天留存：统计日新增用户第七天仍然使用产品的用户数量占总新增用户数量的比例。</li></ul><p>强调第N天，其反应的结果也就是随着时间的推移，留存用户逐渐减少，而行业上也存在着对应较为权威的基准 4-2-1 基准，也即40%/20%/10% 为此计算方法下，较为合理的一个水平。</p></li><li><p>N 天内计算法</p><ul><li>次日留存：统计日新增用户次日仍然使用产品的用户数量占总新增用户数量的比例；</li><li>7 天留存：统计日新增用户7天内，再次使用产品的用户数量占总新增用户数量的比例；</li><li>30 天留存：统计日新增用户30天内，再次使用产品的用户数量占总新增用户数量的比例。</li></ul><p>强调N天内，其反应的结果就是30天留存 &gt; 7天留存 &gt; 次日留存，更多的是表现一个产品的活跃水平。</p></li><li><p>改良后第N天计算法：</p><ul><li>次日留存：统计日新增用户，再次使用产品的时间间隔小于24小时的用户所占比例（T+2出数据指标）；</li><li>7天留存：统计日新增用户，再次使用产品的时间间隔小于7个自然天然填的用户所占比例（T+8出数据指标）；</li><li>30天留存：统计日新增用户，再次使用产品的时间间隔小于30个自然天然填的用户所占比例（T+8出数据指标）。</li></ul><p>改良后的第N天计算法，可以准确地反映新增用户的留存水平，避免特殊场景造成的数据指标影响。</p></li><li><p>改良后N天内计算法：</p><ul><li>次日留存：统计日活跃用户中，次日再次使用产品的用户占比（T+2出数据指标）；</li><li>7天留存：统计日活跃用户中，往后7天内再次使用产品的用户占比（T+8出数据指标）；</li><li>30天留存：统计日活跃用户中，往后30天内再次使用产品的用户占比（T+8出数据指标）。</li></ul><p>针对N天内计算法，由于计算方式反映的更多是产品的活跃水平，并不单纯针对新增用户，产品的迭代过程中，往往会有很多核心功能/用户体验等的改变，想要真实观察产品迭代过程中的留存活跃情况，应当将用户群体进行扩展。</p><p>改良后的N天内计算法，更能清晰/完整地表现所有用户的活跃留存情况。</p></li><li><p>留存标准</p><p>不应该盲目套用，而是应该结合自身产品所处的行业、产品形态以及自身产品定位进行考虑。</p></li></ol><p>提升留存的方向:</p><ol><li><p>产品方向</p><ol><li>提升自己产品的竞争力，不断满足用户的需求，并优化用户体验。</li><li>提升用户对于产品的粘性。<ul><li>日常活跃功能：培养用户习惯。如：日常签到及其奖励体系。</li><li>用户激励体系：鼓励用户行为，并给予认可的反馈，激励用户，成正向循环。如：用户头衔、用户等级。</li><li>强化用户投入：沉淀用户在产品上的行为，使用户对产品产生依赖。即使后来出现竞品，用户也不会轻易放弃。如：<ul><li>时间投入：通过阶段性的任务，量化并强调用户的时间投入，使用户不甘放弃；</li><li>金钱投入：通过年度会员/月度会员等，强化用户的金钱投入，增加用户离平台的损失；</li><li>内容投入：通过 UGC 内容的沉淀，强化用户的内容投入，比如微博/朋友圈/笔记类产品等，用户在使用过程中沉淀了大量的内容，不会轻易放弃；</li><li>情感投入：通过引导用户投入情感，产生精神寄托；</li><li>社交投入：通过形成稳定的圈子关系，强化用户的社交投入，比如微信等社交平台。社交关系越牢靠，用户对于产品的依赖性也越强。</li></ul></li></ul></li></ol></li><li><p>运营方向</p><ol><li><p>用户挽留：减少用户的流失</p><ol><li>明确产品定位及核心竞争力</li><li>从流失用户和活跃用户的特征入手，分析用户流失原因</li><li>结合二者制定优化方案</li></ol></li><li><p>用户召回：召回已流失用户</p><p>召回的两个契机：</p><ol><li><p>让用户看到</p><ul><li>数据关联：通过输入法/浏览记录等，获取并及时为用户推送感兴趣的产品或内容</li><li>关注内容发生变动：当用户关注/收藏的内容发生更新变化时，及时推送用户</li><li>特定时间段/时间点：固定时间点（节日/生日等），向用户推送相关内容</li><li>用户场景变化：当用户所处场景（城市/天气等）发生切换时推送相关内容</li></ul></li><li><p>让用户想起</p><p>要达到让用户主动回想，需要结合产品的调性，长期的诱导或宣传，促使用户的生活记忆与产品产生联系并不断加深认知。</p></li></ol></li></ol></li></ol><h4 id="Revenue-变现"><a href="#Revenue-变现" class="headerlink" title="Revenue 变现"></a>Revenue 变现</h4><div class="table-container"><table><thead><tr><th>用户群体区分</th><th>基本特征</th><th>合适的变现方式</th></tr></thead><tbody><tr><td>免费用户</td><td>固有思维“互联网免费”，基本不进行消费行为</td><td>流量变现；观念引导成为付费用户</td></tr><tr><td>普通用户</td><td>有一定的消费行为及消费意识，挖掘潜力大</td><td>诱导持续消费行为，提高消费额度和频次，养成消费习惯</td></tr><tr><td>优质用户</td><td>消费金额远大于实际价值，注重精神感受</td><td>维护消费后的用户体验，给予特殊待遇</td></tr></tbody></table></div><p>变现方式：</p><ol><li><p>产品及服务变现</p><p>通过与用户直接建立传统买卖关系或为用户提供付费服务获得盈利。</p><p>关键：</p><ol><li>提高产品的核心竞争力（前提）</li><li><p>找到免费与付费的平衡</p><p>平衡在于满足免费用户基本需求的同时，而使付费用户有所收获。在明确用户需求的基础上，对预期需求进行免费，在预期之外的需求（特色服务、体验升级）进行收费。</p></li><li><p>付费行为引导培养</p><p>上瘾模型及激励策略可以培养用户付费行为，诱导用户提升消费额度和频次，提高产品及服务变现的效率。</p><p>上瘾模型：使用户的某些行为发展为习惯。</p><ol><li>触发 - 为用户创造一个场景，使其产生我们想要培养的行为。如：产品和服务的试用。</li><li>行动 - 用户产生培养行为。如：通过一元体验活动开启会员服务。</li><li>激励 - 在用户产生培养行为给予正向反馈。如：给予荣誉成就（精神）或红包（物质）等奖励。</li><li>投入 - 引导用户进行付费后的产品体验，沉浸用户的行为成本，增加用户产生持续付费的可能。如：购物礼品卡（单次抵消额度有限），定时提醒余额和限期。</li></ol></li></ol></li><li><p>流量变现</p><ol><li><p>广告变现：基于用户，通过广告定向投放进行变现。</p><p>现代化广告三要点:</p><ol><li>用户精准 - 精准找到广告的目标用户群体，提升触达有效率；</li><li>时间精准 - 相同的广告，在用户休闲的情况下，往往能够促成转化；在用户忙碌的情况下，更有可能的则是造成骚扰，引起反感；</li><li>场景精准 - 适当的场景下，往往更能促成广告的转化。如：购买手机时推荐耳机。</li></ol></li><li><p>数据变现：基于用户行为活动，通过用户行为脱敏，抽取过滤加工，形成有效、可利用的数据，通过数据的运用或商业转让，获取盈利。<strong>并非卖数据。</strong></p><p>构建用户画像，掌握用户的付费意愿及付费倾向，精准把控用户需求，提供推荐或服务，从而获取盈利。还可以根据相似性，进行关联推荐。</p></li></ol></li></ol><p>相关指标：</p><ol><li><p>LTV：客户终生价值，</p><p>公司从用户生命周期中所得到的全部经济收益的总和，即从用户上手到离开产品所获取的总收益。</p></li><li><p>用户付费率：付费用户群体在活跃用户群体中所占规模比例。</p><p>一旦用户产生付费行为，便成为付费用户。该指标往往用来衡量产品的付费模块是否能够真正触达用户需求。</p></li><li><p>二次付费率：付费用户群体中，产生过二次及以上付费行为的用户所占规模比例。</p><p>通过观察二次付费率指标，可以评估产品付费模块是否对用户产生正向价值？付费体验是否良好？</p></li><li><p>ARPU 及 ARRPU：（通常以月份为维度进行统计）ARPU是指平均每用户收入，ARRPU是指平均每活跃用户收入。</p><p>用以以评估不用渠道的用户质量，不同时期的用户付费情况。</p></li></ol><h4 id="Referral-传播"><a href="#Referral-传播" class="headerlink" title="Referral 传播"></a>Referral 传播</h4><p>自传播：无需借助过多外力，产品自身激发用户间的自发传播。</p><p>自传播优势：</p><ol><li>指数级增长（一传十，十传百）</li><li>用户获取成本低（用户自行推荐节省了渠道成本）</li><li>用户获取质量高（自传播在相似的用户群体中进行）</li><li>口碑效应（用户间讨论形成话题）</li></ol><p>自传播步骤：</p><ol><li><p>传播基础</p><p>条件：</p><ol><li>产品能满足用户需求</li><li>传播手段便捷<ul><li>纵向传播：内容形式转换</li><li>横向传播：跨平台分享</li></ul></li></ol></li><li><p>自主传播</p><p>关键：激发用户传播的欲望。</p><p>出发点：</p><ol><li>制造话题：话题可能会引起讨论并在人群中迅速传播。如：热搜讨论。</li><li>从众心理：个人受到外界人群行为的影响，而在自己的知觉、判断、认识上表现出符合于公众舆论或多数人的行为方式。如：转发锦鲤。</li><li>情绪引导：通过情绪上的引导（产生波动、感同身受），能够促使用户进行分享传播。如：水滴筹。</li><li>引导参与：通过沉淀用户的行为，促使用户分享自身的成果。如：短视频平台发布视频。</li><li>超预期场景：在超预期的场景下，用户分享传播将会变得更加简单。如：买东西被告知中奖。</li></ol></li><li><p>传播转换</p><p>发生自主传播后需要进行有效传播转换，才能达到用户增长的目的。</p><p>出发点:</p><ol><li>可读性：降低被传播用户的接受门槛，轻松获取信息。如：图表优于文字。</li><li>互动：使被传播者与传播者产生互动行为，有参与感或收获。如：帮别人砍价自己也能得到优惠。</li><li>注意力：足够吸引用户的注意力，不至于被忽视。如：标题党。</li></ol></li></ol><p>指标：</p><script type="math/tex; mode=display">K 因子 = 传播数量（每个用户向他的朋友们发出的邀请的数量）* 转化率（接收到邀请的人转化为新用户的转化率）</script><p>K 因子直接体现自传播结果水平：</p><ul><li>K 值大于1时，将激发自传播巨大的力量，K值越大，力量越强</li><li>K值小于1，那么传播水平会逐步减弱，直至消失。</li></ul><h3 id="PEST"><a href="#PEST" class="headerlink" title="PEST"></a>PEST</h3><p><strong>宏观环境</strong>是指影响市场的宏观因素，可归纳为 PEST。</p><div class="table-container"><table><thead><tr><th>环境</th><th>关键指标</th></tr></thead><tbody><tr><td>Politics 政治环境</td><td>政治/经济体制、财政/税收/产业/投资/补助政策、国际/地区关系</td></tr><tr><td>Economics 经济环境</td><td>GDP 及增长率、利率汇率、居民可支配收入、产业结构</td></tr><tr><td>Social 社会文化环境</td><td>人口规模、性别比例、年龄构成、价值观、生活方式、教育状况、消费观念、宗教信仰、风俗习惯</td></tr><tr><td>Technology 技术环境</td><td>国家重点支持、技术更新与传播速度、商品化速度、技术保护情况</td></tr></tbody></table></div><h3 id="波特五力"><a href="#波特五力" class="headerlink" title="波特五力"></a>波特五力</h3><p><strong>企业竞争环境</strong>可归纳为影响企业生存状态的波特五力。</p><div class="table-container"><table><thead><tr><th></th><th>对象</th><th>与企业的关系</th></tr></thead><tbody><tr><td>供应商</td><td>原材料</td><td>讨价还价</td></tr><tr><td>购买者</td><td>产品</td><td>讨价还价</td></tr><tr><td>直接竞争对手</td><td>同类竞品</td><td>抢占市场份额，直接竞争</td></tr><tr><td>间接竞争对手</td><td>替代类竞品</td><td>替代品削弱需求，间接竞争</td></tr><tr><td>潜在进入者</td><td>有可能进入该领域的大企业</td><td>抢占市场的潜在威胁</td></tr></tbody></table></div><h3 id="归因分析"><a href="#归因分析" class="headerlink" title="归因分析"></a>归因分析</h3><h4 id="常见归因分析模型"><a href="#常见归因分析模型" class="headerlink" title="常见归因分析模型"></a>常见归因分析模型</h4><div class="table-container"><table><thead><tr><th>模型</th><th>定义</th></tr></thead><tbody><tr><td>最后交互模型（Last Model）</td><td>认定最后一个渠道的贡献为 100%，因此把转化归功于最后一个渠道</td></tr><tr><td>第一次交互模型（First Model）</td><td>认定第一个渠道的贡献为 100%，因此把转化归功于第一个渠道</td></tr><tr><td>平均模型（Average Model）</td><td>认为所有的渠道的贡献相等，因此将<strong>权重均摊</strong>到参与转化的所有渠道中</td></tr><tr><td>时间衰减模型（Time Decay Model）</td><td>认为贡献程度随时间而衰减</td></tr><tr><td>自定义模型（Customized Model）</td><td>以上四种权重分配都比较武断，无法直接指导投放的优化，因此有针对性的产生了生存分析、通径分析、马尔科夫链、<a href="#夏普利值">夏普利值</a>等模型</td></tr></tbody></table></div><h4 id="夏普利值"><a href="#夏普利值" class="headerlink" title="夏普利值"></a>夏普利值</h4><p>原则：在合作博弈中，所得与贡献相等。</p><p>适用夏普利值的三个特点：</p><ol><li>夏普利值的有效性：联盟 S 具有完整性，不存在具有贡献却未纳入联盟里的参与者</li><li>夏普利值的对称性：参与者价值 V{a, b} = V{b, a}</li><li>夏普利值的可加性：联盟具有独立性，任意两个联盟合并的值等于两个联盟的值的合计，即 V{a, b} = V{a} + V{b} = V(a) + V(b)</li></ol><p>设 |S| 表示与该参与者相关的某联盟 S 中成员的数量，n 表示在合作博弈中所有参与者的数量，则</p><ul><li>与该参与者相关的每个联盟 S 的加权因子为：$\gamma_n (S) = \frac{(|S| - 1)! × (n - |S|)!}{n!}$</li><li>该参与者价值的夏普利值为：$\varphi(v) = \sum \gamma_n(S) × (V(S) - V(S - {I}))$</li></ul><h3 id="RFM"><a href="#RFM" class="headerlink" title="RFM"></a>RFM</h3><blockquote><p>用户画像是了解用户的重要手段，其包含多个方面：用户属性、用户消费特征、用户关联、用户非消费行为…等。其中，<strong>用户消费特征</strong>是用户画像中最核心、与业绩最直接相关的指标。RFM 模型就是根据消费特征对用户进行分层。</p></blockquote><h4 id="Def"><a href="#Def" class="headerlink" title="Def"></a>Def</h4><p>RFM 模型是根据最近消费时间（Recency）、消费频率（Frequency）、消费金额（Monetary）三个指标构建的用户分层模型。</p><ul><li><p>R（Recency）：用户最近一次消费时间间隔</p><p>即，用户最后一次下单时间距今天多长时间。R 的值越小，用户价值越高。</p></li><li><p>F（Frequency）：用户消费频率</p><p>即，用户在固定的时间段内消费了几次。</p><p>该指标反映了用户的<strong>消费活跃度</strong>。F 的值越大，用户价值越高。</p></li><li><p>M（Monetary）：用户消费金额</p><p>即，用户在固定的周期内在平台上花了多少钱。</p><p>该指标直接反映了用户<strong>对公司贡献的价值</strong>。M 的值越大，用户价值越高。</p></li></ul><h4 id="用户分层"><a href="#用户分层" class="headerlink" title="用户分层"></a>用户分层</h4><p>以下三种方法可以根据不同需求选用，一般第一种方法最常用，因为可以直观反映用户价值和重要性，然后根据用户价值和重要性采取不同策略，可操作性强。</p><ol><li><p>等级变量划分法</p><p>根据R、F、M三个指标数据，将其转化为等级变量，如高、低，具体划分标准可依据指标数据分布确定（可取中位数或平均数作为分界线），再根据三个指标等级划分用户等级。</p><p>如果每个指标划分为高、低两种等级，则用户可出现2^3=8种，但可根据实际需要将用户划分为3种等级，如下表所示：</p><p>|R-Recency|F-Frequency|M-Monetary|用户等级|划分群体类型|<br>|-|-|-|-|-|<br>|高|高|高|A|重要价值客户|<br>|高|低|高|A|重要发展客户|<br>|低|高|高|B|重要保持客户|<br>|低|低|高|B|重要挽留客户|<br>|高|高|低|B|一般价值客户|<br>|高|低|低|B|一般发展客户|<br>|低|高|低|C|一般保持客户|<br>|低|低|低|C|一般挽留客户|</p></li><li><p>加权得分法</p><ol><li>将每一个指标归一化，$x_1 = \frac{x - min}{max - min}$，将每个指标都转化到0~1的区间内。需要注意的是R的取值需要进行转化，取 $x_2 = 1 - x_1$；</li><li>赋予指标权重；</li><li>计算用户的加权得分，根据得分对用户进行分层。</li></ol></li><li><p>将指标取值转化为顺序变量，再计算加权得分</p><ol><li>根据分位数（如四分位数）将各项指标转化为1,2,3,4顺序变量</li><li>赋予指标权重；</li><li>计算用户的加权得分，根据得分对用户进行分层。</li></ol></li></ol><hr><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><h3 id="多维度拆解"><a href="#多维度拆解" class="headerlink" title="多维度拆解"></a>多维度拆解</h3><blockquote><p>辛普森悖论：考察数据的整体，和考察数据的部分会得出相反的结论。</p></blockquote><p>Def：</p><p>通过不同维度观察同一组数据，发掘数据波动真正的原因。</p><p>拆分角度：</p><ul><li>指标构成：根据单一指标的构成进行拆解分析。如：买家城市分为一线、二线、三线。</li><li>业务流程：根据业务流程进行拆解分析。如：推荐页购物分为浏览、收藏、加购、购买。</li></ul><p>示例：</p><p>为何推荐页购买率低？</p><ol><li>从指标构成拆解：对于不同城市，买家对本身没有强烈购买意愿的推荐物品的购买决策取决于当地经济水平和收入剩余，所以一线城市购买率可能高于二三线，但二三线用户基数大，所以拉低整体购买率。可以根据城市经济水平推荐价格更合适的物品。</li><li>从业务流程拆解：通过各流程发现，浏览/收藏/加购多，而最终购买少，表明用户是感兴趣的但无法下定决心，猜测可能是不符合心里的预期价格导致推迟或放弃购买。可以通过组合优惠或购买赠送优惠券的方式增大购买的吸引力。</li></ol><h3 id="逻辑树分析"><a href="#逻辑树分析" class="headerlink" title="逻辑树分析"></a>逻辑树分析</h3><p>Def：</p><p>逻辑树分析法通过将问题的各个要素以逻辑树的形式体现出来，同时从<strong>广度</strong>和<strong>深度</strong>两方面找出问题所在。逻辑树结构能够帮助理清思路及层次，避免混乱、重复、无关的思考，从而有针对性地制定策略。</p><p>步骤：</p><ol><li>找出核心问题，将其放在逻辑树最上层；</li><li>思考并罗列出所有能够影响核心问题的因素或思路，将其罗列在第二层；</li><li>思考并罗列出所有能够实现各影响因素或思路的方法，将其罗列在第三层；</li><li>针对第三次层方法，思考并罗列相应的解决对策；</li><li>查漏补缺。</li></ol><p>示例：</p><p>增加利润</p><ul><li>增加销售额<ul><li>增加销售量 -&gt; 促销活动</li><li>提高单价 -&gt; 组合套装</li></ul></li><li>降低成本<ul><li>降低原料成本 -&gt; 改变供应商</li><li>降低人力成本 -&gt; 智能化设备</li></ul></li></ul><h3 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a>假设检验</h3><p>Def：</p><ol><li>假设结果：对总体参数提出一个假设值</li><li>验证假设：利用样本信息判断这一假设是否成立</li></ol><p>显著性水平：</p><h3 id="群组分析"><a href="#群组分析" class="headerlink" title="群组分析"></a>群组分析</h3><p>Def：</p><p>同期群分析（Cohort Analysis），又称群组分析，根据初始行为的发生时间将用户划分为不同的群组，观察相似群组用户的行为特征表现。</p><p>示例：</p><p>（注：百分比为留存率 = 基期新增用户某月使用数 / 基期新增用户数）</p><div class="table-container"><table><thead><tr><th>月份</th><th>新增用户</th><th>+1 月</th><th>+2 月</th><th>+3 月</th><th>+4 月</th></tr></thead><tbody><tr><td>1 月</td><td>106</td><td>62%</td><td>51%</td><td>43%</td><td>34%</td></tr><tr><td>2 月</td><td>122</td><td>60%</td><td>48%</td><td>36%</td><td></td></tr><tr><td>3 月</td><td>279</td><td>49%</td><td>27%</td><td></td><td></td></tr><tr><td>4 月</td><td>302</td><td>35%</td><td></td><td></td></tr></tbody></table></div><ul><li>横向对比：每个月份的新增用户的在几个月内的留存变化情况</li><li>纵向对比：比较不同月份的新增用户的新增数量和留存变化</li></ul><p>可以观察到：</p><ol><li>1、2 月份新增用户数少于 3、4 月份 — 因为 3、4 月份有拉新活动，新用户明显增多；</li><li>3、4 月份的留存率低于同期 1、2 月份的留存率 — 3、4 月份拉新得来的新用户并未有效转化，可能新用户羊毛党居多或者不是目标用户。</li></ol><p>如果将观察指标从“留存率”换为“日均使用时长”，则可以从另一个角度了解这段时间的变化情况。</p><h3 id="因子分析"><a href="#因子分析" class="headerlink" title="因子分析"></a>因子分析</h3><p>Def：</p><p>同类型因素间的相关性会造成重叠信息的扩大化，增加分类偏差。因子分析是数据消减的常用方法，通过数据聚合，用少数不相关的因子反映多个具有相关性的原始信息，起到剔除相关性和数据降维的作用。</p><p>步骤：</p><ol><li>适用性检验：原始维度具有相关性才能进行因子分析。</li><li>因子提取：提取主要因子。常见方法有主成分分析。</li><li>因子旋转：（类似旋转坐标轴）有效区隔各因子的维度特征，使之差异化。<ul><li>因子载荷：表示因子对维度信息的解释程度。</li></ul></li><li>因子命名：根据维度特征的特点对因子进行命名。</li><li>计算因子得分：某因子得分越高表明越具有该因子的特征。</li></ol><h4 id="聚类分析"><a href="#聚类分析" class="headerlink" title="聚类分析"></a>聚类分析</h4><p>Def：</p><p>用于非监督分类 — 事先不知该分成几类，探索样本数据的内在规律进行归类，使各类别之间具有显著性差异并描述各类别特征。</p><p>分类：</p><ol><li><p>层次聚类（系统聚类）</p><p>特点：事先不需要知道分几类，树状图会显示出所有的聚类方案。</p><p>步骤：</p><ol><li>根据样本距离，将距离最近的样本合为一类；</li><li>然后计算所形成的类别与其他样本的距离，对距离最近样本再做合并；</li><li>依此类推，直到所有样本聚成一类，形成树状图。</li></ol></li></ol><ol><li><p>迭代聚类</p><p>特点：根据指定<strong>类别数</strong>进行分类。</p><p>步骤：</p><ol><li>选择初始类中心点；</li><li>将每个点按最近距离进行归类，并重新计算形成的新类的中心点；</li><li>不断迭代，直至归类正确（每个点到所归类的中心点最近）。</li></ol></li></ol><p>层次聚类与迭代聚类比较：</p><div class="table-container"><table><thead><tr><th></th><th>层次聚类</th><th>迭代聚类</th></tr></thead><tbody><tr><td>思路</td><td>逐层合并</td><td>不断迭代，以确定类别中心点和类别构成</td></tr><tr><td>类别数</td><td>事先未知。树状图会显示所有聚类方案，可以从中选择最优方案</td><td>事先已知并需要指定。若聚类效果不好，则需要重新设定类别数，重新聚类</td></tr><tr><td>计算速度</td><td>由于反复计算距离，当样本量太大或者变量比较多时计算速度比较慢</td><td>计算量小，内存占用低，运行速度快。常用于处理多变量、大样本的数据</td></tr><tr><td>聚类对象</td><td>记录与变量均可</td><td>只能对记录聚类</td></tr><tr><td>数据类型</td><td>连续变量和分类变量均可</td><td>只可用连续变量</td></tr></tbody></table></div><h4 id="回归分析"><a href="#回归分析" class="headerlink" title="回归分析"></a>回归分析</h4><p>Def：</p><p>探索两种或两种以上变量间相互依赖的定量关系（方程）。</p><p>基本概念（以道格拉斯生产函数为例：$y = A K^\alpha L^\beta \mu$）：</p><ol><li><p>自变量与因变量</p><p>自变量是因，常用 x 表示；因变量是果，常用 y 表示。</p><p>在道格拉斯生产函数中：</p><ul><li>y（生产规模）是因变量</li><li>K（资本） 和 L（劳动力） 为自变量，受企业影响</li><li>A 是外生变量，不受企业影响，是一个常数。</li></ul></li><li><p>一元与多元</p><p>元，指变量的个数。</p><p>在道格拉斯生产函数中：</p><ul><li>存在 K 和 L 两个变量，因此为二元分析。</li></ul></li><li><p>线性与非线性</p><p>如果回归模型中的<strong>所有自变量都是一次幂</strong>，则是线性回归；否则，为非线性回归。</p><p>在道格拉斯生产函数中：</p><ul><li>自变量 K 和 L 分别为 $\alpha ∈ (0, 1)$ 次幂和 $\beta ∈ (0, 1)$ 次幂，因此为非线性回归</li><li><p>为了使用线性回归，可以将非线性函数<strong>线性化</strong>（通过取 ln 对数化），将 K 和 L 转化为一次幂：</p><p>$lny = lnA + \alpha lnK + \beta lnB + ln\mu$，设 $y_1 = lny$，$K_1 = lnK$，$B_1 = lnB$，则 $K_1$ 和 $B_1$ 为一次幂，与 $y_1$ 存在线性关系。</p></li></ul></li></ol><p>回归分析预测步骤：</p><ol><li>整理数据源与线性化</li><li>调用回归分析</li><li>确定常量 A 和系数$\alpha$，$\beta$，求出回归方程</li><li><p><strong>假设检验</strong></p><p>原因：经验模型不一定适用于所有场景；根据散点图判断回归模型具有主观性。</p><p>检验方法:</p><ul><li><p>$T$ 检验</p><p>对回归<strong>系数</strong>的检验，思路：若 X 与 Y 相关，则回归系数≠0。检验标准是 $T_{统计量}$ 的伴随概率 $P &lt; \alpha（显著性水平，默认为 0.05）$。</p><p>若检验不通过，以 L（劳动力）为例，表明 L 的回归系数等于 0 不是小概率事件，即 L 与 y 的相关性不强，因此提出 L 这个自变量，重新回归；对重新回归后的系数再次检验，知道所有剩余的自变量都通过检验为止。若用剔除法仍有自变量没有通过检验，则表明回归模型不恰当，需要重新建立回归模型。</p></li><li><p>$F$ 检验</p><p>对回归<strong>系数</strong>的检验，思路：若回归方程有效，则回归方程对样本数据的信息解释量要高于误差项 $\mu$ 对样本数据信息的解释量。检验标准是 $F_{统计值}$ 的伴随概率 $Significance F &lt; \alpha（显著性水平，默认为 0.05）$。</p><p>若检验不通过，则表明从样本数据来看，L（劳动力）和 K（资本）并不能充分解释生产规模的变动，即可能还有其他重要的影响因素没有纳入模型中，需要重新建立模型。</p></li></ul></li><li><p>回归预测</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>new_post</title>
      <link href="/2020/08/29/new-post/"/>
      <url>/2020/08/29/new-post/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2020/08/12/test/"/>
      <url>/2020/08/12/test/</url>
      
        <content type="html"><![CDATA[<p>Test for hexo.</p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 实战问题</title>
      <link href="/2020/06/20/mysql-practise/"/>
      <url>/2020/06/20/mysql-practise/</url>
      
        <content type="html"><![CDATA[<p><font color="#008000"> [Updated] </font> 本文收集了一些常见 MySQL 实践知识点。（基于《MySQL 实战 45 讲》）</p><a id="more"></a><h1 id="MySQL-实战问题"><a href="#MySQL-实战问题" class="headerlink" title="MySQL 实战问题"></a>MySQL 实战问题</h1><h2 id="普通索引和唯一索引的选择"><a href="#普通索引和唯一索引的选择" class="headerlink" title="普通索引和唯一索引的选择"></a>普通索引和唯一索引的选择</h2><h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><h3 id="查询过程的索引区别"><a href="#查询过程的索引区别" class="headerlink" title="查询过程的索引区别"></a>查询过程的索引区别</h3><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ul><li>对于普通索引来说，查找到满足条件的第一个记录后，需要继续查找下一个记录，直至碰到第一个不满足条件的记录；</li><li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</li></ul><h4 id="性能差距"><a href="#性能差距" class="headerlink" title="性能差距"></a>性能差距</h4><p>大部分情况下，微乎其微。</p><p>InnoDB 以“数据页”为单位来读写数据。当需要读一条记录的时候，会将记录所在的页整体（InnoDB 中数据页的默认大小是 16KB）从磁盘读出来放至内存。连续记录大概率会在同一个数据页内，而在内存中寻找下一条记录的操作只是：一次指针寻址 + 一次计算，这在 CPU 的操作成本微乎其微。当连续记录分别在两个数据页的页尾和页头时，操作复杂度较高。</p><h3 id="更新过程的索引区别"><a href="#更新过程的索引区别" class="headerlink" title="更新过程的索引区别"></a>更新过程的索引区别</h3><h4 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h4><p>当更新一个数据页时，若该数据页还没有在内存中，在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入该数据页。直到需要查询该数据页的时，才将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p><ul><li><p>change buffer 使用的是 buffer pool 里的内存，因此不能无限增大。change buffer 可以通过参数 innodb_change_buffer_max_size 来动态地设置大小，如：当参数设置为 50，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。</p></li><li><p>change buffer 优点：</p><ol><li>减少读磁盘（随机 IO 的访问），提升 SQL 语句的执行速度</li><li>避免占用内存，提高内存利用率（数据读入内存会占用内存为 RDBMS 开辟的 buffer pool）</li></ol></li><li><p>使用场景</p><p>一个数据页做 merge 之前，change buffer 记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。因此，对于<strong>写多读少</strong>的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。</p><p>反之，在<strong>写少读多</strong>的场景下，每次更新数据都先记录在 change buffer，之后很快就要读数据页并触发 merge，既不能减少随机 IO 访问，又增加了 change buffer 维护成本</p></li></ul><h4 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h4><p>将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。</p><p>触发 merge 的条件：</p><ol><li>访问数据页时，change buffer 中有与这个页有关的操作</li><li>系统的后台线程定期 merge</li><li>在数据库正常关闭（shutdown）的过程中执行 merge 操作。</li></ol><h4 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h4><ul><li><p>对于唯一索引：</p><p>无法使用 change buffer。</p><p>对于唯一索引，所有的更新操作都要先判断这个操作是否违反唯一性约束（即更新后的结果是否唯一），而该过程需要将数据页读入内存，故直接在内存中修改更快，不需要 change buffer。</p></li><li><p>对于普通索引：</p><p>事实上，只有普通索引能用 change buffer。</p><ul><li>记录要更新的目标页在内存中，找到目标记录进行更新</li><li>记录要更新的目标页不在内存中，将更新记录在 change buffer，语句执行即结束</li></ul></li></ul><h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><p><strong>change buffer 是</strong>可以持久化<strong>的数据，在内存中有拷贝，也会被写入到磁盘上。</strong></p><ol><li><p>change buffer 有一部分在内存有一部分在 ibdata。 merge 操作会把 change buffer 里相应的数据持久化到 ibdata；</p></li><li><p>redo log 里记录了数据页的修改以及 change buffer 新写入的信息。</p><p>如果掉电，持久化的 change buffer 数据已经 merge，不用恢复。主要分析没有持久化的数据情况又分为以下几种：</p><ol><li><p>change buffer 写入，redo log 虽然做了 fsync 但未 commit，binlog 未 fsync 到磁盘，这部分数据丢失；</p></li><li><p>change buffer 写入，redo log 写入但没有 commit，binlog 已经 fsync 到磁盘，先从 binlog 恢复 redo log，再从 redo log 恢复 change buffer；</p></li><li><p>change buffer 写入，redo log 和 binlog 都已经 fsync，那么直接从 redo log 里恢复。</p></li></ol><p>注： fsync，同步内存中所有已修改的文件数据到磁盘/储存设备。</p></li></ol><h3 id="索引选择"><a href="#索引选择" class="headerlink" title="索引选择"></a>索引选择</h3><p>以上可见，类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。<strong>建议尽量选择普通索引 + change buffer。</strong></p><ul><li><p>实用场景</p><p>在使用机械硬盘时，change buffer 的收效非常显著。如果有一个类似“历史数据”的库，并且出于成本考虑用的是机械硬盘，那么应该尽量使用普通索引，并把 change buffer 尽量开大，以确保这个“历史数据”表的数据写入速度。</p></li><li><p>特殊场景</p><p>如果所有更新后面，往往都伴随着对该数据的查询，那么建议关闭 change buffer。</p></li></ul><h3 id="change-buffer-和-redo-log"><a href="#change-buffer-和-redo-log" class="headerlink" title="change buffer 和 redo log"></a>change buffer 和 redo log</h3><h4 id="两者关系"><a href="#两者关系" class="headerlink" title="两者关系"></a>两者关系</h4><p>假设更新过程有两个待更新数据页 A、B，A 在内存中，B 在磁盘中。该过程涉及四个部分：内存（buffer pool）、redo log、 数据表空间、系统表空间：</p><ol><li>对于在内存中的 A，直接更新内存中的数据表；（写一次内存）</li><li>对于不在内存中的 B，在内存的 change buffer 区域，记录下更新信息；（写一次内存）</li><li>上述两个动作都记入 redo log 中。（写一次磁盘，顺序写）</li></ol><p>若更新后，随即读取这些数据：</p><ol><li>对于在内存中的 A，直接从内存读取数据；</li><li>对于不在内存中的 B，将 B 从磁盘读入内存中，然后应用 change buffer 操作日志，生成正确的版本再返回。</li></ol><h4 id="提升性能上的区别"><a href="#提升性能上的区别" class="headerlink" title="提升性能上的区别"></a>提升性能上的区别</h4><ul><li>redo log 主要节省的是<strong>随机写</strong>磁盘的 IO 消耗（转成顺序写）；</li><li>change buffer 主要节省的则是<strong>随机读</strong>磁盘的 IO 消耗。</li></ul><h2 id="MySQL-索引选择异常和处理"><a href="#MySQL-索引选择异常和处理" class="headerlink" title="MySQL 索引选择异常和处理"></a>MySQL 索引选择异常和处理</h2><h3 id="排查方法"><a href="#排查方法" class="headerlink" title="排查方法"></a>排查方法</h3><ol><li>explain 命令查看语句的执行情况；</li><li>查看优化器选择的索引是否符合预期；</li><li><p>若 key 选择不符合预期，通过慢查询日志（slow log）查看具体的执行情况；</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> long_query_time=<span class="number">0</span>;</span><br><span class="line">&lt;查询语句&gt;;</span><br></pre></td></tr></table></figure></li><li><p>查看扫描行数，是否进行全表扫描/索引扫描。</p></li></ol><h3 id="优化器逻辑"><a href="#优化器逻辑" class="headerlink" title="优化器逻辑"></a>优化器逻辑</h3><p>优化器通过选择索引，找到最优的执行方案，并用最小的代价去执行语句。优化器主要会结合以下因素进行综合判断：</p><ol><li><a href="#扫描行数">扫描行数</a></li><li>是否使用临时表</li><li>是否排序</li></ol><h3 id="扫描行数"><a href="#扫描行数" class="headerlink" title="扫描行数"></a>扫描行数</h3><p>扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的 CPU 资源越少。</p><h4 id="索引统计"><a href="#索引统计" class="headerlink" title="索引统计"></a>索引统计</h4><ul><li><p>统计信息</p><p>索引的“区分度”，一个索引上不同的值越多，这个索引的区分度就越好。</p></li><li><p>索引基数</p><p>一个索引上不同的值的个数称为“基数”（cardinality），显然，基数越大，索引的区分度越好。查看一个索引的基数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> &lt;表名&gt;;</span><br></pre></td></tr></table></figure><p>但这个统计结果并不一定准确。</p></li><li><p>MySQL 获取索引基数</p><p>MySQL 通过<strong>采样统计</strong>得到索引的基数。因为取整张表逐行统计虽然结果精确，但代价太高。</p><p>采样统计的方法：</p><ol><li>InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值；</li><li>对 N 个数据页的不同值计算平均值；</li><li>用所得的 N 页平均值，乘以索引的页面数，得到该索引基数；</li><li>此后，当变更的数据行数超过 1/M 的时候，会自动触发重新做一次索引统计。</li></ol></li><li><p>存储索引统计的两种方式</p><p>通过设置参数 innodb_stats_persistent 的值来选择：</p><ul><li>设置为 on 表示：统计信息会持久化存储。此时，默认的 N 是 20，M 是 10；</li><li>设置为 off 表示：统计信息只存储在内存中。此时，默认的 N 是 8，M 是 16。</li></ul><p>显然，不管 N 取 20 还是 8，采样统计的基数都很容易不准。</p></li></ul><h4 id="优化器对扫描行数的判断"><a href="#优化器对扫描行数的判断" class="headerlink" title="优化器对扫描行数的判断"></a>优化器对扫描行数的判断</h4><ol><li>执行 SQL 前，根据<a href="#统计信息">统计信息</a>来估算扫描记录数；</li><li>针对“<strong>直接主键扫描</strong>”和“<strong>索引扫描+主键回表</strong>”两种方案，分别估算扫描行数，选择代价更小的方案。</li></ol><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="扫描行数的估计值不准确的情况"><a href="#扫描行数的估计值不准确的情况" class="headerlink" title="扫描行数的估计值不准确的情况"></a>扫描行数的估计值不准确的情况</h4><ol><li><p>统计信息的修正</p><p>explain 的结果预估的 rows 值跟实际情况差距比较大的情况下，可使用命令修正统计信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">analyze</span> <span class="keyword">table</span> &lt;表名&gt;;</span><br></pre></td></tr></table></figure><p>再执行则可以正确使用索引。</p></li></ol><h4 id="选错索引的情况"><a href="#选错索引的情况" class="headerlink" title="选错索引的情况"></a>选错索引的情况</h4><ol><li><p>采用 force index 强行选择一个索引</p><p>MySQL 会根据词法解析的结果分析出可能可以使用的索引作为候选项，然后在候选列表中依次判断每个索引需要扫描多少行。如果 force index 指定的索引在候选索引列表中，就直接选择这个索引，不再评估其他索引的执行代价。</p><p>缺点：</p><ol><li>写法不佳；</li><li>修改了索引名，语句要进行相应改动；</li><li>迁库后可能存在兼容性问题。</li></ol></li><li><p>修改语句，引导 MySQL 使用我们期望的索引</p><p>在语义逻辑不变的情况下，修改 SQL 语句，引导其用上我们期待的索引。</p><p>如：order by b limit 1 和 order by b,a limit 1，都返回按 b 排序第一行，但后者会使用上 a 的索引。</p></li><li><p>新建更合适的索引供优化器做选择，或删掉误用的索引</p><ul><li>新建更合适的索引的情况比较少见。尤其经过 DBA 索引优化过的库，找到更合适的索引一般比较难。</li><li>根据实际情况，若检查发现优化器错误选择的索引其实根本没有必要存在，应予以删除。</li></ul></li></ol><h2 id="字符串字段加索引"><a href="#字符串字段加索引" class="headerlink" title="字符串字段加索引"></a>字符串字段加索引</h2><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><p>使用合适长度的前缀索引，就可以做到既节省空间（减少每个索引长度），又不用额外增加太多的查询成本（回主键索引取数据的次数）。</p><h4 id="寻找合适的前缀索引"><a href="#寻找合适的前缀索引" class="headerlink" title="寻找合适的前缀索引"></a>寻找合适的前缀索引</h4><ol><li>核心：索引区分度越高越好，那么重复的键值越少。</li><li>首先，统计索引上有多少个不同的值 N；</li><li>然后，依次截取不同长度的前缀串，查看各前缀串不同的值 M；</li><li>最后：选取区分效率最高（M 趋于 N）的截取长度，取该截取长度作前缀索引。</li></ol><h4 id="前缀索引对覆盖索引的影响"><a href="#前缀索引对覆盖索引的影响" class="headerlink" title="前缀索引对覆盖索引的影响"></a>前缀索引对覆盖索引的影响</h4><p>以如下方 SQL 为例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, email <span class="keyword">from</span> <span class="keyword">User</span> <span class="keyword">where</span> email=<span class="string">'******@xxx.com'</span>;</span><br></pre></td></tr></table></figure><ul><li>若使用对 email 的完整索引，可以了利用覆盖索引，查到结果直接返回，不需要回表再查一遍；</li><li>若使用对 email 的前缀索引，即使是 email(14)，在查到结果后，为获取完整信息，都必须回表查找。因为 RDBMS 并不确定前缀索引的定义是否截断了完整信息，此时便用不上覆盖索引对查询性能的优化。</li></ul><h3 id="其他索引方式"><a href="#其他索引方式" class="headerlink" title="其他索引方式"></a>其他索引方式</h3><h4 id="倒序存储"><a href="#倒序存储" class="headerlink" title="倒序存储"></a>倒序存储</h4><ul><li><p>方法</p><p>先对字符串数据进行倒序存储，再创建前缀索引。</p></li><li><p>优点</p><p>绕过字符串本身前缀的区分度不够的问题。如：身份证号码。</p></li><li><p>缺点</p><ul><li>不支持范围扫描；</li><li>从数据库读写数据时，需要额外进行翻转操作。</li></ul></li></ul><h4 id="hash-字段存储"><a href="#hash-字段存储" class="headerlink" title="hash 字段存储"></a>hash 字段存储</h4><ul><li><p>方法</p><p>在表上再创建一个整数字段，保存字符串的校验码，同时在这个字段上创建索引。MySQL 常用校验码 hash 函数：crc32()、crc64()。</p></li><li><p>优点</p><p>控制索引的长度为 4 个字节。</p></li><li><p>缺点</p><ul><li>不支持范围扫描；</li><li>校验码可能存在冲突， 查询语句 where 部分要额外判断 id_card 的值是否精确相同。</li></ul></li></ul><h4 id="倒序存储与-hash-字段存储异同"><a href="#倒序存储与-hash-字段存储异同" class="headerlink" title="倒序存储与 hash 字段存储异同"></a>倒序存储与 hash 字段存储异同</h4><ul><li><p>同</p><p>都不支持范围查询。</p></li><li><p>异</p><ol><li><p>额外占用空间：≈</p><p>倒序存储方式在主键索引上，不会消耗额外的存储空间；hash 字段方法需要增加一个字段。实际上，倒序存储使用的前缀长度为了区分度往往不止 4 个字节，二者总体的空间消耗可能相差无几。</p></li><li><p>CPU 消耗：倒序小</p><p>倒序方式每次读写数据时，都需要额外调用一次 reverse 函数；hash 字段的方式需要额外调用一次 hash 函数。从函数的计算复杂度来看，二者 CPU 消耗：reverse 函数 &lt; hash 函数。</p></li><li><p>查询效率：hash 高</p><p>倒序存储 + 前缀索引的方式，可能会增加扫描行数；hash 字段方式的查询性能相对更稳定一些，虽然 hash 有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近 1。</p></li></ol></li></ul><h3 id="索引方式选择"><a href="#索引方式选择" class="headerlink" title="索引方式选择"></a>索引方式选择</h3><p>结合业务需求和设备条件，进行合理选择。</p><h2 id="MySQL-突然变慢（数据库-flush）"><a href="#MySQL-突然变慢（数据库-flush）" class="headerlink" title="MySQL 突然变慢（数据库 flush）"></a>MySQL 突然变慢（数据库 flush）</h2><h3 id="脏页"><a href="#脏页" class="headerlink" title="脏页"></a>脏页</h3><p>当内存数据页跟磁盘数据页内容不一致时，称该内存页为“脏页”。将内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。</p><h3 id="引发-flush-的场景"><a href="#引发-flush-的场景" class="headerlink" title="引发 flush 的场景"></a>引发 flush 的场景</h3><h4 id="InnoDB-的-redo-log-写满"><a href="#InnoDB-的-redo-log-写满" class="headerlink" title="InnoDB 的 redo log 写满"></a>InnoDB 的 redo log 写满</h4><ul><li><p>场景描述</p><p>此时系统会<strong>停止所有更新操作</strong>，把 checkpoint 往前推进，推进区间的日志所对应的脏页全都 flush 到磁盘上，为 redo log 留出继续写的空间。</p></li><li><p>性能影响</p><p>此时整个系统不能再接受更新，所有更新操作将被阻塞，应该尽力避免。</p></li></ul><h4 id="系统内存不足"><a href="#系统内存不足" class="headerlink" title="系统内存不足"></a>系统内存不足</h4><ul><li><p>场景描述</p><p>当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给新的数据页使用。如果淘汰的是“脏页”，就要先将脏页 flush 到磁盘。</p><p>“刷脏页一定会写盘”的机制保证了每个数据页只会有两种状态：</p><ol><li>内存里存在，内存里就肯定是正确的结果，直接返回；</li><li>内存里没有，就可以肯定数据文件上是正确的结果，读入内存后返回。</li></ol><p>相比“从内存直接淘汰，等到下次请求从磁盘读入数据页，再拿 redo log 应用”的做法，效率更高。</p></li><li><p>性能影响</p><p>InnoDB 用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态：</p><ol><li>未使用的；</li><li>使用了的“干净页”；</li><li>使用了的“脏页”。</li></ol><p>而 InnoDB 的策略是尽量使用内存，因此对于长时间运行的库来说，未被使用的页面很少。当待读入的数据页在内存中不存在，而内存又不足时，缓冲池中将淘汰最久未使用数据页：</p><ul><li>若淘汰页是“干净页”，则直接释放用来复用；</li><li>若淘汰页是“脏页”，则要先 flush 到磁盘，变成干净页后才能释放复用。</li></ul></li></ul><h4 id="MySQL-认为系统“空闲”的时候进行-flush"><a href="#MySQL-认为系统“空闲”的时候进行-flush" class="headerlink" title="MySQL 认为系统“空闲”的时候进行 flush"></a>MySQL 认为系统“空闲”的时候进行 flush</h4><ul><li><p>场景描述</p><p>可以灵活设置 MySQL 定期 flush 的时间，以提高空闲或繁忙时 MySQL 刷“脏页”的效率。</p></li><li><p>性能影响</p><p>MySQL 空闲时的操作，对系统压力不大。</p></li></ul><h4 id="MySQL-正常关闭"><a href="#MySQL-正常关闭" class="headerlink" title="MySQL 正常关闭"></a>MySQL 正常关闭</h4><ul><li><p>场景描述</p><p>MySQL 需要正常关闭时，会把内存的脏页都 flush 到磁盘上，这样下次 MySQL 启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</p></li><li><p>性能影响</p><p>MySQL 关闭前的操作，对性能无影响。</p></li></ul><h4 id="性能影响总结"><a href="#性能影响总结" class="headerlink" title="性能影响总结"></a>性能影响总结</h4><p>根据上述的第一、二个 flush 场景，对应易引发两种明显影响性能情况：</p><ol><li>日志写满，更新全部堵住，写性能跌为 0。这种情况对敏感业务来说，是不能接受的；</li><li>一次查询要淘汰的“脏页”个数太多，导致查询响应时间明显变长。</li></ol><p>因此，InnoDB 需要控制脏页比例的机制，以避免上述这两种情况。</p><h3 id="InnoDB-控制脏页比例的机制"><a href="#InnoDB-控制脏页比例的机制" class="headerlink" title="InnoDB 控制脏页比例的机制"></a>InnoDB 控制脏页比例的机制</h3><ol><li><p>正确地设置 innodb_io_capacity 参数</p><p>正确地设置 innodb_io_capacity 参数能够告知 InnoDB 所在主机的 IO 能力，在需要全力刷脏页的时候尽最快的速度。</p><p>测试磁盘随机读写的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest</span><br></pre></td></tr></table></figure><p>innodb_io_capacity 的设置不当可能导致较好的硬件设备也产生脏页累计（刷脏页的速度比脏页生成还慢），影响查询和更新性能。</p></li><li><p>控制 redo log 写盘速度</p><p>参数 innodb_max_dirty_pages_pct 是脏页比例上限（默认值是 75%），InnoDB 会根据当前的脏页比例 M，算出一个范围在 0 到 100 之间的数字，计算公式记为 $F_1(N)$。</p><p>InnoDB 每次写入的日志都有一个序号，根据当前写入的序号跟 checkpoint 对应的序号之间的差值 N，算出一个范围在 0 到 100 之间的数字，计算公式记为 $F_2(N)$。$F_2(N)$ 算法比较复杂，其特点为：N 越大，$F_2(N)$ 的值越大。</p><p>根据上述算得的 $F_1(N)$ 和 $F_2(N)$ 两个值，取 R = max{$F_1(N)$, $F_2(N)$}，之后引擎就按照 v = innodb_io_capacity × R% 来控制刷脏页的速度。</p></li><li><p>控制脏页比例</p><p>平时应多关注脏页比例，不要让它经常接近 75%。</p><p>查看脏页比例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看 Innodb_buffer_pool_pages_dirty</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @a <span class="keyword">from</span> global_status <span class="keyword">where</span> VARIABLE_NAME = <span class="string">'Innodb_buffer_pool_pages_dirty'</span>;</span><br><span class="line"><span class="comment">-- 查看 Innodb_buffer_pool_pages_total</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @b <span class="keyword">from</span> global_status <span class="keyword">where</span> VARIABLE_NAME = <span class="string">'Innodb_buffer_pool_pages_total'</span>;</span><br><span class="line"><span class="comment">-- 脏页比例 = Innodb_buffer_pool_pages_dirty / Innodb_buffer_pool_pages_total</span></span><br><span class="line"><span class="keyword">select</span> @a/@b;</span><br></pre></td></tr></table></figure></li></ol><h3 id="MySQL-刷脏页的“连坐”机制"><a href="#MySQL-刷脏页的“连坐”机制" class="headerlink" title="MySQL 刷脏页的“连坐”机制"></a>MySQL 刷脏页的“连坐”机制</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>对于每个数据页，如果跟它相邻的数据页和它一样也是脏页，就会被放到一起 flush，因此，一个脏页的 flush 可能肯能导致相邻脏页的连锁 flush，使查询更慢。</p><h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><p>在 InnoDB 中，通过设置 innodb_flush_neighbors 参数来控制这个行为：</p><ul><li><p>值为 1 时，开启“连坐”机制</p><p>适合用于使用<strong>机械硬盘</strong>的情况。</p><p>机械硬盘的随机 IOPS（Input/Output Operations Per Second，每秒的读写次数） 一般只有几百，“连坐”机制可以减少随机 IO，大幅提高系统性能。</p></li><li><p>值为 0 时，仅刷选中脏页自身</p><p>适合用于使用 IOPS 比较高的设备的情况，比如 SSD。</p><p>该场景下 IOPS 往往不是瓶颈，仅刷选中脏页能够更快地执行完必要的刷脏页操作，减少 SQL 语句响应时间。</p></li></ul><h2 id="数据表删掉一半，但表文件大小不变"><a href="#数据表删掉一半，但表文件大小不变" class="headerlink" title="数据表删掉一半，但表文件大小不变"></a>数据表删掉一半，但表文件大小不变</h2><p>skip。</p><h2 id="COUNT-慢"><a href="#COUNT-慢" class="headerlink" title="COUNT(*) 慢"></a>COUNT(*) 慢</h2><h3 id="count-的实现方式"><a href="#count-的实现方式" class="headerlink" title="count(*) 的实现方式"></a>count(*) 的实现方式</h3><p>在没有使用 where 时：</p><ul><li>MyISAM 引擎：将表的总行数存在磁盘上，执行 count(*) 时会直接返回</li><li>InnoDB 引擎：把数据逐行读出，然后累积计数。</li></ul><p>此时，InnoDB 使用 COUNT(*) 慢于 MyISAM。而使用 where 时，二者都需要逐行读出数据并进行条件过滤。</p><h3 id="InnoDB-不存储表行数的原因"><a href="#InnoDB-不存储表行数的原因" class="headerlink" title="InnoDB 不存储表行数的原因"></a>InnoDB 不存储表行数的原因</h3><p>即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的。</p><h3 id="TABLE-ROWS"><a href="#TABLE-ROWS" class="headerlink" title="TABLE_ROWS"></a>TABLE_ROWS</h3><p>show table status 命令中的 TABLE_ROWS 是根据<a href="#索引统计">采样估计</a>得来的，误差可能达到 40% 到 50%，并不准确，所以不能直接使用。</p><h3 id="快速获取记录总数的方案"><a href="#快速获取记录总数的方案" class="headerlink" title="快速获取记录总数的方案"></a>快速获取记录总数的方案</h3><h4 id="用缓存系统保存计数"><a href="#用缓存系统保存计数" class="headerlink" title="用缓存系统保存计数"></a>用缓存系统保存计数</h4><p>用一个 Redis 服务来保存这个表的总行数。这个表每被插入一行 Redis 计数就加 1，每被删除一行 Redis 计数就减 1。读写效率快，但要注意以下两个问题：</p><ul><li><p>丢失更新</p><p>可能情况：数据库更新了一条数据，Redis 在内存中（未永久化）计数 +1 后，发生了异常重启，+1 操作丢失。</p><p>解决方案：异常重启后，到数据库中单独执行依次 COUNT(*) 再写入 Redis。鉴于异常重启是小概率事件，该操作成本可以接受。</p></li><li><p>逻辑不精确</p><p>可能情况：</p><p>假设有会话 A 和会话 B。A 中的操作有：① Redis 计数 +1;② 插入一行数据。B中的操作有：③ 读 Redis 计数，取最近 100 条记录。当执行顺序为 ①③② 或 ①③② 时，操作是数据不一致的。</p><p>在并发系统里面，我们无法精确控制不同线程的执行时刻，因为此可能存在以上数据不一致的操作序列。所以，即使 Redis 正常工作，这个计数值还是逻辑上不精确的。</p><p>解决方案：无。</p></li></ul><h4 id="在数据库保存计数"><a href="#在数据库保存计数" class="headerlink" title="在数据库保存计数"></a>在数据库保存计数</h4><p>将计数直接放到数据库里单独的一张计数表 C 中。</p><ul><li><p>丢失更新</p><p>由于 InnoDB 支持崩溃恢复，所以可以解决丢失更新的问题。</p></li><li><p>逻辑不精确</p><p>利用事务特性，实现一致性读。</p></li></ul><h3 id="不同-count-用法"><a href="#不同-count-用法" class="headerlink" title="不同 count 用法"></a>不同 count 用法</h3><h4 id="count-的语义"><a href="#count-的语义" class="headerlink" title="count() 的语义"></a>count() 的语义</h4><p>count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值。故</p><ul><li>count(*)、count(主键 id) 和 count(1)，表示返回满足条件的结果集的总行数；</li><li>count(字段)，表示返回字段不为 NULL 的结果集的总行数</li></ul><h4 id="性能差异"><a href="#性能差异" class="headerlink" title="性能差异"></a>性能差异</h4><p>原则：</p><ol><li>server 层要什么就给什么；</li><li>InnoDB 只给必要的值；</li><li>优化器只优化了 count(*) 的语义为“取行数”，其他“显而易见”的优化并没有做。</li></ol><p>各用法差别如下：</p><ul><li><p>count(主键 id)：取 id。</p><p>InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断不可能为空（主键不能为空），按行累加。</p></li><li><p>count(1)：不取值，只置“1”。</p><p>InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断不可能为空，按行累加。</p><p>与 count(主键 id) 相比，count(1) 执行得要比 count(主键 id) 快。因为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作。</p></li><li><p>count(字段)：取值，若类型定义为 not null 直接累加，否则逐行判段不为 null 才累加。</p><ul><li><p>如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不可能为 null，按行累加；</p></li><li><p>如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。即第一条原则，server 层要什么字段，InnoDB 就返回什么字段。</p></li></ul></li><li><p>count(*)：不取值，直接累加。</p><p>count(*) 不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。</p></li></ul><p>按效率排序，<strong>count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(*)</strong>，因此建议<strong>尽量使用 count(*)</strong>。</p><h2 id="order-by-工作原理"><a href="#order-by-工作原理" class="headerlink" title="order by 工作原理"></a>order by 工作原理</h2><h3 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h3><h4 id="全字段排序执行流程"><a href="#全字段排序执行流程" class="headerlink" title="全字段排序执行流程"></a>全字段排序执行流程</h4><p>以下方 SQL 为例，其中，id 是主键，a 是普通索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a, b, c <span class="keyword">from</span> T <span class="keyword">where</span> a=<span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> b <span class="keyword">limit</span> N;</span><br></pre></td></tr></table></figure><ol><li>初始化 sort_buffer，确定放入 a、b、c 这三个字段；</li><li>从索引 a 找到第一个满足 a=1 条件的主键 id；</li><li>到主键 id 索引取出整行，取 a、b、c 三个字段的值，存入 sort_buffer 中；</li><li>从索引 a 取下一个记录的主键 id；</li><li>重复步骤 3、4 直到 a 的值不满足查询条件为止，对应的主键 id；</li><li>对 sort_buffer 中的数据按照字段 b 做快速排序；</li><li>按照排序结果取前 N 行返回给客户端。</li></ol><h4 id="sort-buffer"><a href="#sort-buffer" class="headerlink" title="sort_buffer"></a>sort_buffer</h4><p>MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer。sort_buffer 中做快速排序，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数 sort_buffer_size。</p><ul><li><p>sort_buffer_size</p><p>sort_buffer_size 是 MySQL 为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。</p></li></ul><p>查看一个排序语句是否使用了临时文件的方法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 打开optimizer_trace，只对本线程有效 */</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace=<span class="string">'enabled=on'</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* @a保存Innodb_rows_read的初始值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @a <span class="keyword">from</span>  performance_schema.session_status <span class="keyword">where</span> variable_name = <span class="string">'Innodb_rows_read'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行排序语句 */</span></span><br><span class="line"><span class="keyword">select</span> a, b, c <span class="keyword">from</span> T <span class="keyword">where</span> a=<span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> b <span class="keyword">limit</span> N;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查看 OPTIMIZER_TRACE 输出 */</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`information_schema`</span>.<span class="string">`OPTIMIZER_TRACE`</span>\G</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @b保存Innodb_rows_read的当前值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @b <span class="keyword">from</span> performance_schema.session_status <span class="keyword">where</span> variable_name = <span class="string">'Innodb_rows_read'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算Innodb_rows_read差值 */</span></span><br><span class="line"><span class="keyword">select</span> @b-@a;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 通过查看 OPTIMIZER_TRACE 的结果中的 number_of_tmp_files，可以判断是否使用了临时文件</span></span><br></pre></td></tr></table></figure><ul><li><p>number_of_tmp_files</p><p>number_of_tmp_files = N（N &gt; 0），表示排序过程中使用的临时文件数为 N。外部排序一般使用归并排序算法，将待排数据分成 N 份做 N 路归并排序。sort_buffer_size 越小，需要分成的份数越多，number_of_tmp_files 的值就越大。</p><p>number_of_tmp_files = 0，表示 sort_buffer_size 大于待排数据的大小，排序可以直接在内存中完成。</p></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>全字段排序只需读取一遍原表数据，剩下的操作都是在 sort_buffer 和临时文件中执行的。在查询需要返回很多个字段时，sort_buffer 中要放的字段数太多，会导致内存里能够同时放下的行数会很少，需要分成很多个临时文件，排序的性能会很差。</p><h3 id="rowid-排序"><a href="#rowid-排序" class="headerlink" title="rowid 排序"></a>rowid 排序</h3><h4 id="max-length-for-sort-data"><a href="#max-length-for-sort-data" class="headerlink" title="max_length_for_sort_data"></a>max_length_for_sort_data</h4><p>max_length_for_sort_data，是 MySQL 中专门控制用于排序的行数据的长度的一个参数。若单行的长度超过这个值，MySQL 就认为单行太大，会从全字段排序算法切换成rowid 排序算法。</p><p>采用 rowid 排序时，放入 sort_buffer 的字段只有<strong>需要排序的列</strong>和<strong>主键 id</strong>。</p><h4 id="rowid-排序执行流程"><a href="#rowid-排序执行流程" class="headerlink" title="rowid 排序执行流程"></a>rowid 排序执行流程</h4><p>以下方 SQL 为例，其中，id 是主键，a 是普通索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a, b, c <span class="keyword">from</span> T <span class="keyword">where</span> a=<span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> b <span class="keyword">limit</span> N;</span><br></pre></td></tr></table></figure><ol><li>初始化 sort_buffer，确定放入两个字段，即 b 和 id；</li><li>从索引 a 找到第一个满足 a=1 条件的主键 id；</li><li>到主键 id 索引取出整行，取 b、id 这两个字段，存入 sort_buffer 中；</li><li>从索引 a 取下一个记录的主键 id；</li><li>重复步骤 3、4 直到不满足 a=1 条件为止；</li><li>对 sort_buffer 中的数据按照字段 b 进行排序；</li><li>遍历排序结果，取前 N 行，并按照 id 的值回到原表中取出 a、b 和 c 三个字段返回给客户端。</li></ol><h4 id="与全字段排序区别"><a href="#与全字段排序区别" class="headerlink" title="与全字段排序区别"></a>与全字段排序区别</h4><p>rowid 排序相比全自担排序，在取最后结果集时多出一步：访问主键索引，以取出其他字段数据。</p><h3 id="MySQL-排序算法的选择思路"><a href="#MySQL-排序算法的选择思路" class="headerlink" title="MySQL 排序算法的选择思路"></a>MySQL 排序算法的选择思路</h3><p>MySQL 的一个设计思想：如果内存够，就要多利用内存，尽量减少磁盘访问。故对于 InnoDB 表来说，rowid 排序会要求回表多造成磁盘读，因此不会被优先选择。</p><h3 id="对排序算法的优化"><a href="#对排序算法的优化" class="headerlink" title="对排序算法的优化"></a>对排序算法的优化</h3><p>并非所有的 order by 语句都需要排序操作的，若从表中取出的数据行天然有序，则无需排序。</p><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>以下方 SQL 为例，其中，id 是主键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a, b, c <span class="keyword">from</span> T <span class="keyword">where</span> a=<span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> b <span class="keyword">limit</span> N;</span><br></pre></td></tr></table></figure><p>创建 (a, b) 的联合索引，由于 (a, b) 这个0<strong>联合索引本身有序</strong>，那么查询过程中，只要 a=1，b 的值一定有序。</p><p>此时，排序执行过程如下：</p><ol><li>从索引 (a, b) 找到第一个满足 a=1 条件的主键 id；</li><li>到主键 id 索引取出整行，取 a、b、c 三个字段的值，作为结果集的一部分直接返回；</li><li>从索引 (a, b) 取下一个记录主键 id；</li><li>重复步骤 2、3，直到查到第 N 条记录，或者是不满足 a=1 条件时循环结束。</li></ol><p>该查询过程不需要临时表，也不需要排序。</p><h4 id="联合索引-覆盖索引"><a href="#联合索引-覆盖索引" class="headerlink" title="联合索引 + 覆盖索引"></a>联合索引 + 覆盖索引</h4><p>以下方 SQL 为例，其中，id 是主键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a, b, c <span class="keyword">from</span> T <span class="keyword">where</span> a=<span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> b <span class="keyword">limit</span> N;</span><br></pre></td></tr></table></figure><p>创建 (a, b， c) 的联合索引，由于 (a, b， c) 这个联合索引本身有序，且索引树上已具备查询所需的所有字段。</p><p>此时，排序执行过程如下：</p><ol><li>从索引 (a, b， c) 找到第一个满足 a=1 条件的记录，取出其中的 a, b， c 这三个字段的值，作为结果集的一部分直接返回；</li><li>从索引 (a, b， c) 取下一个记录，同样取出这三个字段的值，作为结果集的一部分直接返回；</li><li>重复执行步骤 2，直到查到第 N 条记录，或者是不满足 a=1 条件时循环结束。</li></ol><p>该查询过程不需要临时表，不需要排序，也不需要回主表取出其它字段数据，直接从索引 (a, b， c) 上取出数据行作结果集。</p><p>优点：</p><ul><li>联合索引：本身有序。</li><li>覆盖索引：索引上的信息足够满足查询请求，则不需要再回到主键索引上去取数据。</li></ul><p>缺点：</p><ul><li>索引维护有代价，使用需适当。</li></ul><h2 id="随机消息的显示"><a href="#随机消息的显示" class="headerlink" title="随机消息的显示"></a>随机消息的显示</h2><p>skip。</p><h2 id="SQL-语句逻辑相同，而性能差异巨大"><a href="#SQL-语句逻辑相同，而性能差异巨大" class="headerlink" title="SQL 语句逻辑相同，而性能差异巨大"></a>SQL 语句逻辑相同，而性能差异巨大</h2><h3 id="条件字段函数操作的影响"><a href="#条件字段函数操作的影响" class="headerlink" title="条件字段函数操作的影响"></a>条件字段函数操作的影响</h3><h4 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h4><p>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h3 id="隐式类型转换的影响"><a href="#隐式类型转换的影响" class="headerlink" title="隐式类型转换的影响"></a>隐式类型转换的影响</h3><h4 id="隐式类型转换的规则"><a href="#隐式类型转换的规则" class="headerlink" title="隐式类型转换的规则"></a>隐式类型转换的规则</h4><ul><li><p>判断方法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> “<span class="number">10</span>” &gt; <span class="number">9</span>；</span><br></pre></td></tr></table></figure><ul><li>若结果为 1，表明做的是数字比较，规则为“将字符串转成数字”</li><li>若结果为 0，表明做的是字符串比较，规则为“将数字转成字符串”</li><li>通过验证得知，MySQL 的转换规则为“字符串转换成数字”</li></ul></li></ul><h4 id="数据类型转换导致全索引扫描的原因"><a href="#数据类型转换导致全索引扫描的原因" class="headerlink" title="数据类型转换导致全索引扫描的原因"></a>数据类型转换导致全索引扫描的原因</h4><p>隐式数据类型转换，本质上相当于对索引字段使用了数据类型转换函数，影响与<a href="#条件字段函数操作的影响">条件字段函数操作的影响</a>相同。</p><h3 id="隐式字符编码转换"><a href="#隐式字符编码转换" class="headerlink" title="隐式字符编码转换"></a>隐式字符编码转换</h3><h4 id="自动类型转换原则"><a href="#自动类型转换原则" class="headerlink" title="自动类型转换原则"></a>自动类型转换原则</h4><p>在程序设计语言里面，做自动类型转换的时候，为了避免数据在转换过程中由于截断导致数据错误，也都是“按数据长度增加的方向”进行转换的。</p><h4 id="隐式字符编码转换导致全索引扫描的原因"><a href="#隐式字符编码转换导致全索引扫描的原因" class="headerlink" title="隐式字符编码转换导致全索引扫描的原因"></a>隐式字符编码转换导致全索引扫描的原因</h4><p>隐式字符编码转换，相当于对索引字段使用了字符编码转换函数，影响与<a href="#条件字段函数操作的影响">条件字段函数操作的影响</a>相同。</p><h3 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h3><ol><li>修改字段的类型/字符集，避免类型/字符集转换；</li><li>修改 SQL 语句，将转换函数加在输入参数（右值）上，避免破坏字段有序性;</li><li><p>SQL 语句中，尽量不要在字段上做任何操作，以免破坏索引。避免类似写法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> T <span class="keyword">WHERE</span> <span class="keyword">id</span> + <span class="number">1</span> = <span class="number">1000</span>;</span><br><span class="line"><span class="comment">-- 该 where 条件的写法，将导致无法使用 id 的索引查找，MySQL 也不会主动重写这个语句</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> T <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1000</span> - <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 正确做法</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="只查一行，执行慢"><a href="#只查一行，执行慢" class="headerlink" title="只查一行，执行慢"></a>只查一行，执行慢</h2><h3 id="查询长时间不返回"><a href="#查询长时间不返回" class="headerlink" title="查询长时间不返回"></a>查询长时间不返回</h3><p>执行查询语句后，长时间等待没有返回结果，大概率是表被锁住了，可执行 show processlist 命令，查看当前语句处于什么状态。</p><h4 id="等-MDL-锁"><a href="#等-MDL-锁" class="headerlink" title="等 MDL 锁"></a>等 MDL 锁</h4><ul><li><p>现象</p><p>若执行 show processlist 命令， State 为 “Waiting for table metadata lock”，表示有一个线程正在表上请求或者持有 MDL 写锁，把查询语句堵住了。</p></li><li><p>处理方法</p><p>找到持有 MDL 锁的进程，将其 kill 掉</p><ol><li>MySQL 启动时设置 performance_schema=on（相比于设置为 off 会有 10% 左右的性能损失）</li><li><p>查询 sys.schema_table_lock_waits 这张表，找到阻塞进程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> blocking_id <span class="keyword">FROM</span> sys.schema_table_lock_waits;</span><br></pre></td></tr></table></figure></li><li><p>kill 阻塞进程</p></li></ol></li></ul><h4 id="等-flush"><a href="#等-flush" class="headerlink" title="等 flush"></a>等 flush</h4><ul><li>MySQL 里面对表做 flush 操作的用法:<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用法一：指定表 t 的话，表示只关闭表 t</span></span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">tables</span> t <span class="keyword">with</span> <span class="keyword">read</span> <span class="keyword">lock</span>;</span><br><span class="line"><span class="comment">-- 用法二：没有指定具体的表名，表示关闭 MySQL 里所有打开的表</span></span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">tables</span> <span class="keyword">with</span> <span class="keyword">read</span> <span class="keyword">lock</span>;</span><br></pre></td></tr></table></figure></li></ul><p>正常情况下，两种用法执行起来都很快，除非它们被别的线程堵住了。</p><ul><li><p>现象</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.processlist <span class="keyword">where</span> <span class="keyword">id</span>=&lt;pid&gt;;</span><br></pre></td></tr></table></figure><p>线程的状态是 “Waiting for table flush”。</p></li><li><p>处理方法</p><ol><li>show processlist 找到阻塞 flush 线程的线程；</li><li>kill</li></ol></li></ul><h4 id="等行锁"><a href="#等行锁" class="headerlink" title="等行锁"></a>等行锁</h4><ul><li><p>处理方法</p><ol><li><p>通过 sys.innodb_lock_waits 表找谁占着写锁（blocking_pid）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t sys.innodb_lock_waits <span class="keyword">where</span> locked_table=<span class="string">`'test'.'t'`</span>\G</span><br></pre></td></tr></table></figure></li><li><p>KILL <blocking_pid>，直接断开这个连接。</blocking_pid></p><p>连接被断开的时候，会自动回滚这个连接里面正在执行的线程，也就释放了行锁。</p><p>若使用 KILL QUERY <blocking_pid>，只是停止 blocking_pid 线程当前正在执行的语句，而占有行锁的是 update 语句，这个语句已经是之前执行完成了的，此时执行 KILL QUERY 无法让这个事务去掉行锁。</blocking_pid></p></li></ol></li></ul><h3 id="查询慢"><a href="#查询慢" class="headerlink" title="查询慢"></a>查询慢</h3><p>坏查询不一定是慢查询。可能在数据量大起来之后，执行时间才开始快速上涨。</p><h4 id="一致性读"><a href="#一致性读" class="headerlink" title="一致性读"></a>一致性读</h4><p>事务执行过程中，查询某行数据遇锁（其他事物频繁执行更新操作，生产大量 redo log），当锁释放后，为保持一致性读，进行大量计算找到对应数据版本。</p><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><h2 id="只改一行，锁很多"><a href="#只改一行，锁很多" class="headerlink" title="只改一行，锁很多"></a>只改一行，锁很多</h2><h2 id="“饮鸩止渴”-提高性能的方法"><a href="#“饮鸩止渴”-提高性能的方法" class="headerlink" title="“饮鸩止渴” 提高性能的方法"></a>“饮鸩止渴” 提高性能的方法</h2><h2 id="MySQL-保持数据不丢"><a href="#MySQL-保持数据不丢" class="headerlink" title="MySQL 保持数据不丢"></a>MySQL 保持数据不丢</h2><h3 id="binlog-的写入机制"><a href="#binlog-的写入机制" class="headerlink" title="binlog 的写入机制"></a>binlog 的写入机制</h3><h4 id="过程-2"><a href="#过程-2" class="headerlink" title="过程"></a>过程</h4><ol><li>事务执行过程中，先把日志写到 binlog cache</li><li>事务提交的时候，再把 binlog cache 写到 binlog 文件中，并清空 binlog cache</li></ol><h3 id="redo-log-的写入机制"><a href="#redo-log-的写入机制" class="headerlink" title="redo log 的写入机制"></a>redo log 的写入机制</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="WAL-机制主要得益于"><a href="#WAL-机制主要得益于" class="headerlink" title="WAL 机制主要得益于"></a>WAL 机制主要得益于</h4><ol><li>redo log 和 binlog 都是顺序写，磁盘的顺序写比随机写速度要快</li><li>组提交机制，可以大幅度降低磁盘的 IOPS 消耗</li></ol><h4 id="MySQL-出现-IO-性能瓶颈的提升方法"><a href="#MySQL-出现-IO-性能瓶颈的提升方法" class="headerlink" title="MySQL 出现 IO 性能瓶颈的提升方法"></a>MySQL 出现 IO 性能瓶颈的提升方法</h4><ol><li><p>设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，减少 binlog 的写盘次数。</p><p>风险：此法基于“额外的故意等待”实现，可能会增加语句的响应时间，但没有丢失数据的风险。</p></li><li><p>将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000）。</p><p>风险：主机掉电时会丢 binlog 日志。</p></li><li><p>将 innodb_flush_log_at_trx_commit 设置为 2。</p><p>风险：主机掉电的时候会丢数据。</p><p>不建议 innodb_flush_log_at_trx_commit 设置成 0。因为把这个参数设置成 0，表示 redo log 只保存在内存中，这样的话 MySQL 本身异常重启也会丢数据，风险太大。而 redo log 写到文件系统的 page cache 的速度也是很快的，所以将这个参数设置成 2 跟设置成 0 其实性能差不多，但这样做 MySQL 异常重启时就不会丢数据了，相比之下风险会更小。</p></li></ol><h4 id="数据库的-crash-safe"><a href="#数据库的-crash-safe" class="headerlink" title="数据库的 crash-safe"></a>数据库的 crash-safe</h4><ol><li>如果客户端收到事务成功的消息，事务就一定持久化了</li><li>如果客户端收到事务失败（比如主键冲突、回滚等）的消息，事务就一定失败了</li><li>如果客户端收到“执行异常”的消息，应用需要重连后通过查询当前状态来继续后续的逻辑。此时数据库只需要保证内部（数据和日志之间，主库和备库之间）一致就可以了</li></ol><h2 id="MySQL-保持主备一致"><a href="#MySQL-保持主备一致" class="headerlink" title="MySQL 保持主备一致"></a>MySQL 保持主备一致</h2><h3 id="主备切换的基本原理"><a href="#主备切换的基本原理" class="headerlink" title="主备切换的基本原理"></a>主备切换的基本原理</h3><p>假设 A 为主库，B 为备库。</p><ul><li>未切换前，客户端的读写都直接访问 A，而备库 B 只是将 A 的更新操作都同步到本地并执行，保证了 A 和 B 的数据相同。</li><li>切换后，客户端读写直接访问 B，此时 A 做备库并同步 B 的操作在本地执行。</li></ul><p>[注]建议将备库设置为 readonly 模式，即使备库并没有被直接访问。因为：</p><ol><li>备库上可能会执行一些运营类的查询语句，设置只读可避免误操作</li><li>防止切换逻辑 bug，比如切换过程中出现双写，导致主备不一致</li><li>以是否 readonly 状态判断数据库的主/从角色</li></ol><h3 id="主备流程"><a href="#主备流程" class="headerlink" title="主备流程"></a>主备流程</h3><p>M-S 结构：备库 B 跟主库 A 之间维持了一个长连接。主库 A 内部有一个线程，专门用于服务备库 B 的这个长连接。</p><p>一个事务日志同步的完整过程是这样的：</p><ol><li>在备库 B 上通过 change master 命令，设置主库 A 的 IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog，这个位置包含<strong>文件名</strong>和<strong>日志偏移量</strong>；</li><li>在备库 B 上执行 start slave 命令，这时候备库会启动两个线程： io_thread（与主库建立连接） 和 sql_thread；</li><li>主库 A 校验完用户名、密码后，开始按照备库 B 传过来的位置，从本地读取 binlog 发送给 B；</li><li>备库 B 拿到 binlog 后，写到本地文件，称为中转日志（relay log）；</li><li>sql_thread 读取中转日志，解析出日志里的命令，并执行。</li></ol><h3 id="binlog-三种格式"><a href="#binlog-三种格式" class="headerlink" title="binlog 三种格式"></a>binlog 三种格式</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ol><li><p>statement</p><p>当 binlog_format=’statement‘ 时，binlog 里面记录的就是 SQL 语句的原文，包括注释。</p><p>由于 statement 格式下，记录到 binlog 里的是语句原文，因此可能会出现这样一种情况：在主库执行这条 SQL 语句的时候，用的是索引 a；而在备库执行这条 SQL 语句的时候，却使用了索引 b。因此，MySQL 认为这样写是有风险的。</p></li><li><p>row</p><p>当 binlog_format=‘row’ 时，binlog 不会 SQL 原文而是记录 event（包含：记录更新表的 Table_map event、记录更新事务的 event）。</p><p>更新事务的 event 中记录了主库中真实更新的主键 id，所以备库不会有选错索引导致主备更新不同行的问题。</p></li><li><p>mixed（statement 和 row 的混合）</p><p>存在原因：</p><ol><li>有些 statement 格式的 binlog 可能会导致主备不一致，所以要使用 row 格式；</li><li><p>row 格式很占空间；</p><p>  比如你用一个 delete 语句删掉 10 万行数据，用 statement 的话就是一个 SQL 语句被记录到 binlog 中，占用几十个字节的空间。但如果用 row 格式的 binlog，就要把这 10 万条记录都写到 binlog 中。一方面，占用了更大的空间；另一方面，写 binlog 需要耗费大量 IO 资源，影响执行速度。</p></li></ol><p>mixed 格式是一种折中方案：MySQL 自行对 SQL 语句进行判断，<strong>若可能引起主备不一致，就用 row 格式</strong>；否则，就用 statement 格式。</p><p>故线上 MySQL 设置的 binlog 格式<strong>至少</strong>应该为 ‘mixed’，既避免了 ‘statement’ 数据不一致的风险，又在不需要 ‘row’ 模式时提高空间和时间效率。</p></li></ol><h4 id="row-格式越来越常见的原因"><a href="#row-格式越来越常见的原因" class="headerlink" title="row 格式越来越常见的原因"></a>row 格式越来越常见的原因</h4><p>便于<strong>数据恢复</strong>。例如：</p><ul><li><p>执行 delete 语句</p><p>row 格式的 binlog 会把被删掉的行的整行信息保存起来。若发现误删，直接将 binlog 中记录的 delete 语句转成 insert，把被错删的数据插入回去即可恢复。</p></li><li><p>执行 insert 语句</p><p>row 格式的 binlog 会记录所有插入的字段信息。若发现误插入，直接将 binlog 中记录的 insert 语句转成 delete，把插入的数据删除即可。</p></li><li><p>执行 update 语句</p><p>row 格式的 binlog 会记录<strong>修改前</strong>整行的数据和<strong>修改后</strong>的整行数据。若误更新，只需要将更新 event 中前后的两行数据对调一下，再去数据库里面执行即可恢复。</p></li></ul><h4 id="binlog-恢复数据的标准做法"><a href="#binlog-恢复数据的标准做法" class="headerlink" title="binlog 恢复数据的标准做法"></a>binlog 恢复数据的标准做法</h4><p>用 mysqlbinlog 工具解析出来，然后把解析结果整个发给 MySQL 执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 将 &lt;binlog 文件&gt; 里面从 &lt;binlog 起始位置&gt; 字节到 &lt;binlog 结束位置&gt; 字节中间的内容解析出来，放到 MySQL 去执行</span><br><span class="line">mysqlbinlog  --start-position=&lt;binlog 起始位置&gt; --stop-position=&lt;binlog 结束位置&gt;  | mysql -h127.0.0.1 -P13000 -u$user -p$pwd;</span><br></pre></td></tr></table></figure><h3 id="循环复制"><a href="#循环复制" class="headerlink" title="循环复制"></a>循环复制</h3><p>实际生产上使用比较多的是双 M 结构：A 和 B 互为主备关系，切换主备时就不用再修改主备关系。但互为主备关系，则可能发生双方互相发送更新生成 binlog 的循环复制问题。</p><ul><li><p>解决循环复制</p><ol><li>规定每个库的 server id 必须不同，若相同则不能设定为主备关系；</li><li>备库接到 binlog 并在重放的过程中，生成与原 binlog 的 server id 相同的新的 binlog；</li><li>每个库在收到从自己的主库发过来的日志后，先判断 server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志。</li></ol></li><li><p>日志的执行流程</p><ol><li>A 的 binlog 中更新事务记录标注着 A 的 server id；</li><li>A 的 binlog 传到 B 执行一次后，B 生成的 binlog 的 server id 是 A 的 server id，再传回 A；</li><li>A 判断收到的 binlog 的 server id 与 自身相同，弃之。</li></ol></li></ul><h2 id="MySQL-保持高可用"><a href="#MySQL-保持高可用" class="headerlink" title="MySQL 保持高可用"></a>MySQL 保持高可用</h2><p>skip。</p><h2 id="备库延迟"><a href="#备库延迟" class="headerlink" title="备库延迟"></a>备库延迟</h2><p>skip。</p><h2 id="主库出错，备库如何操作"><a href="#主库出错，备库如何操作" class="headerlink" title="主库出错，备库如何操作"></a>主库出错，备库如何操作</h2><p>skip。</p><h2 id="读写分离的坑"><a href="#读写分离的坑" class="headerlink" title="读写分离的坑"></a>读写分离的坑</h2><p>skip。</p><h2 id="判断数据库是否出问题"><a href="#判断数据库是否出问题" class="headerlink" title="判断数据库是否出问题"></a>判断数据库是否出问题</h2><p>skip。</p><h2 id="数据误删"><a href="#数据误删" class="headerlink" title="数据误删"></a>数据误删</h2><h3 id="误删类型"><a href="#误删类型" class="headerlink" title="误删类型"></a>误删类型</h3><h4 id="使用-delete-语句误删数据行"><a href="#使用-delete-语句误删数据行" class="headerlink" title="使用 delete 语句误删数据行"></a>使用 delete 语句误删数据行</h4><p>Flashback：通过闪回恢复数据的工具</p><ul><li><p>原理</p><p>修改 binlog 的内容，拿回原库重放。</p></li><li><p>使用前提</p><p>确保 binlog_format=row 和 binlog_row_image=FULL。</p></li><li><p>恢复操作</p><p>对于单个事务：</p><ul><li>对于 insert 语句，对应的 binlog event 类型是 Write_rows event，把它改成 Delete_rows event 即可；</li><li>对于 delete 语句，也是将 Delete_rows event 改为 Write_rows event；</li><li>对于 Update_rows，binlog 里面记录了数据行修改前和修改后的值，对调这两行的位置即可。</li></ul><p>对于多个事务：</p><ul><li>Flashback 解析 binlog 后，需要将<strong>事务的顺序逆转</strong>过来再执行。</li></ul></li><li><p>注意事项</p><p>不建议直接在主库上执行恢复操作。</p><p>恢复数据比较安全的做法：</p><ul><li>恢复出一个备份，确认过再恢复回主库；</li><li>找一个从库作为临时库，在这个临时库上执行这些操作，然后再将确认过的临时库的数据，恢复回主库。</li></ul><p>原因：一个在执行线上逻辑的主库，数据状态的变更往往是有关联的。可能由于发现数据问题的时间晚了一点儿，就导致已经在之前误操作的基础上，业务代码逻辑又继续修改了其他数据。所以，如果这时候单独恢复这几行数据，而又未经确认的话，就可能会出现对数据的二次破坏。</p></li></ul><p>事前预防误删的措施：</p><ol><li><p>把 sql_safe_updates 参数设置为 on。</p><p>此时，如果忘记在 delete / update 语句中写 where 条件，或者 where 条件里面没有包含索引字段，这条语句的执行就会报错；</p><p>该设置下进行全表删除：</p><ul><li>在 delete 语句中加上 where 条件，比如 where 1=1；</li><li>注：delete 全表效率很低，需要生成回滚日志、写 redo、写 binlog。</li><li><p>从性能角度考虑，全表删除应优先考虑使用 truncate table 或者 drop table 命令，但无法通过 Flashback 来恢复。</p><p>因为，即使配置了 binlog_format=row，执行 truncate/drop 时，记录的 binlog 还是 statement 格式。binlog 里面就只有一个 truncate/drop 语句，这些信息是恢复不出数据的。</p></li></ul></li><li><p>代码上线前，必须经过 SQL 审计。</p></li></ol><h4 id="使用-drop-table-或者-truncate-table-语句误删数据表-数据库"><a href="#使用-drop-table-或者-truncate-table-语句误删数据表-数据库" class="headerlink" title="使用 drop table 或者 truncate table 语句误删数据表/数据库"></a>使用 drop table 或者 truncate table 语句误删数据表/数据库</h4><p>前提条件：</p><ul><li>线上有定期的全量备份</li><li>实时备份 binlog</li></ul><p>假如有人中午 12 点误删了一个库，恢复数据的流程如下：</p><ol><li>取最近一次全量备份，假设这个库是一天一备，上次备份是当天 0 点；</li><li>用备份恢复出一个临时库；</li><li>从日志备份里面，取出凌晨 0 点之后的日志；</li><li>把这些日志，除了误删除数据的语句外，全部应用到临时库。</li></ol><p>注意：</p><ol><li><p>为了加速数据恢复，如果这个临时库上有多个数据库，可以在使用 mysqlbinlog 命令时，加上“–database”参数，用来指定误删表所在的库，以避免在恢复数据时还要应用其他库日志的情况。</p></li><li><p>在应用日志的时候，需要跳过 12 点误操作的那个语句的 binlog：</p><ul><li><p>如果原实例没有使用 GTID 模式</p><p>只能在应用到包含 12 点的 binlog 文件的时候，先用“–stop-position”参数执行到误操作之前的日志，然后再用“–start-position”从误操作之后的日志继续执行；</p></li><li><p>如果实例使用了 GTID 模式</p><p>假设误操作命令的 GTID 是 gtid1，那么只需要执行</p><pre><code>set gtid_next=gtid1;begin;commit;</code></pre><p>先把这个 GTID 加到临时实例的 GTID 集合，之后按顺序执行 binlog 的时候，就会自动跳过误操作的语句。</p></li></ul></li></ol><p>mysqlbinlog 方法恢复数据不够快的主要原因有两个：</p><ol><li>如果是误删表，最好就是只恢复出这张表，也就是只重放这张表的操作，但是 mysqlbinlog 工具并不能指定只解析一个表的日志；</li><li>用 mysqlbinlog 解析出日志应用，应用日志的过程就只能是单线程。</li></ol><p>加速恢复数据：</p><ol><li><p>并行复制</p><p>在用备份恢复出临时实例之后，将这个临时实例设置成线上备库的从库，这样：</p><ol><li>在 <figure class="highlight plain"><figcaption><span>slave``` 之前，先通过执行 ```change replication filter replicate_do_table </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line">   2. 这样做也可以用上并行复制技术，来加速整个数据恢复过程。</span><br><span class="line"></span><br><span class="line">2. 延迟复制备库</span><br><span class="line"></span><br><span class="line">   一般的主备复制结构存在的问题是，如果主库上有个表被误删了，这个命令很快也会被发给所有从库，进而导致所有从库的数据表也都一起被误删了。</span><br><span class="line">  </span><br><span class="line">   延迟复制的备库是一种特殊的备库，通过 ```CHANGE MASTER TO MASTER_DELAY = N``` 命令，可以指定这个备库持续保持跟主库有 N 秒的延迟。</span><br><span class="line">  </span><br><span class="line">   比如你把 N 设置为 3600，这就代表了如果主库上有数据被误删了，并且在 1 小时内发现了这个误操作命令，这个命令就还没有在这个延迟复制的备库执行。这时候到这个备库上执行 ```stop slave```，再通过之前介绍的方法，跳过误操作命令，就可以恢复出需要的数据。这样的话，你就随时可以得到一个，只需要最多再追 1 小时，就可以恢复出数据的临时实例，也就缩短了整个数据恢复需要的时间。</span><br><span class="line"></span><br><span class="line">预防误删库 / 表的方法：</span><br><span class="line"></span><br><span class="line">1. 账号分离，避免写错命令</span><br><span class="line">  </span><br><span class="line">   - 只给业务开发同学 DML 权限，而不给 truncate/drop 权限。在有 DDL 需求的时候，通过开发管理系统得到支持；</span><br><span class="line">  </span><br><span class="line">   - DBA 团队成员，日常也都规定只使用只读账号，必要的时候才使用有更新权限的账号。</span><br><span class="line"></span><br><span class="line">2. 制定操作规范，避免写错要删除的表名。</span><br><span class="line">  </span><br><span class="line">   - 在删除数据表之前，必须先对表做改名操作。然后，观察一段时间，确保对业务无影响以后再删除这张表。</span><br><span class="line">  </span><br><span class="line">   - 改表名的时候，要求给表名加固定的后缀（比如加 _to_be_deleted），然后删除表的动作必须通过管理系统执行。并且，管理系删除表的时候，只能删除固定后缀的表。</span><br><span class="line"></span><br><span class="line">#### 使用 rm 命令误删整个 MySQL 实例</span><br><span class="line"></span><br><span class="line">1. 对于一个有高可用机制的 MySQL 集群来说只要不是恶意地把整个集群删除，而只是删掉了其中某一个节点的数据的话，HA 系统（High Available，高可用性集群）就会开始工作，选出一个新的主库，从而保证整个集群的正常工作。</span><br><span class="line"></span><br><span class="line">2. 避免 MySQL 集群挂掉：尽量将备份跨机房，最好是跨城市保存。</span><br><span class="line"></span><br><span class="line">## kill 不掉的语句</span><br><span class="line"></span><br><span class="line">### 两种 kill 命令</span><br><span class="line"></span><br><span class="line">- kill query + 线程 id</span><br><span class="line">  </span><br><span class="line">  终止这个线程中正在执行的语句。</span><br><span class="line"></span><br><span class="line">- kill (connection) + 线程 id</span><br><span class="line">  </span><br><span class="line">  断开这个线程的连接，当然如果这个线程有语句正在执行，也是要先停止正在执行的语句的。</span><br><span class="line"></span><br><span class="line">### kill 执行过程</span><br><span class="line"></span><br><span class="line">以 kill query thread_id_B 为例：</span><br><span class="line">1. 把 session B 的运行状态改成 THD::KILL_QUERY(将变量 killed 赋值为 THD::KILL_QUERY)；</span><br><span class="line">2. 给 session B 的执行线程发一个信号。</span><br><span class="line">   </span><br><span class="line">   发送信号是因为：假设 session B 处于锁等待状态，如果只是把 session B 的线程状态设置 THD::KILL_QUERY，线程 B 无法知道这个状态变化，还是会继续等待。所以发送信号通知 session B 退出等待，来处理这个 THD::KILL_QUERY 状态。</span><br><span class="line"></span><br><span class="line">   表明：</span><br><span class="line">   1. 一个语句执行过程中有多处“埋点”，在这些“埋点”的地方判断线程状态，如果发现线程状态是 THD::KILL_QUERY，才开始进入语句终止逻辑；</span><br><span class="line">   2. 如果处于等待状态，必须是一个可以被唤醒的等待，否则根本不会执行到“埋点”处；</span><br><span class="line">   3. 语句从开始进入终止逻辑，到终止逻辑完全完成，是有一个过程的。</span><br><span class="line"></span><br><span class="line">### kill 失效</span><br><span class="line"></span><br><span class="line">#### kill 失效现象</span><br><span class="line"></span><br><span class="line">使用了 kill 命令，却没能断开这个连接。再执行 show processlist 命令，看到这条语句的 Command 列显示的是 Killed。</span><br><span class="line"></span><br><span class="line">show processlist 的特别逻辑：如果一个线程的状态是KILL_CONNECTION，就把Command列显示成Killed。</span><br><span class="line"></span><br><span class="line">#### 情况一：线程没有执行到判断线程状态的逻辑</span><br><span class="line"></span><br><span class="line">#### 情况二：终止逻辑耗时较长</span><br><span class="line"></span><br><span class="line">常见场景：</span><br><span class="line">1. 超大事务执行期间被 kill</span><br><span class="line">   </span><br><span class="line">   此时，回滚操作需要对事务执行期间生成的所有新数据版本做回收操作，耗时很长。</span><br><span class="line"></span><br><span class="line">2. 大查询回滚</span><br><span class="line">   </span><br><span class="line">   如果查询过程中生成了比较大的临时文件，加上此时文件系统压力大，删除临时文件可能需要等待 IO 资源，导致耗时较长。</span><br><span class="line"></span><br><span class="line">3. DDL 命令执行到最后阶段被 kill</span><br><span class="line">   </span><br><span class="line">   此时，系统需要删除中间过程的临时文件，也可能受 IO 资源影响耗时较久。</span><br><span class="line"></span><br><span class="line">### 关于客户端的误解</span><br><span class="line"></span><br><span class="line">#### “Ctrl+C” 可以直接终止线程 -- X</span><br><span class="line"></span><br><span class="line">正解：“Ctrl+C” 不能直接终止线程。</span><br><span class="line"></span><br><span class="line">原因：</span><br><span class="line">1. 客户端的操作只能操作到客户端的线程，客户端和服务端只能通过网络交互，是不可能直接操作服务端线程的。</span><br><span class="line"></span><br><span class="line">2. 由于 MySQL 是停等协议，所以当前线程执行的语句还没有返回的时候，再往这个连接里面继续发命令也是没有用的。实际上，执行 “Ctrl+C” 时 MySQL 客户端会另外启动一个连接，然后发送一个 kill query 命令。</span><br><span class="line"></span><br><span class="line">#### 库里面的表越多，连接越慢 -- X</span><br><span class="line"></span><br><span class="line">正解：本地客户端执行操作慢，而非连接慢或服务端慢。</span><br><span class="line"></span><br><span class="line">原因：</span><br><span class="line">1. 前提</span><br><span class="line">   </span><br><span class="line">   客户端与服务端建立连接的涉及操作只有： TCP 握手、用户校验、获取权限。与库里的表个数无关。</span><br><span class="line"></span><br><span class="line">2. 根源</span><br><span class="line"></span><br><span class="line">   当使用**默认参数连接**的时候，MySQL 客户端会提供一个本地库名和表名补全的功能（Tab 键自动补全表名或者显示提示）。为了实现这个功能，客户端在连接成功后，需要多做一些操作：</span><br><span class="line">   1. 执行 show databases；</span><br><span class="line">   2. 切到 db1 库，执行 show tables；</span><br><span class="line">   3. 把这两个命令的结果用于构建一个本地的哈希表。（此过程耗时较长，尤其在表数很多的时候）</span><br><span class="line"></span><br><span class="line">   自动补全关闭：</span><br><span class="line">   1. 在连接命令中加上 “-A”，就可以关掉这个自动补全的功能，然后客户端就可以快速返回了；</span><br><span class="line">   2. 在连接命令中加上 “–quick”(或 “-q”) 参数，也可以跳过这个阶段。</span><br><span class="line"></span><br><span class="line">#### “–quick” 是一个让服务端加速的参数 -- X</span><br><span class="line"></span><br><span class="line">正解：“–quick” 只能加快客户端响应，反而可能降低服务端的性能。</span><br><span class="line"></span><br><span class="line">原因：使用 “–quick” 参数，客户端会使用不缓存的方式。此时，如果客户端本地处理缓慢，就会导致服务端的发送结果被阻塞，让服务端变慢。</span><br><span class="line"></span><br><span class="line">“–quick” 效果：</span><br><span class="line"></span><br><span class="line">1. 跳过表名自动补全功能；</span><br><span class="line">2. mysql_store_result 需要申请本地内存来缓存查询结果，如果查询结果太大，会耗费较多的本地内存，可能会影响客户端本地机器的性能；</span><br><span class="line">3. 不会把执行命令记录到本地的命令历史文件。</span><br><span class="line"></span><br><span class="line">可见，“–quick” 是让客户端变得更快。</span><br><span class="line"></span><br><span class="line">MySQL 客户端接收服务端返回结果的方式有两种：</span><br><span class="line">1. 本地缓存</span><br><span class="line">   </span><br><span class="line">   在本地开一片内存，先把结果存起来。如果你用 API 开发，对应的就是 mysql_store_result 方法。</span><br><span class="line"></span><br><span class="line">2. 不缓存</span><br><span class="line">   </span><br><span class="line">   读一个处理一个。如果你用 API 开发，对应的就是 mysql_use_result 方法。</span><br><span class="line"></span><br><span class="line">## 查大量数据的内存问题</span><br><span class="line"></span><br><span class="line">### 全表扫描对 server 层的影响</span><br><span class="line"></span><br><span class="line">#### MySQL S/C 收发数据流程</span><br><span class="line"></span><br><span class="line">MySQL 是**边读边发的**，而非服务端保存一个完整的结果再集一次性发送。如果客户端接收得慢，会导致 MySQL 服务端由于结果发不出去，使事务的执行时间变长。取数据和发数据的流程：</span><br><span class="line"></span><br><span class="line">1. 获取一行，写到 net_buffer 中。这块内存的大小是由参数 net_buffer_length 定义的，默认是 16k；</span><br><span class="line">2. 重复获取行，直到 net_buffer 写满，调用网络接口发出去；</span><br><span class="line">3. 如果发送成功，就清空 net_buffer，然后继续取下一行，并写入 net_buffer；</span><br><span class="line">4. 如果发送函数返回 EAGAIN 或 WSAEWOULDBLOCK，就表示本地网络栈（socket send buffer）写满了，进入等待。直到网络栈重新可写，再继续发送。</span><br><span class="line"></span><br><span class="line">可见：</span><br><span class="line">1. 一个查询在发送过程中，占用的 MySQL 内部的内存最大就是 net_buffer_length 这么大，并不会达到 200G；</span><br><span class="line">2. socket send buffer 也不可能达到 200G（默认定义 /proc/sys/net/core/wmem_default），如果 socket send buffer 被写满，就会暂停读数据的流程。</span><br><span class="line"></span><br><span class="line">#### 线程 &quot;sending&quot; 状态</span><br><span class="line"></span><br><span class="line">线程状态：</span><br><span class="line">- &quot;Sending to client&quot;</span><br><span class="line">  </span><br><span class="line">  服务器端的网络栈已写满，线程处于“等待客户端接收结果”的状态。</span><br><span class="line">  </span><br><span class="line">  如果客户端使用–quick 参数，会使用 mysql_use_result 方法：读一行处理一行。假设客户端在遇上逻辑比较复杂的业务处理较慢，就容易产生该状态。</span><br><span class="line"></span><br><span class="line">- “Sending data”</span><br><span class="line">  </span><br><span class="line">  线程“正在执行”。并不一定是指“正在发送数据”，而可能是处于执行器过程中的任意阶段。</span><br><span class="line"></span><br><span class="line">  查询语句的状态变化：</span><br><span class="line">  1. MySQL 查询语句进入执行阶段后，首先把状态设置成“Sending data”；</span><br><span class="line">  2. 然后，发送执行结果的列相关的信息（meta data) 给客户端；</span><br><span class="line">  3. 再继续执行语句的流程；</span><br><span class="line">  4. 执行完成后，把状态设置成空字符串。</span><br><span class="line"></span><br><span class="line">故对于正常的线上业务来说，当一个查询的返回结果：</span><br><span class="line">- 不会很多</span><br><span class="line">  </span><br><span class="line">  建议使用 mysql_store_result 这个接口，直接把查询结果保存到本地内存。</span><br><span class="line"></span><br><span class="line">- 很多</span><br><span class="line">  </span><br><span class="line">  建议使用 mysql_use_result 接口。同时，优化查询结果，并评估这么多的返回结果是否合理。</span><br><span class="line"></span><br><span class="line">### 全表扫描对 InnoDB 的影响</span><br><span class="line"></span><br><span class="line">InnoDB 引擎内部，由于有淘汰策略，大查询也不会导致内存暴涨。并且，由于 InnoDB 对 LRU 算法做了改进，冷数据的全表扫描，对 Buffer Pool 的影响也能做到可控。</span><br><span class="line"></span><br><span class="line">#### Buffer Pool</span><br><span class="line"></span><br><span class="line">作用：</span><br><span class="line">- 保存更新结果，配合 redo log，避免随机写盘</span><br><span class="line">- 缓存数据页，加速查询</span><br><span class="line"></span><br><span class="line">内存命中率：</span><br><span class="line">- Buffer Pool 对查询的加速效果的指标</span><br><span class="line">- 查看</span><br><span class="line">  ```SQL</span><br><span class="line">  show engine innodb status;</span><br><span class="line">  -- Buffer pool hit rate 即当前的命中率</span><br></pre></td></tr></table></figure></li></ol></li></ol><p>innodb_buffer_pool_size：</p><ul><li>设置 Buffer Pool 的大小</li><li>建议大小：物理内存的 60%~80%（内存用尽原则）</li></ul><h4 id="InnoDB-内存管理"><a href="#InnoDB-内存管理" class="headerlink" title="InnoDB 内存管理"></a>InnoDB 内存管理</h4><ul><li><p>最近最少使用 (Least Recently Used, LRU) 算法：淘汰最久未使用的数据</p><ol><li>链表大小固定，表头是最近刚刚被访问过的数据页；</li><li>最新请求的数据页会被移至表头；</li><li>请求数据页不在链表中，向 BP 申请新数据页移至表头。此时若链表已满，表尾会被情况并放入新数据页内容，再移至表头。</li></ol></li><li><p>若一次性读取一个较大且久未访问的数据表</p><p>当前 BP 中的数据会被全部淘汰掉，导致 BP 的内存命中率急剧下降，磁盘压力增加，SQL 语句响应变慢，对正在做业务服务的库效率影响很大。</p><p>为避免该情况，InnoDB 对 LRU 算法做了改进。</p></li><li><p>InnoDB 改进后的 LRU 算法：</p><p>按照 5:3 的比例把整个 LRU 链表分成了 young 区域和 old 区域，LRU_old 指向 old 区域的第一个位置，即整个链表的 5/8 处。</p><p>执行过程：</p><ol><li>请求访问数据页在 young 区域，将数据页移至 young 区域头部，即表头；</li><li>请求的访问数据页不在当前整个链表中，淘汰表尾数据页，新数据页放至 LRU_old 处；</li><li><p>old 区域中的每个数据页，每次被访问的时候都要做下面这个判断：</p><ul><li>若其在 LRU 链表中存在的时间 &gt; 1 秒，将其移动到链表头部；</li><li>如其在 LRU 链表中存在的时间 &lt; 1 秒，位置保持不变。</li></ul><p>1 秒这个时间，由参数 innodb_old_blocks_time 控制，其默认值是 1000，单位毫秒。</p></li></ol><p>改进后的 LRU 算法，既使用了 BP，又使 young 区域中的常用数据页不受大规模历史数据查询的影响，保证了 BP 响应正常业务的查询命中率。</p></li></ul><h3 id="查询大量数据的常用做法"><a href="#查询大量数据的常用做法" class="headerlink" title="查询大量数据的常用做法"></a>查询大量数据的常用做法</h3><h4 id="一次性取"><a href="#一次性取" class="headerlink" title="一次性取"></a>一次性取</h4><ul><li>好处：对服务端只全表，只扫描一遍；</li><li>坏处：可能会出现大事务。</li></ul><h4 id="建议做法"><a href="#建议做法" class="headerlink" title="建议做法"></a>建议做法</h4><p>分批次取，然后每一批拿到最大的一个id（主键值），下一批查询的时候用 where Id &gt; N。</p><h2 id="join-的使用和优化"><a href="#join-的使用和优化" class="headerlink" title="join 的使用和优化"></a>join 的使用和优化</h2><h3 id="Index-Nested-Loop-Join"><a href="#Index-Nested-Loop-Join" class="headerlink" title="Index Nested-Loop Join"></a>Index Nested-Loop Join</h3><h4 id="NLJ-执行过程"><a href="#NLJ-执行过程" class="headerlink" title="NLJ 执行过程"></a>NLJ 执行过程</h4><p>以下方 SQL 为例，t1 和 t2 表结构相同，都有一个主键索引 id 和一个索引 a：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">straight_join</span> t2 <span class="keyword">on</span> (t1.a=t2.a);</span><br><span class="line"><span class="comment">-- straight_join 让 MySQL 使用固定的连接方式执行查询，这样优化器只会按照我们指定的方式去 join：在该语句中，t1 是驱动表，t2 是被驱动表。</span></span><br><span class="line"><span class="comment">-- 直接使用 join 语句，MySQL 优化器可能会选择表 t1 或 t2 作为驱动表</span></span><br></pre></td></tr></table></figure><p>该 SQL 执行过程：</p><ol><li>从表 t1 中读入一行数据 R；</li><li>从数据行 R 中，取出 a 字段到表 t2 里去（索引）查找；</li><li>取出表 t2 中满足条件的行，跟 R 组成一行，作为结果集的一部分；</li><li>重复执行步骤 1 到 3，直到表 t1 的末尾循环结束。</li></ol><p>此过程与嵌套查询类似，并可以用上被驱动表的索引。故称 “Index Nested-Loop Join”，简称 NLJ。</p><h4 id="NLJ-选择驱动表"><a href="#NLJ-选择驱动表" class="headerlink" title="NLJ 选择驱动表"></a>NLJ 选择驱动表</h4><p><strong>应该让小表来做驱动表。</strong></p><p>假设被驱动表的行数是 M。每次在被驱动表查一行数据，要先搜索索引 a，再搜索主键索引。每次搜索一棵树近似复杂度是以 2 为底的 M 的对数，记为 $\log_2M$，所以在被驱动表上查一行的时间复杂度是 $2·\log_2M$。</p><p>假设驱动表的行数是 N，执行过程就要扫描驱动表 N 行，然后对于每一行，到被驱动表上匹配一次。</p><p>因此整个执行过程，近似复杂度是 $N + N·2·\log_2M$。可见，N 对扫描行数的影响更大，因此应该让小表来做驱动表。</p><h3 id="Simple-Block-Nested-Loop-Join"><a href="#Simple-Block-Nested-Loop-Join" class="headerlink" title="Simple/Block Nested-Loop Join"></a>Simple/Block Nested-Loop Join</h3><p>以下方 SQL 为例，t1 和 t2 表结构相同，都有一个主键索引 id 和一个索引 a，字段 b 上无索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">straight_join</span> t2 <span class="keyword">on</span> (t1.a=t2.b);</span><br></pre></td></tr></table></figure><p>由于表 t2 的字段 b 上没有索引，因此再用图 2 的执行流程时，每次到 t2 去匹配的时候，就要做一次全表扫描。该算法被称作 “Simple Nested-Loop Join”。假设 t1 行数为 M，t2 行数为 N，那么总共需要扫描 M*N 行。</p><p>当 Simple Nested-Loop Join 中两个表的行数都非常大，称作 “Block Nested-Loop Join” 的算法，简称 BNL。</p><h4 id="BNL-执行过程"><a href="#BNL-执行过程" class="headerlink" title="BNL 执行过程"></a>BNL 执行过程</h4><p>由于被驱动表上没有可用的索引：</p><ol><li>把表 t1 的数据读入线程内存 join_buffer 中，由于语句中写的是 select <em>，因此是<em>*把整个表 t1 放入了内存</em></em>；</li><li>扫描表 t2，把表 t2 中的每一行取出来，跟 join_buffer 中的数据做对比，满足 join 条件的，作为结果集的一部分返回。</li></ol><p>与 Simple Nested-Loop Join 相比，二者时间复杂度相同，但 BNL 中的判断 M*N 次判断操作在内存中进行，速度会快很多。</p><h4 id="join-buffer"><a href="#join-buffer" class="headerlink" title="join_buffer"></a>join_buffer</h4><p>join_buffer 是一个无序数组，其大小是由参数 join_buffer_size 设定的，默认值是 256k。</p><p>若表 t1 很大，join_buffer 一次性放不下 t1 的所有数据，会将数据<strong>分段放</strong>。此时执行过程变成：</p><ol><li>扫描表 t1，顺序读取数据行放入 join_buffer 中，待 join_buffer 满了，继续第 2 步；</li><li>扫描表 t2，把 t2 中的每一行取出来，跟 join_buffer 中的数据做对比，满足 join 条件的，作为结果集的一部分返回；</li><li>清空 join_buffer；</li><li>继续扫描表 t1，顺序读取最后的 12 行数据放入 join_buffer 中，继续执行第 2 步。</li></ol><h4 id="BNL-选择驱动表"><a href="#BNL-选择驱动表" class="headerlink" title="BNL 选择驱动表"></a>BNL 选择驱动表</h4><p>假设驱动表的行数是 N，被驱动表的行数是 M </p><ul><li><p>N 小于 join_buffer 的大小：</p><ol><li>两个表都做一次全表扫描，所以总的扫描行数是 M+N；</li><li>内存中的判断次数是 M*N。</li></ol><p>此时，选择大表还是小表做驱动表，执行耗时是一样的。</p></li><li><p>N 大于 join_buffer 的大小，驱动表被分成 k 段。因为 N 越大 k 越大，所以 k 可表示为 μ * N，μ ∈ (0,1)：</p><ol><li>大表扫描行数为 N，小表扫描行数为 μ <em> N </em> M，扫描总行数为 N +  μ <em> N </em> M；</li><li>内存中判断的次数为 N * M。</li></ol><p>可见：</p><ol><li><p>N 越小越好，故<strong>应选择小表做驱动表。</strong></p></li><li><p>k（分段数）越小越好，所以 <strong>join_buffer_size 越大越好</strong>。</p></li></ol></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><h4 id="是否用-join"><a href="#是否用-join" class="headerlink" title="是否用 join"></a>是否用 join</h4><p>explain 查询语句，查看 Extra 字段：</p><ol><li>NLJ：可以使用。</li><li>BNL：尽量不使用。扫描行数过多，太占用系统资源。</li></ol><h4 id="join-驱动表选择"><a href="#join-驱动表选择" class="headerlink" title="join 驱动表选择"></a>join 驱动表选择</h4><p>总是用“小表”：</p><ol><li><p>小表</p><p>两个表按照<strong>各自的条件过滤</strong>，过滤完成之后，计算<strong>参与 join 的各个字段</strong>的总数据量，数据量小的那个表。</p></li><li><p>小表并非数据行数较少的那个表。</p></li></ol><h2 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h2><h3 id="与内存表的区别"><a href="#与内存表的区别" class="headerlink" title="与内存表的区别"></a>与内存表的区别</h3><ul><li><p>内存表</p><ol><li>使用 Memory 引擎的表创键。</li><li>表的数据都保存在内存里，系统重启的时候会被清空，但是表结构还在。</li></ol></li><li><p>临时表</p><ol><li>可以使用各种引擎（包括 Memory 引擎）类型创建。</li><li>使用 InnoDB 引擎或者 MyISAM 引擎的临时表，写数据的时候是写到磁盘上的。</li></ol></li></ul><h3 id="临时表的特征"><a href="#临时表的特征" class="headerlink" title="临时表的特征"></a>临时表的特征</h3><ol><li>建表语法：create temporary table …。</li><li>一个临时表只能被创建它的 session 访问，对其他线程不可见。在session 结束的时候，会自动删除。</li><li>临时表可以与普通表同名。</li><li>session A 内有同名的临时表和普通表的时候，show create 语句，以及增删改查语句访问的是临时表。</li><li>show tables 命令不显示临时表。</li></ol><h3 id="临时表的应用"><a href="#临时表的应用" class="headerlink" title="临时表的应用"></a>临时表的应用</h3><p>临时表一般用于处理比较复杂的计算逻辑。由于临时表是每个线程自己可见的，所以不需要考虑多个线程执行同一个处理逻辑时，临时表的重名问题。在线程退出的时候，临时表也能自动删除，省去了收尾和异常处理的工作。</p><h4 id="join-优化"><a href="#join-优化" class="headerlink" title="join 优化"></a>join 优化</h4><ol><li><p>不同 session 的临时表是可重名。</p><p>如果有多个 session 同时执行 join 优化，不需要担心表名重复导致建表失败的问题。</p></li><li><p>不需要担心数据删除问题。</p><p>如果使用普通表，在流程执行过程中客户端发生了异常断开，或者数据库发生异常重启，还需要专门来清理中间过程中生成的数据表。</p><p>而临时表由于会自动回收，所以不需要这个额外的操作。</p></li></ol><h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><ul><li><p>一般场景</p><p>把一个逻辑上的大表分散到不同的数据库实例上。</p><p>分库分表系统一般都有一个中间层 proxy。在这个架构中，分区 key 的选择是以“减少跨库和跨表查询”为依据的。如果大部分的语句都会包含 f 的等值条件，那么就要用 f 做分区键。这样，在 proxy 这一层解析完 SQL 语句以后，就能确定将这条语句路由到哪个分表做查询。</p></li></ul><p>查询语句没有用到分区字段：</p><ol><li><p>在 proxy 层的进程代码中实现排序。</p><p>这种方式的优势是处理速度快，拿到分库的数据以后，直接在内存中参与计算。</p><p>不过，这个方案的缺点也比较明显：</p><ol><li>需要的开发工作量比较大。<br>如果涉及到复杂的操作，比如 group by，甚至 join 这样的操作，对中间层的开发能力要求比较高；</li><li>对 proxy 端的压力比较大，尤其是很容易出现内存不够用和 CPU 瓶颈的问题。</li></ol></li><li><p>各分库操作再汇总操作。</p><p>把各个分库拿到的数据，汇总到一个 MySQL 实例的一个临时表中，然后在这个汇总实例上做逻辑操作。由于分库操作每个分库的计算量往往不饱和，所以会直接把临时表放到某一个分库上。</p></li></ol><h3 id="临时表可重名原因"><a href="#临时表可重名原因" class="headerlink" title="临时表可重名原因"></a>临时表可重名原因</h3><h4 id="物理原因"><a href="#物理原因" class="headerlink" title="物理原因"></a>物理原因</h4><p>使用 InnoDB 引擎创键表时，会创建一个 frm 文件保存表结构定义，还要有地方保存表数据。</p><ul><li><p>frm 文件</p><p>存放在临时文件目录下，文件名的后缀是.frm，前缀是“#sql{进程 id}<em>{线程 id}</em> 序列号”。可以使用 select @@tmpdir 命令，来显示实例的临时文件目录。</p></li><li><p>表中数据的存放方式</p><ul><li><p>在 5.6 以及之前的版本里，MySQL 会在临时文件目录下创建一个相同前缀、以 <strong>.ibd</strong> 为后缀的文件，用来存放数据文件；</p></li><li><p>5.7 版本开始，MySQL 引入了一个<strong>临时文件表空间</strong>，专门用来存放临时文件的数据。因此，我们就不需要再创建 ibd 文件了。</p></li></ul></li></ul><p>可见，不同 session 创键名为 t 的同名临时表，在存储上两者磁盘文件名是不同的。</p><h4 id="table-def-key-原因"><a href="#table-def-key-原因" class="headerlink" title="table_def_key 原因"></a>table_def_key 原因</h4><p>MySQL 维护数据表，除了物理上要有文件外，内存里面也有一套机制区别不同的表，每个表都对应一个 table_def_key：</p><ul><li><p>普通表的 table_def_key</p><p>由“库名 + 表名”得到的，所以如果你要在同一个库下创建两个同名的普通表，创建第二个表的过程中就会发现 table_def_key 已经存在了。</p></li><li><p>临时表</p><p>table_def_key 在“库名 + 表名”基础上，又加入了“server_id+thread_id”。</p></li></ul><p>可见，不同 session 创键名为 t 的同名临时表，两者的 table_def_key 是不同的。</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>不同 session 创键名为 t 的同名临时表，由于它们的 table_def_key 不同，磁盘文件名也不同，因此可以并存。</p><h3 id="临时表与主备复制"><a href="#临时表与主备复制" class="headerlink" title="临时表与主备复制"></a>临时表与主备复制</h3><h4 id="bing-log-记录临时表操作"><a href="#bing-log-记录临时表操作" class="headerlink" title="bing log 记录临时表操作"></a>bing log 记录临时表操作</h4><p>在实现上，每个线程都维护了自己的临时表链表。每次 session 内操作表时：</p><ol><li>先遍历链表，检查是否有这个名字的临时表，如果有就优先操作临时表；</li><li>如果没有临时表，操作普通表；</li><li>在 session 结束的时候，对链表里的每个临时表，执行 “DROP TEMPORARY TABLE + 表名”操作。</li></ol><p>为了备库需要，binlog 中会记录 “DROP TEMPORARY TABLE” 这条命令。如果不记录临时表的操作，当主库普通表中存在部分由临时表得来的数据，备库在执行时将无法获取这部分数据。因此，主库创建临时表的语句会传到备库执行，备库的同步线程就会创建这个临时表。主库在线程退出的时候，会自动删除临时表，但是备库同步线程是持续在运行的。所以，此时需要在主库上再写一个 DROP TEMPORARY TABLE 传给备库执行。</p><p>由于 binlog_format=row 时，binlog 中直接记录操作相关的数据，所以此时跟临时表有关的语句，就不会记录到 binlog 里；而当 binlog_format=statment/mixed 时，binlog 中会记录临时表的操作。</p><h4 id="drop-table-的改写"><a href="#drop-table-的改写" class="headerlink" title="drop table 的改写"></a>drop table 的改写</h4><p>drop table 命令可以一次删除多个表。比如，在上面的例子中，设置 binlog_format=row，如果主库上执行 “drop table t_normal, temp_t”这个命令，那么 binlog 中就只能记录：DROP TABLE <code>t_normal</code> /<em> generated by server </em>/因为备库上并没有表 temp_t，将这个命令重写后再传到备库执行，才不会导致备库同步线程停止。所以，drop table 命令记录 binlog 的时候，就必须对语句做改写。“/<em> generated by server </em>/”说明了这是一个被服务端改写过的命令。</p><h4 id="主库上不同线程的同名的临时表是没关系的如何传到备库执行"><a href="#主库上不同线程的同名的临时表是没关系的如何传到备库执行" class="headerlink" title="主库上不同线程的同名的临时表是没关系的如何传到备库执行"></a>主库上不同线程的同名的临时表是没关系的如何传到备库执行</h4><p>MySQL 在记录 binlog 的时候，会把主库执行这个语句的线程 id 写到 binlog 中。这样，在备库的应用线程就能够知道执行每个语句的主库线程 id，并利用这个线程 id 来构造临时表的 table_def_key。</p><p>如主库 M 上的两个 session 创建了同名的临时表 t1，这两个 create temporary table t1 语句都会被传到备库 S 上：</p><ol><li>session A 的临时表 t1，在备库的 table_def_key 就是：库名 +t1+“M 的 serverid”+“session A 的 thread_id”;</li><li>session B 的临时表 t1，在备库的 table_def_key 就是 ：库名 +t1+“M 的 serverid”+“session B 的 thread_id”。</li></ol><p>由于 table_def_key 不同，这两个表在备库的应用线程里面不会冲突。</p><h2 id="MySQL-使用内存临时表的时机"><a href="#MySQL-使用内存临时表的时机" class="headerlink" title="MySQL 使用内存临时表的时机"></a>MySQL 使用内存临时表的时机</h2><h3 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h3><h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><ol><li>创建一个内存临时表，该临时表中的字段 = 第一个子查询中的查询字段，且为主键字段；</li><li>执行第一个子查询，结果存入临时表；</li><li>执行第二个子查询，逐行取出结果试图插入临时表：<ul><li>若该值已存在于临时表，违反唯一性约束，则插入失败，跳过；</li><li>若该值临时表中不存在，则插入；</li></ul></li><li>从临时表中按行取出数据，返回结果，并删除临时表。</li></ol><h4 id="内存临时表大小"><a href="#内存临时表大小" class="headerlink" title="内存临时表大小"></a>内存临时表大小</h4><ul><li>内存临时表的大小是有限制的，通过参数 tmp_table_size 控制，默认是 16M。</li><li>当内存临时表大小到达了上限，系统会将内存临时表转成磁盘临时表，磁盘临时表默认使用的引擎是 InnoDB。</li></ul><h3 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h3><h4 id="执行过程-1"><a href="#执行过程-1" class="headerlink" title="执行过程"></a>执行过程</h4><ol><li>创建一个内存临时表，临时表字段 = 待查询字段，聚合键作为主键；</li><li>通过表索引找到所需要的数据，插入临时表；</li><li>对临时表数据进行排序，返回结果，并删除临时表；</li><li>无需排序的情况下，可通过 ORDER BY NULL 取消排序这一步。</li></ol><h4 id="优化：索引"><a href="#优化：索引" class="headerlink" title="优化：索引"></a>优化：索引</h4><p>不论是使用内存临时表还是磁盘临时表，GROUP BY 逻辑都需要构造一个带唯一索引的内存临时表，目的时为了排序。</p><p>如果可以确保输入的数据是有序的，就可以拿到 GROUP BY 的结果，不需要临时表，也不需要再额外排序。故可以：</p><ul><li><p>MySQL 5.6 及之前的版本</p><p>对聚合键、待查数据创建索引。</p></li><li><p>MySQL 5.7 以后版本</p><p>使用 generated column 机制实现列数据的关联更新：创建一个新列，然后在新列上创建一个索引。</p></li></ul><h4 id="优化：直接排序"><a href="#优化：直接排序" class="headerlink" title="优化：直接排序"></a>优化：直接排序</h4><p>如果遇到数据量很大，又不适合创建索引的场景，此时排序无法避免：</p><ul><li>在内存临时表足够大小的情况下，应优先使用内存临时表；</li><li>但在数据量远大于内存临时表大小的情况下，可以绕过存入内存临时表这一环，直接走磁盘临时表效率更高。</li></ul><p>以下方 SQL 为例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SQL_BIG_RESULT</span> &lt;列名&gt;, ... <span class="keyword">FROM</span> t <span class="keyword">GROUP</span> <span class="keyword">BY</span> ...</span><br></pre></td></tr></table></figure><p>由于磁盘临时表是 B+ 树存储，存储效率不如数组，MySQL 优化器从磁盘空间考虑直接用数组存数据。执行过程如下：</p><ol><li>初始化 sort_buffer，放入整型字段 = 聚合键字段；</li><li>通过扫描表 t 的索引依次取出目标结果存入 sort_buffer 中；</li><li>扫描完成后，对 sort_buffer 的字段做排序（如果 sort_buffer 内存不够用，就会利用磁盘临时文件辅助排序）；</li><li>排序完成后，就得到了一个有序数组。</li></ol><h3 id="总结：内粗临时表使用场景"><a href="#总结：内粗临时表使用场景" class="headerlink" title="总结：内粗临时表使用场景"></a>总结：内粗临时表使用场景</h3><ol><li>SQL 执行过程<strong>无法即读即得</strong>目标结果，需要额外的内存来保存中间结果；</li><li>join_buffer 是无序数组，sort_buffer 是有序数组，内存临时表是二维表结构。如果 SQL 执行逻辑需要用到<strong>二维表特性</strong>，就会优先考虑使用临时表。如：UNION、GROUP BY。</li></ol><h2 id="InnoDB-和-Memory-引擎"><a href="#InnoDB-和-Memory-引擎" class="headerlink" title="InnoDB 和 Memory 引擎"></a>InnoDB 和 Memory 引擎</h2><p>skip。</p><h2 id="自增主键为何不连续"><a href="#自增主键为何不连续" class="headerlink" title="自增主键为何不连续"></a>自增主键为何不连续</h2><p>skip。</p><h2 id="insert-语句的锁"><a href="#insert-语句的锁" class="headerlink" title="insert 语句的锁"></a>insert 语句的锁</h2><h3 id="insert-…-select"><a href="#insert-…-select" class="headerlink" title="insert … select"></a>insert … select</h3><h3 id="insert-循环写入"><a href="#insert-循环写入" class="headerlink" title="insert 循环写入"></a>insert 循环写入</h3><h3 id="insert-唯一键冲突"><a href="#insert-唯一键冲突" class="headerlink" title="　insert 唯一键冲突"></a>　insert 唯一键冲突</h3><h3 id="insert-into-…-on-duplicate-key-update"><a href="#insert-into-…-on-duplicate-key-update" class="headerlink" title="insert into … on duplicate key update"></a>insert into … on duplicate key update</h3><h2 id="快速复制一张表"><a href="#快速复制一张表" class="headerlink" title="快速复制一张表"></a>快速复制一张表</h2><p>为了避免对源表加读锁，稳妥的方案是先将数据写到外部文本文件，然后再写回目标表。</p><h3 id="使用-mysqldump"><a href="#使用-mysqldump" class="headerlink" title="使用 mysqldump"></a>使用 mysqldump</h3><p>使用 mysqldump 命令将数据导出成一组 INSERT 语句，再执行插入。</p><h4 id="导出-INSERT-语句"><a href="#导出-INSERT-语句" class="headerlink" title="导出 INSERT 语句"></a>导出 INSERT 语句</h4><p>通过以下 mysqldump <strong>命令</strong>生成包含 INSERT 语句的 t.sql 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h$host -P$port -u$user --add-locks=0 --no-create-info --single-transaction  --set-gtid-purged=OFF db1 t --where=&quot;a&gt;900&quot; --result-file=/client_tmp/t.sql</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><p>–single-transaction</p><p>在导出数据的时候不需要对表 db1.t 加表锁，而是使用 START TRANSACTION WITH CONSISTENT SNAPSHOT 的方法；</p></li><li><p>–add-locks </p><p>设置为 0 表示在输出的文件结果里，不增加” LOCK TABLES t WRITE;” ；</p></li><li><p>–no-create-info </p><p>不需要导出表结构；</p></li><li><p>–set-gtid-purged </p><p>设置为 off 表示不输出跟 GTID 相关的信息；</p></li><li><p>–result-file </p><p>指定输出文件的路径，其中 client 表示生成的文件是在客户端机器上的。</p></li></ul><h4 id="执行-INSERT-语句"><a href="#执行-INSERT-语句" class="headerlink" title="执行 INSERT 语句"></a>执行 INSERT 语句</h4><p>通过下面这条<strong>命令</strong>，执行 t.sql 文件中的 INSERT 语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h127.0.0.1 -P13000  -uroot db2 -e &quot;source /client_tmp/t.sql&quot;</span><br></pre></td></tr></table></figure><p>执行流程：</p><ol><li>打 t.sql 开文件，默认以分号为结尾读取逐条 SQL 语句；</li><li>将 SQL 语句发送到服务端执行。</li></ol><h3 id="使用-csv"><a href="#使用-csv" class="headerlink" title="使用 csv"></a>使用 csv</h3><h4 id="导出为-csv-文件"><a href="#导出为-csv-文件" class="headerlink" title="导出为 .csv 文件"></a>导出为 .csv 文件</h4><p>MySQL 提供了下面的 <strong>SQL 语法</strong>，用来将查询结果导出成.csv 文件到服务端本地目录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> ... <span class="keyword">into</span> <span class="keyword">outfile</span> <span class="string">'/server_tmp/t.csv'</span>;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li><p>该语句会将结果保存在服务端。</p><p>如果你执行命令的客户端和 MySQL 服务端不在同一个机器上，客户端机器的临时目录下是不会生成 t.csv 文件的。</p></li><li><p>into outfile 指定了文件的生成位置（/server_tmp/），这个位置必须受参数 secure_file_priv 的限制。参数 secure_file_priv 的可选值是：</p><ul><li>如果设置为 empty，表示不限制文件生成的位置，这是不安全的设置；</li><li>如果设置为一个表示路径的字符串，就要求生成的文件只能放在这个指定的目录，或者它的子目录；</li><li>如果设置为 NULL，就表示禁止在这个 MySQL 实例上执行 select … into outfile 操作。</li></ul></li><li><p>该语句不会帮你覆盖文件。</p><p>你需要确保 /server_tmp/t.csv 这个文件不存在，否则执行语句时就会因为有同名文件的存在而报错。</p></li><li><p>该语句生成的文本文件中，原则上一个数据行对应文本文件的一行。</p><p>如果字段中包含换行符，在生成的文本中也会有换行符。不过类似换行符、制表符这类符号，前面都会跟上“\”这个转义符，这样就可以跟字段之间、数据行之间的分隔符区分开。</p></li></ol><h4 id="将-csv-文件导入目标表"><a href="#将-csv-文件导入目标表" class="headerlink" title="将 .csv 文件导入目标表"></a>将 .csv 文件导入目标表</h4><p>使用 <strong>load data 命令</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load data infile &apos;/server_tmp/t.csv&apos; into table &lt;目标表&gt;;</span><br></pre></td></tr></table></figure><p>执行过程：</p><ol><li><p>打开文件 /server_tmp/t.csv，以制表符 (\t) 作为字段间的分隔符，以换行符（\n）作为记录之间的分隔符，进行数据读取；</p></li><li><p>启动事务。</p></li><li><p>判断每一行的字段数与表 &lt;目标表&gt; 是否相同：</p><ul><li>若不相同，则直接报错，事务回滚；</li><li>若相同，则构造成一行，调用 InnoDB 引擎接口，写入到表中。</li></ul></li><li><p>重复步骤 3，直到 /server_tmp/t.csv 整个文件读入完成，提交事务。</p></li></ol><p>如果 binlog_format=statement，由于 /server_tmp/t.csv 文件只保存在主库所在的主机上，如果只是把 load data 语句原文写到 binlog 中，在备库执行的时候，备库的本地机器上没有这个文件，就会导致主备同步停止。所以，完整流程如下：</p><ol><li>主库执行完成后，将 /server_tmp/t.csv 文件的内容直接写到 binlog 文件中；</li><li>往 binlog 文件中写入语句 load data local infile ‘/tmp/SQL_LOAD_MB-1-0’ INTO TABLE <code>t</code>；</li><li>把这个 binlog 日志传到备库；</li><li>备库的 apply 线程在执行这个事务日志时：<ul><li>先将 binlog 中 t.csv 文件的内容读出来，写入到本地临时目录 /tmp/SQL_LOAD_MB-1-0 中；</li><li>再执行 load data 语句，往备库的 db2.t 表中插入跟主库相同的数据。</li></ul></li></ol><p>备库执行的 load data 语句里多了一个“local”，意为“将执行这条命令的客户端所在机器的本地文件 /tmp/SQL_LOAD_MB-1-0 的内容，加载到目标表 t 中”。</p><p>故，load data 命令有两种用法：</p><ol><li><p>不加“local”</p><p>读取服务端的文件，这个文件必须在 secure_file_priv 指定的目录或子目录下；</p></li><li><p>加上“local”</p><p>读取的是客户端的文件，只要 mysql 客户端有访问这个文件的权限即可。这时候，MySQL 客户端会先把本地文件传给服务端，然后执行上述的 load data 流程。</p></li></ol><h3 id="select-…-into-outfile"><a href="#select-…-into-outfile" class="headerlink" title="select … into outfile"></a>select … into outfile</h3><p>优点：该方法是最灵活的，支持所有的 SQL 写法。</p><p>缺点:每次只能导出一张表的数据，不会生成表结构文件, 所以导数据时还需要单独的命令得到表结构定义。</p><p>mysqldump 提供了一个–tab 参数，可以同时导出表结构定义文件和 csv 数据文件。使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h$host -P$port -u$user ---single-transaction  --set-gtid-purged=OFF db1 t --where=&quot;a&gt;900&quot; --tab=$secure_file_priv</span><br></pre></td></tr></table></figure><p>该命令会在 $secure_file_priv 定义的目录下，创建一个 t.sql 文件保存建表语句，同时创建一个 t.txt 文件保存 CSV 数据。</p><h3 id="物理拷贝"><a href="#物理拷贝" class="headerlink" title="物理拷贝"></a>物理拷贝</h3><h4 id="直接拷贝-frm-和-ibd"><a href="#直接拷贝-frm-和-ibd" class="headerlink" title="直接拷贝 .frm 和 .ibd"></a>直接拷贝 .frm 和 .ibd</h4><p>此法行不通。</p><p>一个 InnoDB 表，除了包含这两个物理文件外，还需要在数据字典中注册。直接拷贝这两个文件的话，因为数据字典中还没有注册这个表，系统是不会识别和接受它们的。</p><h4 id="可传输表空间"><a href="#可传输表空间" class="headerlink" title="可传输表空间"></a>可传输表空间</h4><p>MySQL 5.6 及之后的版本引入了可传输表空间(transportable tablespace) 的方法，可以通过导出 + 导入表空间的方式，实现物理拷贝表的功能。</p><p>假设我们现在的目标是在 db1 库下，复制一个跟表 t 相同的表 r，具体的执行步骤如下：</p><ol><li>执行 <code>create table r like t;</code>，创建一个相同表结构的空表；</li><li>执行 <code>alter table r discard tablespace;</code>，这时候 r.ibd 文件会被删除；</li><li>执行 <code>flush table t for export;</code>，这时候 db1 目录下会生成一个 t.cfg 文件；</li><li>在 db1 目录下执行 <code>cp t.cfg r.cfg;</code>，<code>cp t.ibd r.ibd;</code>；这两个命令（这里需要注意的是，拷贝得到的两个文件，MySQL 进程要有读写权限）；</li><li>执行 <code>unlock tables;</code>，这时候 t.cfg 文件会被删除；</li><li>执行 <code>alter table r import tablespace;</code>，将这个 r.ibd 文件作为表 r 的新的表空间，由于这个文件的数据内容和 t.ibd 是相同的，所以表 r 中就有了和表 t 相同的数据。</li></ol><p>至此，拷贝完毕。</p><p>注意事项：</p><ol><li>在第 3 步执行完 flsuh table 命令之后，db1.t 整个表处于只读状态，直到执行 unlock tables 命令后才释放读锁；</li><li>在执行 import tablespace 的时候，为了让文件里的表空间 id 和数据字典中的一致，会修改 r.ibd 的表空间 id。而这个表空间 id 存在于每一个数据页中。因此，如果是一个很大的文件（比如 TB 级别），每个数据页都需要修改，所以你会看到这个 import 语句的执行是需要一些时间的。当然，如果是相比于逻辑导入的方法，import 语句的耗时是非常短的。</li></ol><h2 id="grant-后-flush-privilege-的问题"><a href="#grant-后-flush-privilege-的问题" class="headerlink" title="grant 后 flush privilege 的问题"></a>grant 后 flush privilege 的问题</h2><p>skip。</p><h2 id="分区表的使用"><a href="#分区表的使用" class="headerlink" title="分区表的使用"></a>分区表的使用</h2><p>skip。</p><h2 id="自增-id-用尽"><a href="#自增-id-用尽" class="headerlink" title="自增 id 用尽"></a>自增 id 用尽</h2><p>skip。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 基础</title>
      <link href="/2020/05/30/mysql-basic/"/>
      <url>/2020/05/30/mysql-basic/</url>
      
        <content type="html"><![CDATA[<p><font color="#008000"> [Updated] </font> 本文整理了 MySQL 基础知识。（基于《SQL基础教程》）</p><a id="more"></a><h1 id="MySQL-基础"><a href="#MySQL-基础" class="headerlink" title="MySQL 基础"></a>MySQL 基础</h1><h2 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h2><h3 id="Server-层"><a href="#Server-层" class="headerlink" title="Server 层"></a>Server 层</h3><p>包括：连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><p>负责跟客户端建立连接、获取权限、维持和管理连接：</p><ul><li><p>建立连接</p><p>客户端连接服务端，完成 TCP 握手后，连接器开始进行用户认证。</p></li><li><p>获取权限</p><p>用户认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。即使用管理员账号对当前连接用户进行权限修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p></li><li><p>连接维持</p><p>连接完成后，如果你没有后续的动作，连接就处于空闲状态（可使用 show processlist 命令察看）。在一定时间（由参数 wait_timeout 控制，默认 8h）内一直处于空闲，连接器会自动断开。</p></li></ul><p>连接类型：</p><ul><li><p>短连接</p><p>每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p></li><li><p>长连接</p><p>连接成功后，如果客户端持续有请求，则一直使用同一个连接。由于建立连接的过程通常是比较复杂的，所以应尽量减少建立连接的动作，即尽量使用长连接。</p></li><li><p>如何解决长连接累积消耗内存导致 OOM？</p><p>MySQL 在执行过程中临时使用的内存资源是管理在连接对象里面的，直至连接断开时才释放，因此长连接累积可能导致 OOM。解决方案：</p><ol><li><p>定期断开长连接</p><p>使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</p></li><li><p>重新初始化连接资源</p><p>MySQL 5.7 之后的版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。该过程无需重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</p></li></ol></li></ul><h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><ul><li><p>不建议使用的原因</p><p>只要对一个表执行更新操作，该表上所有的查询缓存都会被清空。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非业务是静态表，很少更新数据，如：系统配置表。</p></li><li><p>MySQL 8.0 后的版本以移除查询缓存功能。</p></li></ul><h4 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h4><ol><li><p>词法分析</p><p>识别 SQL 语句的成分（关键字、表名、列名、运算符、函数……）.</p></li><li><p>语法分析</p><p>根据语法规则和词法分析的结果生成一颗解析树，通过检查解析树的合法性判断你输入 SQL 是否满足 MySQL 语法。比如：表和列名是否存在，别名歧义等。</p></li></ol><h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><ul><li>在表里面有多个索引的时候，决定使用哪个索引；</li><li>在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</li></ul><h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><ol><li>判断当前连接对操作表的权限；</li><li>打开表，根据表的引擎定义调用引擎借口进行操作（每取一行调用一次引擎接口）。</li></ol><h3 id="引擎层"><a href="#引擎层" class="headerlink" title="引擎层"></a>引擎层</h3><p>负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。</p><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><p>InnoDB 是现在最常用的存储引擎，MySQL 5.5.5 版本开始成为默认存储引擎。<br>InnoDB 基于 B+ 树，采用聚集索引，即索引文件本身就是数据文件。</p><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><p>MyISAM 也是基于 B+ 树，但采用非聚集索引，即索引和实际存储数据分开，其索引指针指向存储实际数据地址。</p><h4 id="InnoDB-和-MyISAM-区别"><a href="#InnoDB-和-MyISAM-区别" class="headerlink" title="InnoDB 和 MyISAM 区别"></a>InnoDB 和 MyISAM 区别</h4><div class="table-container"><table><thead><tr><th></th><th>InnoDB</th><th>MyISAM</th></tr></thead><tbody><tr><td>事务支持</td><td>支持</td><td>不支持</td></tr><tr><td>存储结构</td><td>表结构、数据文件</td><td>表定义文件.frm、数据文件.MYD、索引.MYI</td></tr><tr><td>操作效率</td><td>INSERT、DELETE、UPDATE 更安全更快</td><td>SELECT 更快</td></tr><tr><td>全表行数</td><td>不保存，需要全表扫描</td><td>保存，直接读出；使用 WHERE 需要全表扫描</td></tr><tr><td>索引</td><td>InnoDB 5.6+ 支持全文索引，不支持压缩索引</td><td>支持全文索引、压缩索引</td></tr><tr><td>主键</td><td>无主键时，自动创建自增索引作主键</td><td>允许无任何主键和索引</td></tr><tr><td>外键</td><td>支持</td><td>不支持</td></tr><tr><td>清表操作</td><td>逐行删除</td><td>重建表</td></tr><tr><td>锁支持</td><td>行级锁、表级锁</td><td>只表级锁</td></tr><tr><td>适用场景</td><td>i. 并发，要求可靠性高、事务处理</td><td>i. 查询、插入频繁，修改不频繁</td></tr><tr><td></td><td>ii. 修改频繁</td><td>ii. 常做全表 COUNT</td></tr></tbody></table></div><hr><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务定义"><a href="#事务定义" class="headerlink" title="事务定义"></a>事务定义</h3><ol><li><p>begin/start transaction 和 commit 之间的操作集合是一个事务。<br>【注】begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动</p></li><li><p>没有显式地使用 begin/commit 时，每个 SQL 语句本身就是一个事务，语句完成的时候会自动提交。</p></li></ol><h3 id="事务特性：ACID"><a href="#事务特性：ACID" class="headerlink" title="事务特性：ACID"></a>事务特性：ACID</h3><h4 id="Atomicity-原子性"><a href="#Atomicity-原子性" class="headerlink" title="Atomicity 原子性"></a>Atomicity 原子性</h4><ul><li><p>定义</p><p>事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。</p></li><li><p>实现</p><p><a href="#日志系统">日志</a></p></li></ul><h4 id="Consistency-一致性"><a href="#Consistency-一致性" class="headerlink" title="Consistency 一致性"></a>Consistency 一致性</h4><ul><li><p>定义</p><p>事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。</p></li><li><p>实现</p><ol><li>设置约束和触发器</li><li><a href="#事务隔离">事务隔离</a></li><li><a href="#锁机制">锁机制</a></li></ol></li></ul><h4 id="Isolation-隔离性"><a href="#Isolation-隔离性" class="headerlink" title="Isolation 隔离性"></a>Isolation 隔离性</h4><ul><li><p>定义</p><p>多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。</p></li><li><p>实现</p><p><a href="#事务隔离">事务隔离</a></p></li></ul><h4 id="Durability-持久性"><a href="#Durability-持久性" class="headerlink" title="Durability 持久性"></a>Durability 持久性</h4><ul><li><p>定义</p><p>事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p></li><li><p>实现</p><p><a href="#WAL">WAL（Write-Ahead Logging）</a></p></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>DBMS 采用<a href="#日志系统">日志系统</a>来保证事务的原子性、一致性和持久性。</p><p>日志系统记录了事务对数据库所做的更新，如果某个事务在执行过程中发生错误，就可以根据日志，撤销事务对数据库已做的更新，使数据库退回到执行事务前的初始状态。</p></li><li><p>DBMS 采用<a href="#锁机制">锁机制</a>来实现事务的隔离性。</p><p>当多个事务同时更新数据库中相同的数据时，只允许持有锁的事务能更新该数据，其他事务必须等待，直到前一个事务释放了锁，其他事务才有机会更新该数据。</p></li></ul><hr><h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2><ul><li>key word<ul><li><a href="#redolog">redo log</a></li><li><a href="#binlog">binlog</a></li><li>保证事务的原子性、一致性、持久性</li></ul></li></ul><h3 id="redolog"><a href="#redolog" class="headerlink" title="redolog"></a>redolog</h3><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><p>一个大小固定的循环队列，记录“哪个数据页做了哪些改动”。</p><h4 id="WAL"><a href="#WAL" class="headerlink" title="WAL"></a>WAL</h4><ul><li><p>关键</p><p>Write-Ahead Logging：先写日志，再写磁盘</p></li><li><p>过程</p><ol><li>记录需要更新，先写入 redo log，并在内存更新</li><li>InnoDB 择机（系统空闲时）将更新记录更新到磁盘</li><li>因为 redo log 是固定大小的（类似循环队列），当没有空间存储更新记录时（队满，无法入队），InnoDB 会将 redo log 数据清除一部分（出队）并刷入磁盘</li></ol></li><li><p>作用</p><p>保证 crash-safe：即使数据库发生异常重启，之前提交的记录都不会丢。</p></li></ul><h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><h4 id="两种格式"><a href="#两种格式" class="headerlink" title="两种格式"></a>两种格式</h4><ol><li><p>statement 格式</p><p>记录完整的 sql 语句。</p></li><li><p>row 格式</p><p>记录数据行的内容，包含两部分：更新前、更新后。</p></li></ol><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>binlog 日志只能用于<strong>归档</strong></li><li>只有 binlog 的 MySQL 不具备 crash-safe 能力</li></ul><h4 id="redolog-和-binlog-区别"><a href="#redolog-和-binlog-区别" class="headerlink" title="redolog 和 binlog 区别"></a>redolog 和 binlog 区别</h4><ol><li><p>功能层次</p><ul><li>redo log 是引擎层 InnoDB 引擎特有的</li><li>binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用</li></ul></li><li><p>记录内容</p><ul><li>redo log 是<strong>物理</strong>日志，记录的是“在某个数据页上做了什么修改”</li><li>binlog 是<strong>逻辑</strong>日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”</li></ul></li><li><p>空间大小</p><ul><li>redo log 是<strong>循环写</strong>的，<strong>空间固定</strong>会用完</li><li>binlog 是可以<strong>追加写</strong>入的，即 binlog 文件写到一定大小后会切换到下一个<strong>新文件</strong>，并不会覆盖以前的日志</li></ul></li></ol><h3 id="redo-log-两阶段提交"><a href="#redo-log-两阶段提交" class="headerlink" title="redo log 两阶段提交"></a>redo log 两阶段提交</h3><p>redo log 的写入有两个步骤：prepare 和 commit，即“两阶段提交”。</p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>以 update 语句将某行某字段 c 加 1 为例：</p><ol><li>执行器向引擎取该行数据</li><li>行数据所在数据页存在内存，直接返回给执行器；若不存在，从磁盘取出所在数据页，再向执行器返回</li><li>执行器将值加 1，得到新的行数据，再调用引擎接口写入新的行数据</li><li>引擎将行数据更新到内存，同时将更新操作写入 redo log，此时，redo log 处于 prepare 状态，并告知执行器执行完成，可以提交事务</li><li>执行器生成该更新操作的 binlog，并将其写入磁盘</li><li>执行器调用引擎提交事务借口，将刚写入的 redo log 改成 commit 状态，至此更新完成</li></ol><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑一致。</p><p>不用两阶段提交情况下，假设执行 update 语句某行某字段 c 值由 0 更新为 1 ，过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，可能发生以下错误：</p><ol><li><p>先写 redo log 后写 binlog。</p><p>假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。</p><ol><li><p>redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。</p></li><li><p>但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。</p></li><li><p>如果后期需要用这个 binlog 来恢复临时库的话，由于这个 binlog 丢失该 update 语句，所恢复的临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，异于原库。</p></li></ol></li><li><p>先写 binlog 后写 redo log。</p><ol><li><p>如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。</p></li><li><p>binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。</p></li><li><p>如果后期用这个 binlog 恢复数据时就多了一个更新事务，恢复出来该行 c 的值就是 1，与原库的值不同。</p></li></ol></li></ol><h4 id="数据误删恢复过程"><a href="#数据误删恢复过程" class="headerlink" title="数据误删恢复过程"></a>数据误删恢复过程</h4><ol><li>首先找到最近一次全量备份，从该全量备份恢复到临时库</li><li>从备份时间点开始，将备份的 binlog 依次取出来，重放到误删表之前的那个时刻</li><li>此时临时库就跟误删之前的线上库一样了，再将表数据从临时库取出，按需恢复到线上库即可</li></ol><hr><h2 id="事务隔离"><a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h2><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>MVCC(Mutil-Version Concurrency Control)，即多版本并发控制，在 RDBMS 中实现对数据库的并发访问。 </p><p>在 MySQL 里，有两个“视图”的概念：</p><ol><li><p>视图 view</p><p>view 是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。</p><p>创建视图的语法是 create view … ，其查询方法与表一样。</p></li><li><p>一致性读视图 consistent read view</p><p>InnoDB 在实现 MVCC 时用到的<strong>一致性读视图</strong>，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。</p></li></ol><h4 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h4><p>在可重复读隔离级别下，事务在启动时会拍一个快照，该快照是基于整个库的。<br>基于整个库意味着：一个事务内，整个库的修改对于该事务都是不可见的(对于快照读的情况)。如果在事务内 select 表 t1，另外的事务执行了DDL 表 t1，根据发生时间，要么锁住要么报错。</p><p>InnoDB 利用了<a href="#多版本">“所有数据都有多个版本”</a>的这个特性，实现了“秒级创建快照”的能力。</p><h4 id="多版本"><a href="#多版本" class="headerlink" title="多版本"></a>多版本</h4><ul><li><p>transaction id</p><p>InnoDB 中每个事务都有唯一的事务 ID，即 transaction id，在事务开始的时候向 InnoDB 的事务系统申请，按申请顺序严格递增的。</p></li><li><p>row trx_id</p><p>每行数据都有多个版本。每次事务<strong>更新</strong>数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。</p><p>即将“更新该数据行的事务 ID ”作为“产生该数据行版本的 ID”。</p></li><li><p>版本查看</p><p>数据每次更新会产生 undo log 并且记录当前版本的 row trx_id。通过<strong>当前版本 + undo log</strong> 依次往前计算，可以顺次得到之前的版本。</p></li></ul><h4 id="数据版本的可见性规则"><a href="#数据版本的可见性规则" class="headerlink" title="数据版本的可见性规则"></a>数据版本的可见性规则</h4><p>视图数组和高水位，就组成了当前事务的一致性视图（read-view）：</p><ul><li><p>视图数组</p><p>InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。</p></li><li><p>高低水位 </p><p>数组里面事务 ID 的最小值记为低水位；<br>当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。</p></li></ul><p>基于数据的 row trx_id 和这个一致性视图的对比结果得到数据可见性。对于当前事务的启动瞬间来说，一个数据行的 row trx_id 有以下几种可能：</p><pre><code>[已提交事务|&lt;低水位&gt;|未提交事务集合|&lt;高水位&gt;|未开始事务]</code></pre><ol><li>如果在 “已提交事务” 部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</li><li>如果在 “未开始事务” 部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</li><li>如果在 “未提交事务集合” 部分，那就包括两种情况<ol><li>若 row trx_id 在图数组中，表示这个版本是由还没提交的事务生成的，不可见；</li><li>若 row trx_id 不在视图数组中，表示这个版本是已经提交了的事务生成的，可见。</li></ol></li></ol><h4 id="更新逻辑"><a href="#更新逻辑" class="headerlink" title="更新逻辑"></a>更新逻辑</h4><ul><li><p>“当前读”（current read）</p><p>更新数据都是先读后写的，而这个读，只能读当前（数据行的最新版本）的值，称为“当前读”（current read）。</p></li></ul><p>根据<a href="#两阶段锁">两阶段锁</a>协议，当前事务的当前读必须要读取最新版本，而且必须加锁，所以要等到其他事务更新完毕，当前事务才能完成当前读。</p><p>除了 update 语句外，select 语句如果加锁（lock in share mode 或 for update），也是当前读。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ol><li><p><strong>InnoDB 的行数据有多个版本，每个数据版本有自己的 row trx_id，每个事务或者语句有自己的一致性视图。</strong> 普通查询语句是一致性读，一致性读会根据 row trx_id 和一致性视图确定数据版本的可见性。</p></li><li><p>可重复读实现的核心就是<strong>一致性读（consistent read）</strong>；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</p></li><li><p>读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：</p><ul><li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li><li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li></ul></li><li><p>可见性总结</p><ul><li>对于可重复读，查询只承认在<strong>事务启动前</strong>就已经<strong>提交完成</strong>的数据；</li><li>对于读提交，查询只承认在<strong>语句启动前</strong>就已经<strong>提交完成</strong>的数据；</li><li>对于当前读，总是读取<strong>已提交完成的最新版本</strong>。</li></ul></li></ol><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li><p>为什么表结构不支持“可重复读”？</p><p>因为表结构没有对应的行数据，也没有 row trx_id，因此只能遵循当前读的逻辑。</p></li><li><p>为什么 rr 能实现可重复读而 rc 不能？</p><ol><li>快照读的情况下, rr 不能更新事务内的 up_limit_id（高水位）, 而 rc 每次会把 up_limit_id 更新为快照读之前最新已提交事务的 transaction id,则 rc 不能可重复读</li><li>当前读的情况下, rr 是利用 record lock + gap lock 来实现的，而 rc 没有 gap，所以 rc 不能可重复读</li></ol></li></ul><h3 id="事务执行问题"><a href="#事务执行问题" class="headerlink" title="事务执行问题"></a>事务执行问题</h3><h4 id="脏读（dirty-read）"><a href="#脏读（dirty-read）" class="headerlink" title="脏读（dirty read）"></a>脏读（dirty read）</h4><ul><li><p>关键：读取未提交数据。</p><p>事务 A 读取了事务 B 未提交数据后，事务 B 发生执行错误并进行回滚，那么事务 A 读取数据即为脏数据。</p></li><li><p>解决：读提交、可重复读、串行化。</p></li></ul><h4 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h4><ul><li>关键：更新覆盖。</li></ul><ol><li><p>第一类：</p><p>事务 A 和事务 B 都瞄准了同一数据行，事务 A 回滚时将事务 B 的更新数据覆盖。</p></li></ol><ul><li>解决：可重复读、串行化。</li></ul><ol><li><p>第二类：</p><p>事务 A 和事务 B 都瞄准了同一数据行，并先后执行了更新操作，那么事务 A 的更新数据就有可能被事务 B 覆盖。</p></li></ol><ul><li>解决：悲观锁、乐观锁。</li></ul><h4 id="不可重复读（non-repeatable-read）"><a href="#不可重复读（non-repeatable-read）" class="headerlink" title="不可重复读（non-repeatable read）"></a>不可重复读（non-repeatable read）</h4><ul><li><p>关键：前后多次读取，数据内容不一致。</p><p>事务 A 执行内容较多，在较长的时间间隔先后读取了同一行数据，期间该行数据被其他事务执行了更新操作（insert / update），导致前后读取的数据不一致，无法取到重复的数据。</p></li><li><p>解决：行级锁，锁定该行。</p></li></ul><h4 id="幻读（phantom-read）"><a href="#幻读（phantom-read）" class="headerlink" title="幻读（phantom read）"></a>幻读（phantom read）</h4><ul><li><p>关键：前后多次读取，数据总量不一致。</p><p>事务 A 执行内容较多，在较长的时间间隔先后查询了数据总量，期间其他事务执行了增减数据的操作（insert / update），导致前后统计的数据总量不一样，仿佛产生幻觉。</p></li><li><p>解决：表级锁，锁定整张表。</p></li></ul><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>为解决事务执行过程中可能出现的问题，产生了“隔离级别”的概念。</p><h4 id="读未提交（read-uncommitted）"><a href="#读未提交（read-uncommitted）" class="headerlink" title="读未提交（read uncommitted）"></a>读未提交（read uncommitted）</h4><p>一个事务还未提交，它所做的变更就可以被别的事务看到。</p><h4 id="读提交（read-committed）"><a href="#读提交（read-committed）" class="headerlink" title="读提交（read committed）"></a>读提交（read committed）</h4><p>一个事务提交之后，它所做的变更才可以被别的事务看到。</p><h4 id="可重复读（repeatable-read）"><a href="#可重复读（repeatable-read）" class="headerlink" title="可重复读（repeatable read）"></a>可重复读（repeatable read）</h4><p>一个事务执行过程中看到的数据始终一致，未提交的更改对其他事务是不可见的。</p><h4 id="串行化（serializable）"><a href="#串行化（serializable）" class="headerlink" title="串行化（serializable）"></a>串行化（serializable）</h4><p>对应一个记录会加读写锁，出现冲突的时候，后访问的事务必须等前一个事务执行完成才能继续执行。</p><h4 id="隔离级别程度"><a href="#隔离级别程度" class="headerlink" title="隔离级别程度"></a>隔离级别程度</h4><div class="table-container"><table><thead><tr><th>↓程度递增→</th><th>脏读</th><th>丢失更新</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>读提交</td><td>X</td><td>√</td><td>√</td><td>√</td></tr><tr><td>可重复读</td><td>X</td><td>X</td><td>X</td><td>√</td></tr><tr><td>串行化</td><td>X</td><td>X</td><td>X</td><td>X</td></tr></tbody></table></div><p>注意：</p><ul><li>√ - 允许，X - 禁止</li><li>隔离剂级别越高越安全，但性能越低</li></ul><hr><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><blockquote><p>索引的作用：提高数据查询的效率，类似书的目录</p></blockquote><h3 id="索引常见模型"><a href="#索引常见模型" class="headerlink" title="索引常见模型"></a>索引常见模型</h3><blockquote><p>索引模型是数据库底层存储的核心，有助于理解分析数据库的适用场景</p></blockquote><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><ul><li>特点：键值对</li><li>优点：由哈希算法直接由值得到位置</li><li>缺点：可能发生冲突。冲突键一般用链表解决，退化为普通查询</li><li>适用场景：等值查询</li><li>效率：无冲突O(1);冲突O(n)</li></ul><h4 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h4><ul><li>特点：数据按顺序存储</li><li>优点：查询效率高，等值查询和范围查询皆适用</li><li>缺点：更新效率低</li><li>适用场景：只适用于静态存储引擎</li><li>效率：二分法O(log(N))</li></ul><h3 id="搜索树"><a href="#搜索树" class="headerlink" title="搜索树"></a>搜索树</h3><p>二叉树是树搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树</p><h4 id="不使用二叉树原因"><a href="#不使用二叉树原因" class="headerlink" title="不使用二叉树原因"></a>不使用二叉树原因</h4><p>索引不止存在内存中，还要写到<strong>磁盘</strong>上。对于高为 h 的搜索树，一次查询可能需要访问 h 个数据块，即读 h 次盘。而二叉树的高度往往过高，会导致查询过程中在磁盘读取上消耗过多时间</p><h4 id="为何使用-N-叉树"><a href="#为何使用-N-叉树" class="headerlink" title="为何使用 N 叉树"></a>为何使用 N 叉树</h4><p>为了<strong>查询过程访问尽量少的数据块</strong>，适用 N 叉树降低树高，“N” 取决于数据块的大小</p><p>B+ 树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数，被广泛应用在数据库引擎中</p><h3 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h3><blockquote><p>在 MySQL 中，<strong>索引是在存储引擎层实现的</strong>，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同</p></blockquote><h4 id="索引模型：B-树"><a href="#索引模型：B-树" class="headerlink" title="索引模型：B+树"></a>索引模型：B+树</h4><p>在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表，数据存储在 B+ 树中</p><h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><ul><li><p>主键索引的叶子节点存的是整行数据在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）</p></li><li><p>非主键索引的叶子节点内容是主键的值在 InnoDB 里，非主键索引也被称为二级索引（secondary index）</p></li></ul><h4 id="基于主键索引和普通索引的查询的区别"><a href="#基于主键索引和普通索引的查询的区别" class="headerlink" title="基于主键索引和普通索引的查询的区别"></a>基于主键索引和普通索引的查询的区别</h4><ul><li><p>主键索引只要根据主键值搜索<strong>主键索引树</strong>即可拿到数据</p></li><li><p>普通索引先搜索<strong>索引树</strong>拿到主键值，再到<strong>主键索引树</strong>搜索一次(<strong>回表</strong>)</p></li></ul><p>基于非主键索引的查询需要多扫描一棵<strong>索引树</strong>，故应该<strong>尽量使用主键查询</strong></p><h4 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h4><p>为维护索引有序性，根据 B+ 树模型，一个数据页满了会进行页分裂(新增一个数据页)，导致性能下降，空间利用率降低大概 50%；反之，相邻数据页利用率很低时会进行页合并</p><h4 id="自增索引"><a href="#自增索引" class="headerlink" title="自增索引"></a>自增索引</h4><p>自增主键是指自增列上定义的主键</p><ul><li><p>定义：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NOT NULL PRIMARY KEY AUTO_INCREMENT</span><br></pre></td></tr></table></figure></li><li><p>特点：</p><p>插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值</p></li><li><p>是否应该使用自增索引</p><p>结论：从<strong>性能</strong>和<strong>存储空间</strong>方面考量，自增主键往往是更合理的选择，K-V 场景除外</p></li><li><p>适用场景</p><ul><li><p>性能角度：递增插入。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂；若使用业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高</p></li><li><p>空间角度：主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小</p></li></ul></li><li><p>特殊场景</p><ul><li><p>K-V 场景</p><ol><li>只有一个索引</li><li>该索引必须是唯一索引</li></ol><p>由于没有其他索引，故不用考虑其他索引的空间问题，此时优先考虑“尽量使用主键查询”原则</p></li></ul></li></ul><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>覆盖索引：待查值已在索引树上（即索引树已覆盖查询需求），因此可以直接提供查询结果，而不需要<strong>回表</strong>。使用覆盖索引可以减少树的搜索次数（IO磁盘读写次数），显著提升查询性能</p><h4 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h4><p>B+Tree 这种索引结构，可以利用索引的”最左前缀”来定位记录：可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。</p><ul><li><p>联合索引内的字段顺序安排</p><p>关键：索引的复用能力。</p><p>因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引。因此，第一原则是，若通过调整索引字段顺序可以少维护一个索引，那么该顺序往往就是需要优先考虑采用的。</p></li></ul><h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p><h3 id="普通索引和唯一索引的选择"><a href="#普通索引和唯一索引的选择" class="headerlink" title="普通索引和唯一索引的选择"></a>普通索引和唯一索引的选择</h3><h4 id="从查询语句看"><a href="#从查询语句看" class="headerlink" title="从查询语句看"></a>从查询语句看</h4><ul><li><p>对于普通索引</p><p>查找到第一个满足条件的记录后，继续查找下一个记录，直至碰到第一个不满足条件的记录</p></li><li><p>对于唯一索引</p><p>由于索引定义了唯一性，查找到第一个满足条件的记录即停止检索</p></li></ul><p>因为 InnoDB 的数据是按数据页为单位来读写的，寻找记录时会将记录所在的整个数据页（对于整型字段，一个数据页可以放近千个 key）读取到内存，故普通索引虽然会比唯一索引多出几次寻找和判断，但是对于现在的 CPU 来说计算性能差距微乎其微（记录跨两个数据页的情况除外，发生概率较低）。</p><h4 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h4><p>当需要更新一个数据页：</p><ol><li>数据页在内存中则直接更新</li><li>若数据页不在内存中，为不影响数据一致性，InnoDB 会将更新操作缓存在 change buffer 中，而不会从磁盘中读取所在数据页进行更新</li><li>在下次查询需要访问该数据页的时候，将数据页读入内存，然后执行  change buffer 中与这个页有关的操作，再查询该数据页，以保证数据逻辑的正确性</li></ol><hr><h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><p>根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。</p><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><h4 id="全局锁作用"><a href="#全局锁作用" class="headerlink" title="全局锁作用"></a>全局锁作用</h4><p>对整个数据库实例加锁，使整个数据库处于只读状态，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p><h4 id="加全局读锁命令：FTWRL"><a href="#加全局读锁命令：FTWRL" class="headerlink" title="加全局读锁命令：FTWRL"></a>加全局读锁命令：FTWRL</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flush tables with read lock;</span><br></pre></td></tr></table></figure><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>全库逻辑备份，即“把整库每个表都 select 出来存成文本”。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li><p>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；</p></li><li><p>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。</p></li></ol><h4 id="为何加锁"><a href="#为何加锁" class="headerlink" title="为何加锁"></a>为何加锁</h4><p>不加锁的话，备份系统备份得到的库不是一个逻辑时间点，视图逻辑不一致。</p><h4 id="不建议使用-“set-global-readonly-true”-设置全库只读的原因"><a href="#不建议使用-“set-global-readonly-true”-设置全库只读的原因" class="headerlink" title="不建议使用 “set global readonly=true” 设置全库只读的原因"></a>不建议使用 “set global readonly=true” 设置全库只读的原因</h4><ol><li><p>修改 global 变量的方式影响面更大。</p><p>在有些 DBMS 中，readonly 的值会被用来做其他逻辑，比如判断一个库是主库还是备库。</p></li><li><p>异常处理机制上有差异。</p><p>如果执行 FTWRL 命令之后由于客户端发生异常断开，MySQL 会自动释放全局锁，整个库恢复可以正常更新的状态。</p><p>而将整个库设置为 readonly 之后，如果客户端发生异常，数据库会一直保持 readonly 状态，就会导致整个库长时间处于不可写状态，风险较高。</p></li></ol><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><h4 id="表级锁分类"><a href="#表级锁分类" class="headerlink" title="表级锁分类"></a>表级锁分类</h4><ul><li>表锁</li><li>元数据锁（meta data lock，MDL)</li></ul><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><ul><li><p>作用</p><p>若某线程 “lock tables t1 read, t2 write;”：</p><ul><li>该线程自身只能 “读表 t1、读写 t2”，而不能访问其他表</li><li>其他线程 “写表 t1、读写 t2” 的语句都会被阻塞</li></ul></li><li><p>命令</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 上锁</span><br><span class="line">lock tables … read/write;</span><br><span class="line"></span><br><span class="line">-- 释放锁</span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure></li><li><p>使用场景</p><p>在没有更细粒度的锁的情况下，用于处理并发，如 MyISAM 引擎。而对于拥有更细粒度的行锁 InnoDB 一般使用行锁控制并发，因为行锁的影响面小于表锁。</p></li></ul><h4 id="MDL"><a href="#MDL" class="headerlink" title="MDL"></a>MDL</h4><ul><li><p>作用</p><p>MDL 不需要显式使用，在访问一个表的时候会被自动加上，以保证读写的正确性。</p><p>MySQL 5.5+ 版本引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作（如：加字段）的时候，加 MDL 写锁。</p></li><li><p>特点</p><ul><li><p>读锁之间不互斥</p><p>可以有多个线程同时对一张表增删改查。</p></li><li><p>写锁 与 读/写锁 都互斥</p><p>如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行，以保证变更表结构操作的安全性。</p></li><li><p>事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。</p></li></ul></li><li><p>如何安全地给小表加字段?</p><ol><li><p>解决长事务</p><p>DDL 要变更时有长事务在执行，可以考虑先暂停 DDL，或者 kill 掉这个长事务。</p></li><li><p>在 DDL 语句里面设定等待时间</p><p>在指定的等待时间里拿不到 MDL 写锁，先放弃更高改，后期再进行重试，以免阻塞后面的业务语句。</p></li></ol></li></ul><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><h4 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h4><ul><li><p>定义</p><p>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。</p></li><li><p>建议</p><p>如果事务中需要锁多个行，应该把最可能造成锁冲突、最可能影响并发度的锁尽量在事务中往后放，使行锁的时间最短，以最大程度地减少了事务之间的锁等待，提升了并发度。</p></li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>当并发系统中不同线程出现<strong>循环资源依赖</strong>，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入<strong>无限等待</strong>的状态，称为死锁。</p><h4 id="死锁解决策略"><a href="#死锁解决策略" class="headerlink" title="死锁解决策略"></a>死锁解决策略</h4><ol><li><p>直接进入等待，直到超时。</p><ul><li><p>设置</p><p>超时时间可以通过参数 innodb_lock_wait_timeout 来设置（InnoDB 中默认值是 50s）。</p></li><li><p>缺点</p><ul><li>等待时长过长，影响线上服务效率和用户体验<ul><li>等待时长过短，误伤时间稍长的锁等待</li></ul></li></ul></li></ul></li><li><p>主动死锁检测</p><p>检测发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。</p><ul><li><p>设置</p><p>死锁检测通过将参数 innodb_deadlock_detect 设置为 on 开启。</p></li><li><p>缺点</p><p>死锁检测要耗费大量的 CPU 资源。</p><p>假设有 1000 个并发线程要同时更新同一行，每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，一次检测时间复杂度是 O(n)，那么整体死锁检测操作达到 100 万量级。</p><p>虽然最终检测的结果可能是没有死锁，但是期间要消耗大量的 CPU 资源。则现象为：现虽然 CPU 利用率很高，但是每秒却执行不了几个事务。</p></li><li><p>应对死锁检测缺点的策略</p><ol><li><p>确保业务无死锁的情况下，临时关闭死锁检测</p><p>操作有风险，可能会出现大量超时，导致业务有损；而出现死锁，进行事务回滚，再通过业务重试恢复的过程是业务无损的。</p></li><li><p>控制并发度</p><p>并发度控制在合适的数量级时，死锁检测的成本很低。</p><ul><li><p>客户端并发控制</p><p>客户端数量很多，即使每个客户端都控制在较少的并发线程，汇总到服务端的数量级也很大。因此，并发控制主要做在服务端。</p></li><li><p>服务端并发控制</p></li></ul><p>对于相同行的更新操作进行排队。措施：</p><ol><li>使用中间件（消息队列）</li><li>修改 MySQL 源码（由 server 层进入引擎之前排队）</li></ol></li></ol></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>systemctl 与 service</title>
      <link href="/2019/11/21/systemctl%E4%B8%8Eservice/"/>
      <url>/2019/11/21/systemctl%E4%B8%8Eservice/</url>
      
        <content type="html"><![CDATA[<p><font color="#008000"> [Updated] </font> 本文整理了 systemctl 与 service 的不同。</p><a id="more"></a><h1 id="systemctl-与-service"><a href="#systemctl-与-service" class="headerlink" title="systemctl 与 service"></a>systemctl 与 service</h1><h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><h3 id="service-解析"><a href="#service-解析" class="headerlink" title="service 解析"></a>service 解析</h3><p>通过命令查看 service 命令的脚本内容：</p><pre><code>cat /usr/sbin/service # 通过 “whereis service” 定位脚本位置</code></pre><p>可知，其大致功能是：</p><ol><li>通过 service 命令，传入服务程序名和服务程序所支持的命令（最起码支持 start stop）；</li><li>service 脚本在 /etc/init.d 下找到相应的程序脚本；</li><li>执行相应命令参数的程序脚本。</li></ol><h3 id="service-用法"><a href="#service-用法" class="headerlink" title="service 用法"></a>service 用法</h3><p>通过 man 函数查找 service 命令：</p><pre><code>man service</code></pre><p>命令用法：</p><pre><code>service &lt; option &gt; | --status-all | [ service_name [ command | --full-restart ] ]</code></pre><div class="table-container"><table><thead><tr><th>常用命令</th><th>含义</th></tr></thead><tbody><tr><td>service &lt;服务名&gt; start</td><td>启动服务</td></tr><tr><td>service &lt;服务名&gt; stop</td><td>停止服务</td></tr><tr><td>service &lt;服务名&gt; restart</td><td>重启服务</td></tr></tbody></table></div><h2 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h2><h3 id="systemctl-解析"><a href="#systemctl-解析" class="headerlink" title="systemctl 解析"></a>systemctl 解析</h3><p>CentOS 7 之后，CentOS 使用 systemd 服务管理系统启动和系统服务，具体通过 systemctl 命令来控制。</p><h3 id="systemctl-用法"><a href="#systemctl-用法" class="headerlink" title="systemctl 用法"></a>systemctl 用法</h3><p>用法：</p><pre><code>systemctl [OPTIONS...] COMMAND [NAME...]</code></pre><div class="table-container"><table><thead><tr><th>常用命令</th><th>含义</th></tr></thead><tbody><tr><td>systemctl start &lt;服务名&gt;</td><td>启动服务</td></tr><tr><td>systemctl stop &lt;服务名&gt;</td><td>停止服务</td></tr><tr><td>systemctl restart &lt;服务名&gt;</td><td>重启服务</td></tr><tr><td>systemctl status &lt;服务名&gt;</td><td>查看服务运行状态</td></tr><tr><td>systemctl reload &lt;服务名&gt;</td><td>重载配置文件</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> systemctl </tag>
            
            <tag> service </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 博客从 github 迁至阿里云服务器</title>
      <link href="/2019/11/20/hexo-migration/"/>
      <url>/2019/11/20/hexo-migration/</url>
      
        <content type="html"><![CDATA[<p><font color="#008000"> [Updated] </font>本文记录了 hexo blog 从 github 迁移到阿里云服务器的过程。</p><a id="more"></a><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>国内访问 github 速度较慢且时有抽风，恰逢双十一大促购入阿里云 ESC，尝试迁移至云上。</p><p>以下是云服务器和客户端本机的配置过程。</p><h2 id="云服务器配置过程"><a href="#云服务器配置过程" class="headerlink" title="云服务器配置过程"></a>云服务器配置过程</h2><h3 id="云服务器基本信息"><a href="#云服务器基本信息" class="headerlink" title="云服务器基本信息"></a>云服务器基本信息</h3><ul><li><p>选择系统：</p><p>CentOS 7</p></li><li><p>安全组配置：</p><p>阿里云默认不开放 HTTP（80）端口，故需要在阿里云服务器控制台手动添加安全组规则，授权 HTTP（80）端口的访问，否则将无法访问服务器的 web 应用。</p></li></ul><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>使用 git 配置云服务器代码仓库，创建 git 用户统一管理。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>yum install git</code></pre><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ol><li><p>创建 git 用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 1. 创建 git 用户，并设置密码</span><br><span class="line">sudo adduser git</span><br><span class="line">sudo passwd git</span><br><span class="line"></span><br><span class="line"># 2. 为 git 用户设置权限</span><br><span class="line">chmod 740 /etc/sudoers # 先临时给 sudoers 文件添加写权限，修改完毕后及时收回</span><br><span class="line">vi /etc/sudoers # 添加 “git ALL=(ALL) ALL”</span><br><span class="line">chmod 400 /etc/sudoers</span><br></pre></td></tr></table></figure></li><li><p>配置 ssh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 1. 生成 ssh 秘钥</span><br><span class="line">mkdir ~/.ssh</span><br><span class="line">cd ~/.ssh</span><br><span class="line">ssh-keygen # .ssh 文件夹下会生成 id_rsa 和 id_rsa.pub 文件</span><br><span class="line"></span><br><span class="line"># 2. 设置密钥认证，使客户端可免密连接</span><br><span class="line">vi authorized_keys</span><br><span class="line">&lt;! 文件内输入本地客户端的 ssh 公钥，即本地客户端 ～/.ssh/id_rsa.pub 文件的内容&gt;</span><br><span class="line"></span><br><span class="line"># 3. 设置只有 git 用户对 .ssh 文件有读写权限</span><br><span class="line">chmod 600 ~/.ssh/authorized_keys </span><br><span class="line">chmod 700 ~/.ssh</span><br></pre></td></tr></table></figure></li><li><p>创建 git 仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir repo &amp; cd repo </span><br><span class="line">git init --bare hexoBlog.git</span><br><span class="line">sudo chown -R git:git hexoBlog.git # 递归修改文件用户组</span><br></pre></td></tr></table></figure></li><li><p>设置 hooks</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~/repo/hexoBlog.git/hooks/post-receive</span><br></pre></td></tr></table></figure><p>编辑内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --work-tree=/home/www/blog --git-dir=/home/git/repo/hexoBlog.git checkout -f</span><br></pre></td></tr></table></figure><p>保存退出后，给 post-receive 添加执行权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod u+x ~/repo/hexoBlog.git/hooks/post-receive</span><br></pre></td></tr></table></figure></li></ol><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>本地客户端通过 ssh 连接能够免密登录：</p><pre><code>ssh git@&lt;域名/服务器公网 ip 地址&gt;</code></pre><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><h4 id="Nginx-安装"><a href="#Nginx-安装" class="headerlink" title="Nginx 安装"></a>Nginx 安装</h4><ol><li><p>安装 epel-release，以自动配置 yum 的软件仓库</p><pre><code>sudo yum install -y epel-release</code></pre></li><li><p>安装</p><pre><code> sudo yum install -y Nginx</code></pre></li></ol><h4 id="Nginx-测试"><a href="#Nginx-测试" class="headerlink" title="Nginx 测试"></a>Nginx 测试</h4><ol><li><p>云服务器中，设置开机启动 Nginx：</p><pre><code>sudo systemctl enable nginx</code></pre></li><li><p>使用以下命令启动 Nginx：</p><pre><code>systemctl nginx start</code></pre></li><li><p>查看运行状态：</p><pre><code>sudo systemctl status nginx</code></pre><p>可以看到进程处于活跃状态和其他相关信息。</p></li><li><p>在任意浏览器中，访问云服务器公网 ip，若出现 Nginx 欢迎界面，说明 Nginx 安装成功。若没有出现 Nginx 欢迎界面，首先应排查是否<a href="#云服务器配置">安全组未配置</a>，其次观察是否为端口问题（占用或防火墙），再者可观察安装版本，换源/换版本重装。</p></li></ol><h4 id="Nginx-配置"><a href="#Nginx-配置" class="headerlink" title="Nginx 配置"></a>Nginx 配置</h4><p>注意：因为 yum 源和安装方式不一， Nginx 版本或有不同，配置文件的位置可能会不一样，注意找到对应的文件进行修改。</p><ol><li>查看 nginx.conf 下包含的配置文件路径</li></ol><img src="/2019/11/20/hexo-migration/nginx_conf.png" title="nginx.conf"><p>   找到配置文件文件夹在 “conf.d”（即 include 的目录）。</p><ol><li><p>在 “conf.d” 下创建新配置文件 “hexoBlog.conf”，添加以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">     listen    80; # 监听端口</span><br><span class="line">     server_name &lt;域名/服务器公网 ip 地址&gt;;</span><br><span class="line"></span><br><span class="line">     location / &#123;</span><br><span class="line">         root /home/git/www/hexo; # hexo blog 根目录</span><br><span class="line">         index index.html; # 索引页，与 hexo 生成的静态索引页应同名</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重新加载服务，加载更新后的配置文件：</p><pre><code>systemctl nginx reload</code></pre></li><li><p>此处使用 include 方式增加配置文件原因有二：</p><ol><li>不破坏原有默认配置文件；</li><li>便于以后增删网站配置文件。</li></ol></li></ol><h2 id="本机配置修改"><a href="#本机配置修改" class="headerlink" title="本机配置修改"></a>本机配置修改</h2><h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><p>修改 hexo 目录下的 _config.yml 文件中的 deploy 模块即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@&lt;域名/服务器公网 ip 地址&gt;:/home/git/repo/hexoBlog.git # git 仓库地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><h4 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h4><ol><li><p>新建文章</p><pre><code>hexo new &quot;test&quot;</code></pre></li><li><p>生成静态文件</p><pre><code>hexo clean # 清除缓存文件和已生成的静态文件hexo g -d # 生成静态文件并部署，“hexo generate --deploy”的简写</code></pre></li><li><p>任意客户端通过域名和 ip 进入可看见<a href="#http://47.107.111.47/">博客首页</a>即成功。</p></li></ol><h2 id="Issue-list"><a href="#Issue-list" class="headerlink" title="Issue list"></a>Issue list</h2><ol><li><p>无法访问资源</p><p>403 Forbidden.</p><p>查看 /etc/Nginx/Nginx.conf 文件中的 “user”，是否为博客所在目录所属用户，修正即可。</p><p>若安装 Nginx 时使用 sudo，user 会默认为 root。</p></li><li><p>定位不到博客文件</p><ol><li><p>查看 conf 文件的 root 目录是否设置正确；</p></li><li><p>查看 conf 文件的 index 索引页是否设置正确。</p><p>博客页面由 hexo 静态生成，对照博客目录下静态生成的页面，查看 index 是否设置错误。</p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 云服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Excel 快捷与函数</title>
      <link href="/2019/09/21/Excel%E5%BF%AB%E6%8D%B7%E4%B8%8E%E5%87%BD%E6%95%B0/"/>
      <url>/2019/09/21/Excel%E5%BF%AB%E6%8D%B7%E4%B8%8E%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><font color="#008000"> [Updated] </font> 本文记录了 EXCEL 的高频快捷用法和常用函数</p><a id="more"></a><h1 id="Excel-快捷与函数"><a href="#Excel-快捷与函数" class="headerlink" title="Excel 快捷与函数"></a>Excel 快捷与函数</h1><h2 id="1-快捷"><a href="#1-快捷" class="headerlink" title="1 快捷"></a>1 快捷</h2><h3 id="1-1-常用快捷操作"><a href="#1-1-常用快捷操作" class="headerlink" title="1.1 常用快捷操作"></a>1.1 常用快捷操作</h3><div class="table-container"><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Ctrl+方向键</td><td>跳转至选中方向边缘的数据</td></tr><tr><td>Ctrl+Shift+方向键</td><td>框选当前位置到选中方向边缘的所有数据</td></tr><tr><td>Ctrl+空格键</td><td>框选当前列</td></tr><tr><td>Shift+空格键</td><td>框选当前行</td></tr><tr><td>Ctrl+f</td><td>查找</td></tr><tr><td>Ctrl+h</td><td>替换</td></tr><tr><td>Ctrl+Alt+v</td><td>选择性粘贴</td></tr><tr><td>Ctrl+t</td><td>隔行上色</td></tr></tbody></table></div><h3 id="1-2-自动填充"><a href="#1-2-自动填充" class="headerlink" title="1.2 自动填充"></a>1.2 自动填充</h3><p>自动填充数据和函数：</p><ul><li>选中单元格，瞄准右下角时鼠标变为十字准星，向某一方向框选区域进行自动填充</li><li>选中单元格，瞄准右下角时鼠标变为十字准星，双击自动填充至边缘</li><li>框选区域，输入填充内容，快捷键 Ctrl+Enter 自动填充</li></ul><p>智能填充：</p><ol><li>在第一个单元格手工输入目标值；</li><li>框选填充区域；</li><li>快捷键 Ctrl+E，自动识别填充规则并进行填充。</li></ol><h3 id="1-3-锁定："><a href="#1-3-锁定：" class="headerlink" title="1.3 锁定：$"></a>1.3 锁定：$</h3><p>锁定行或列，常配合自动填充使用。</p><hr><h2 id="2-函数"><a href="#2-函数" class="headerlink" title="2 函数"></a>2 函数</h2><h3 id="2-1-假设函数"><a href="#2-1-假设函数" class="headerlink" title="2.1 假设函数"></a>2.1 假设函数</h3><h4 id="2-1-2-IF"><a href="#2-1-2-IF" class="headerlink" title="2.1.2 IF"></a>2.1.2 IF</h4><p>根据条件进行真假判断，返回真假对应结果：</p><blockquote><p>IF(判断条件, 条件为“真”的返回值， 条件为“假”的返回值)</p></blockquote><p>判断条件可以为：</p><ul><li>单个条件</li><li>AND(条件 1， 条件 2，……)</li><li>OR(条件 1， 条件 2，……)</li></ul><div class="table-container"><table><thead><tr><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>=IF(AND(A1 &gt; 1, A2 &gt; 1), 1, 0)</td><td>A1、A2 都大于 1 则返回 1，否则返回0</td></tr></tbody></table></div><h4 id="2-1-3-COUNT"><a href="#2-1-3-COUNT" class="headerlink" title="2.1.3 COUNT"></a>2.1.3 COUNT</h4><p>计算包含数字的单元格个数以及参数列表中数字的个数:</p><blockquote><p>COUNT(value1, [value2], …)</p></blockquote><div class="table-container"><table><thead><tr><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>=COUNT(A1:A5)</td><td>返回单元格区域 A1 到 A5 中包含数字的单元格的个数</td></tr></tbody></table></div><h4 id="2-1-4-COUNTIFS"><a href="#2-1-4-COUNTIFS" class="headerlink" title="2.1.4 COUNTIFS"></a>2.1.4 COUNTIFS</h4><p>统计满足所有条件的次数：</p><blockquote><p>COUNTIFS(criteria_range1, criteria1, [criteria_range2, criteria2],…)</p></blockquote><div class="table-container"><table><thead><tr><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>=COUNTIFS(A2:A17, “=1”, B2:B17, “&gt;1/1/2010”, C2:C17, “&lt;” &amp; D2)</td><td>返回满足“A=1，B 日期晚于 2010-1-1，C &lt; 单元格 D2 数字”条件的单元格的个数</td></tr></tbody></table></div><h4 id="2-1-5-SUMIF"><a href="#2-1-5-SUMIF" class="headerlink" title="2.1.5 SUMIF"></a>2.1.5 SUMIF</h4><p>对范围中符合指定条件的值求和：</p><blockquote><p>SUMIF(range, criteria, [sum_range])</p></blockquote><div class="table-container"><table><thead><tr><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>=SUMIF(A1:A5, “&gt;100”)</td><td>返回 A1:A5 区域大于 100 的数值之和</td></tr><tr><td>=SUMIF(A1:A5, “=” &amp; C1, B1:B5)</td><td>返回 A1:A5 中等于 C1 对应的 Bi 之和</td></tr></tbody></table></div><h4 id="2-1-6-SUMIFS"><a href="#2-1-6-SUMIFS" class="headerlink" title="2.1.6 SUMIFS"></a>2.1.6 SUMIFS</h4><p>计算满足多个条件的全部参数的总量：</p><blockquote><p>SUMIFS(sum_range, criteria_range1, criteria1, [criteria_range2, criteria2], …)</p></blockquote><div class="table-container"><table><thead><tr><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>=SUMIFS(A1:B5, B1:B5, “=A*”, C1:C5, “B”)</td><td>返回 A1:B5 区域中满足条件“Bi 为 ‘Axx..’ 且 Ci 为 ‘B’” 的 Ai 之和</td></tr></tbody></table></div><h3 id="2-2-数值函数"><a href="#2-2-数值函数" class="headerlink" title="2.2 数值函数"></a>2.2 数值函数</h3><h4 id="2-2-1-SUM"><a href="#2-2-1-SUM" class="headerlink" title="2.2.1 SUM"></a>2.2.1 SUM</h4><p>对选中区域数值求和：</p><blockquote><p>SUM(number1, [number2], …)</p></blockquote><div class="table-container"><table><thead><tr><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>=SUM(A1:B5, D1:F5)</td><td>返回 A1:B5 和 D1:F5 区域值之和</td></tr></tbody></table></div><ul><li>快捷键：Alt+=</li></ul><h4 id="2-2-2-SUMPRODUCT"><a href="#2-2-2-SUMPRODUCT" class="headerlink" title="2.2.2 SUMPRODUCT"></a>2.2.2 SUMPRODUCT</h4><p>返回对应的区域或数组的乘积（默认乘法，还可通过公式指定加、减、除）之和（执行完所有操作，最终操作总为求和）：</p><blockquote><p>SUMPRODUCT(array1, [array2], [array3], …)</p></blockquote><div class="table-container"><table><thead><tr><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>=SUMPRODUCT(A1:A5, B1:B5)</td><td>对 A1:A5, B1:B5 对应乘积求和（常见：加权平均）</td></tr></tbody></table></div><h4 id="2-2-3-ROUND（UP-DOWN）"><a href="#2-2-3-ROUND（UP-DOWN）" class="headerlink" title="2.2.3 ROUND（UP/DOWN）"></a>2.2.3 ROUND（UP/DOWN）</h4><p>对数字按指定位数（向上/向下）四舍五入：</p><blockquote><p>ROUND(number, num_digits)</p></blockquote><ul><li>num_digits 大于 0（零），则将数字四舍五入到指定的小数位数。</li><li>num_digits 等于 0，则将数字四舍五入到最接近的整数。</li><li>num_digits 小于 0，则将数字四舍五入到小数点左边的相应位数。</li></ul><div class="table-container"><table><thead><tr><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>=ROUND(3.14, 1)</td><td>四舍五入到一个小数位，返回 3.1</td></tr><tr><td>=ROUND(13.14, -1)</td><td>四舍五入到小数点左侧一位，返回 10</td></tr></tbody></table></div><h4 id="2-2-4-SUBTOTAL"><a href="#2-2-4-SUBTOTAL" class="headerlink" title="2.2.4 SUBTOTAL"></a>2.2.4 SUBTOTAL</h4><p>返回列表或数据库中的分类汇总：</p><blockquote><p>SUBTOTAL(function_num, ref1, [ref2],…)</p></blockquote><p>其中，function_num 与函数对应表如下：</p><div class="table-container"><table><thead><tr><th>Function_num</th><th>对应函数</th></tr></thead><tbody><tr><td>1    101</td><td>AVERAGE</td></tr><tr><td>2    102</td><td>COUNT</td></tr><tr><td>3    103</td><td>COUNTA</td></tr><tr><td>4    104</td><td>MAX</td></tr><tr><td>5    105</td><td>MIN</td></tr><tr><td>6    106</td><td>PRODUCT</td></tr><tr><td>7    107</td><td>STDEV</td></tr><tr><td>8    108</td><td>STDEVP</td></tr><tr><td>9    109</td><td>SUM</td></tr><tr><td>10    110</td><td>VAR</td></tr><tr><td>11    111</td><td>VARP</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>=SUBTOTAL(9/109, A1:A5)</td><td>对 A1:A5 执行 9/109 代表的函数（求和）</td></tr></tbody></table></div><h4 id="2-2-5-LARGE"><a href="#2-2-5-LARGE" class="headerlink" title="2.2.5 LARGE"></a>2.2.5 LARGE</h4><p>返回数据集中第 k 个最大值：</p><blockquote><p>LARGE(array, k)</p></blockquote><div class="table-container"><table><thead><tr><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>=LARGE(A1:B5, 5)</td><td>返回 A1:B5 区域第 5 大的值</td></tr></tbody></table></div><h3 id="2-3-定位查找函数"><a href="#2-3-定位查找函数" class="headerlink" title="2.3 定位查找函数"></a>2.3 定位查找函数</h3><h4 id="2-3-1-VLOOKUP"><a href="#2-3-1-VLOOKUP" class="headerlink" title="2.3.1 VLOOKUP"></a>2.3.1 VLOOKUP</h4><p>按行查找项目：</p><blockquote><p>VLOOKUP （查阅值、查阅值所在的区域、区域中包含返回值的列号、匹配模式）</p></blockquote><ul><li>查阅值：要查找的值</li><li>查阅值所在的区域：包含查阅值。<strong>查阅值应该始终位于所在区域的第一列</strong></li><li>区域中包含返回值的列号：以 A2:C5 区域为例，A 为第一列，B 为第二列进行计数，依此类推</li><li>匹配模式：近似匹配（TRUE）或完全匹配（FALSE）</li></ul><div class="table-container"><table><thead><tr><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>=VLOOKUP(A1, B1:D5, 2, FALSE)</td><td>在 Bi 列中找到精确等于 A1 的行，返回对应的 Ci（以 B 为首列，C 为第 2 列）</td></tr><tr><td>=IF(VLOOKUP(A1, B1:D5, 2, FALSE)=’C’, ‘找到’, ‘未找到’)</td><td>在 Bi 列中找到精确等于 A1 的行，取出对应的 Ci，若 Ci 为 ‘C’，返回’找到’, 否则返回’未找到’。</td></tr></tbody></table></div><h4 id="2-3-2-LOOKUP"><a href="#2-3-2-LOOKUP" class="headerlink" title="2.3.2 LOOKUP"></a>2.3.2 LOOKUP</h4><p>在单行区域或单列区域（称为“向量”）中查找值，然后返回第二个单行区域或单列区域中相同位置的值：</p><blockquote><p>LOOKUP(lookup_value, lookup_vector, [result_vector])</p></blockquote><ul><li>lookup_value：LOOKUP 在第一个向量中搜索的值，可以是数字、文本、逻辑值、名称或对值的引用</li><li><p>lookup_vector：只包含一行或一列的区域</p><p>注：</p><ul><li>lookup_vector 中的值必须按升序排列：…, -2, -1, 0, 1, 2, …, A-Z, FALSE, TRUE；否则，LOOKUP 可能无法返回正确的值。 文本不区分大小写。</li><li><p>如果 LOOKUP 函数找不到 lookup_value，则该函数会与 lookup_vector 中小于或等于 lookup_value 的最大值进行匹配。</p></li><li><p>如果 lookup_value 小于 lookup_vector 中的最小值，则 LOOKUP 会返回 #N/A 错误值</p></li></ul></li><li>result_vector：只包含一行或一列的区域，与 lookup_vector 大小必须相同</li></ul><div class="table-container"><table><thead><tr><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>=LOOKUP(C1, A1:A5, B1:B5)</td><td>返回 A1:A5 中等于 C1 的行对应的 Bi</td></tr></tbody></table></div><h4 id="2-3-3-MATCH"><a href="#2-3-3-MATCH" class="headerlink" title="2.3.3 MATCH"></a>2.3.3 MATCH</h4><p>在选中单元格中搜索特定的项，然后返回该项在此区域中的相对位置：</p><blockquote><p>MATCH(lookup_value, lookup_array, [match_type])</p></blockquote><div class="table-container"><table><thead><tr><th>Match_type</th><th>说明</th></tr></thead><tbody><tr><td>1 或缺省</td><td>查找小于或等于 lookup_value 的最大值。 lookup_array 参数中的值必须以升序排序</td></tr><tr><td>0</td><td>查找完全等于 lookup_value 的第一个值。 lookup_array 参数中的值可按任何顺序排列</td></tr><tr><td>-1</td><td>查找大于或等于 lookup_value 的最小值。 lookup_array 参数中的值必须按降序排列</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>=MATCH(“b”, {“a”,”b”,”c”}, 0)</td><td>返回 “b” 在 {“a”,”b”,”c”} 中的相对位置</td></tr></tbody></table></div><h4 id="2-3-4-INDEX"><a href="#2-3-4-INDEX" class="headerlink" title="2.3.4 INDEX"></a>2.3.4 INDEX</h4><p>返回表格或区域中的值或值的引用：</p><blockquote><p>INDEX(array, row_num, [column_num])</p></blockquote><ul><li>数组只包含一行或一列：相应的 row_num 或 column_num 参数是可选的</li><li>数组具有多行和多列, 并且仅使用 row_num 或 column_num：返回数组中整个行或列的数组</li><li>同时使用 row_num 和 column_num 参数：返回 row_num 和 column_num 交叉处的单元格中的值。该值必须在数组中，否则将返回 #REF! 错误。</li></ul><div class="table-container"><table><thead><tr><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>=INDEX(A1:B5, 2, 3)</td><td>返回 A1:B5 区域第 2 行第 3 列交叉处的值</td></tr></tbody></table></div><h3 id="2-4-格式函数"><a href="#2-4-格式函数" class="headerlink" title="2.4 格式函数"></a>2.4 格式函数</h3><h4 id="2-4-1-IS"><a href="#2-4-1-IS" class="headerlink" title="2.4.1 IS"></a>2.4.1 IS</h4><p>检验指定值并根据结果返回 TRUE 或 FALSE：</p><blockquote><p>IS**(value)</p></blockquote><div class="table-container"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>ISBLANK</td><td>值为空白单元格</td></tr><tr><td>ISERR</td><td>值为任意错误值（除去 #N/A）</td></tr><tr><td>ISERROR</td><td>值为任意错误值（#N/A、#VALUE!、#REF!、#DIV/0!、#NUM!、#NAME? 或 #NULL!）</td></tr><tr><td>ISLOGICAL</td><td>值为逻辑值</td></tr><tr><td>ISNA</td><td>值为错误值 #N/A（值不存在）</td></tr><tr><td>ISNONTEXT</td><td>值为不是文本的任意项。 （请注意，此函数在值为空单元格时返回 TRUE）</td></tr><tr><td>ISNUMBER</td><td>值为数字</td></tr><tr><td>ISREF</td><td>值为引用</td></tr><tr><td>ISTEXT</td><td>值为文本</td></tr></tbody></table></div><h4 id="2-4-2-LEFT-RIGHT-MID"><a href="#2-4-2-LEFT-RIGHT-MID" class="headerlink" title="2.4.2 LEFT/RIGHT/MID"></a>2.4.2 LEFT/RIGHT/MID</h4><p>文本字符串[从左起 | 从右起 | 字符串中的指定位置]第一个字符开始返回指定个数的字符：</p><blockquote><p>LEFT/RIGHT(text, [num_chars])<br>MID(text, start_num, num_chars)</p></blockquote><div class="table-container"><table><thead><tr><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>=LEFT/RIGHT(A1, 3)</td><td>A1 左/右边第 1 个字符起，返回 3 个字符</td></tr><tr><td>=MID(A1, 3, 5)</td><td>A1 第 3 个字符起，返回 5 个字符</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Excel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL基础速览</title>
      <link href="/2019/07/02/sql/"/>
      <url>/2019/07/02/sql/</url>
      
        <content type="html"><![CDATA[<p><font color="#008000"> [Updated] </font> 本文梳理了 SQL 相关基础知识（基于《SQL基础教程》）</p><a id="more"></a><h1 id="SQL-基础"><a href="#SQL-基础" class="headerlink" title="SQL 基础"></a>SQL 基础</h1><hr><h2 id="SQL-概要"><a href="#SQL-概要" class="headerlink" title="SQL 概要"></a>SQL 概要</h2><h3 id="标准-SQL"><a href="#标准-SQL" class="headerlink" title="标准 SQL"></a>标准 SQL</h3><p>国际标准化组织（ISO）为 SQL 制定的相应标准，适用于各种 RDBMS</p><h3 id="SQL-语句及其种类"><a href="#SQL-语句及其种类" class="headerlink" title="SQL 语句及其种类"></a>SQL 语句及其种类</h3><p>由关键字、表名、列名等组合而成一条 SQL 语句描述操作的内容</p><h4 id="DDL（Data-Definition-Language，数据定义语言）"><a href="#DDL（Data-Definition-Language，数据定义语言）" class="headerlink" title="DDL（Data Definition Language，数据定义语言）"></a>DDL（Data Definition Language，数据定义语言）</h4><p>用来创建或者删除存储数据用的数据库以及数据库中的表等对象。包含指令：</p><ul><li>CREATE： 创建数据库和表等对象</li><li>DROP： 删除数据库和表等对象</li><li>ALTER： 修改数据库和表等对象的结构</li></ul><h4 id="DML（Data-Manipulation-Language，数据操纵语言）"><a href="#DML（Data-Manipulation-Language，数据操纵语言）" class="headerlink" title="DML（Data Manipulation Language，数据操纵语言）"></a>DML（Data Manipulation Language，数据操纵语言）</h4><p>用来查询或者变更表中的记录。包含指令：</p><ul><li>SELECT：查询表中的数据</li><li>INSERT：向表中插入新数据</li><li>UPDATE：更新表中的数据</li><li>DELETE：删除表中的数据</li></ul><h4 id="DCL（Data-Control-Language，数据控制语言）"><a href="#DCL（Data-Control-Language，数据控制语言）" class="headerlink" title="DCL（Data Control Language，数据控制语言）"></a>DCL（Data Control Language，数据控制语言）</h4><p>用来确认或者取消对数据库中的数据进行的变更。除此之外，还可以对 RDBMS 的用户是否有权限<br>操作数据库中的对象（数据库表等）进行设定。包含指令：</p><ul><li>COMMIT： 确认对数据库中的数据进行的变更</li><li>ROLLBACK： 取消对数据库中的数据进行的变更</li><li>GRANT： 赋予用户操作权限</li><li>REVOKE： 取消用户的操作权限</li></ul><h3 id="SQL-的基本书写规则"><a href="#SQL-的基本书写规则" class="headerlink" title="SQL 的基本书写规则"></a>SQL 的基本书写规则</h3><ul><li>以分号（；）结尾</li><li>SQL 不区分关键字大小写；表中数据区分大小写</li><li>SQL 一般书写原则：<ul><li>关键字大写</li><li>表名首字母大写</li><li>其余（列名）小写</li></ul></li><li><strong>SQL 子句的顺序不能改变，也不能互相替换</strong></li></ul><h3 id="表的创建"><a href="#表的创建" class="headerlink" title="表的创建"></a>表的创建</h3><h4 id="数据库的创建（CREATE-DATABASE语句）"><a href="#数据库的创建（CREATE-DATABASE语句）" class="headerlink" title="数据库的创建（CREATE DATABASE语句）"></a>数据库的创建（CREATE DATABASE语句）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> &lt;数据库名&gt;;</span><br></pre></td></tr></table></figure><h4 id="表的创建（CREATE-TABLE语句）"><a href="#表的创建（CREATE-TABLE语句）" class="headerlink" title="表的创建（CREATE TABLE语句）"></a>表的创建（CREATE TABLE语句）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> &lt;表名&gt;</span><br><span class="line">(&lt;列名<span class="number">1</span>&gt; &lt;数据类型&gt; &lt;该列所需约束&gt;,</span><br><span class="line"> &lt;列名<span class="number">2</span>&gt; &lt;数据类型&gt; &lt;该列所需约束&gt;,</span><br><span class="line"> ……</span><br><span class="line"> &lt;列名n&gt; &lt;数据类型&gt; &lt;该列所需约束&gt;,</span><br><span class="line"> &lt;该表约束<span class="number">1</span>&gt;, &lt;该表约束<span class="number">2</span>&gt;, ……);</span><br></pre></td></tr></table></figure><ul><li>NOT NULL 约束只能以列为单位进行设置</li><li>列的数据类型必须指定</li><li>列的约束可以定义时设置，也可以语句末尾设置</li></ul><h4 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h4><ul><li>数据库/表/列名：半角英文字母、数字、下划线(_)</li><li>标准 SQL 中名称必须以半角英文字母开头</li><li>名称不能重复</li></ul><h4 id="数据类型的指定"><a href="#数据类型的指定" class="headerlink" title="数据类型的指定"></a>数据类型的指定</h4><ul><li>INTEGER：整数</li><li>CHAR：定长字符串<ul><li>括号中指定可存储字符串长度</li><li>超出部分无法输入到列中</li><li>不足部分由半角空格进行补足。如：char(10)存”123”，存储字符占10个字节。取数据的时候，char类型的要用trim()去掉多余的空格</li><li>比 VARCHAR 效率高，空间换时间</li></ul></li><li>VARCHAR：可变长字符串<ul><li>括号指定最大长度</li><li>不足部分<strong>不会</strong>使用半角空格进行补足，会自动裁剪。如：varchar(10)存”123”，存储字符占3个字节</li><li>比 CHAR 节省空间</li></ul></li><li>DATE：日期<ul><li>含年/月/日</li><li>Oracle 中 DATE 型还包含时分秒</li></ul></li></ul><h4 id="约束的设置"><a href="#约束的设置" class="headerlink" title="约束的设置"></a>约束的设置</h4><ul><li>键：指定特定数据时使用的列的组合</li><li>主键（primary key）：可以唯一确定一行数据的列（故无法重复）</li></ul><h3 id="表的删除和更新"><a href="#表的删除和更新" class="headerlink" title="表的删除和更新"></a>表的删除和更新</h3><h4 id="表的删除（DROP-TABLE语句）"><a href="#表的删除（DROP-TABLE语句）" class="headerlink" title="表的删除（DROP TABLE语句）"></a>表的删除（DROP TABLE语句）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> &lt;表名&gt;;</span><br></pre></td></tr></table></figure><ul><li>删除表无法回复，只能重建</li><li>避免到需要恢复数据的场景</li></ul><h4 id="表定义的更新（ALTER-TABLE语句）"><a href="#表定义的更新（ALTER-TABLE语句）" class="headerlink" title="表定义的更新（ALTER TABLE语句）"></a>表定义的更新（ALTER TABLE语句）</h4><p>添加列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt; <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> &lt;列的定义&gt;;</span><br></pre></td></tr></table></figure><p>删除列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt; <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> &lt;列名&gt;;</span><br></pre></td></tr></table></figure><ul><li>表定义变更（ALTER TABLE）之后无法恢复</li><li>不同数据库提供不同<strong>变更表名（RENAME）</strong>（非标准 SQL）指令。如：MySQL 中，</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RENAME</span> <span class="keyword">TABLE</span> &lt;原表名&gt; <span class="keyword">to</span> &lt;新表名&gt;;</span><br></pre></td></tr></table></figure><hr><h2 id="查询基础"><a href="#查询基础" class="headerlink" title="查询基础"></a>查询基础</h2><h3 id="SELECT语句基础"><a href="#SELECT语句基础" class="headerlink" title="SELECT语句基础"></a>SELECT语句基础</h3><h4 id="列的查询"><a href="#列的查询" class="headerlink" title="列的查询"></a>列的查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;列名&gt;，……</span><br><span class="line">  <span class="keyword">FROM</span> &lt;表名&gt;；</span><br></pre></td></tr></table></figure><ul><li>&lt; * &gt; 按表定义列的顺序列出所有列</li><li>不建议使用 &lt; * &gt;；建议列出所有列名，以提高 SQL 可读性</li></ul><h4 id="为列或表设定别名"><a href="#为列或表设定别名" class="headerlink" title="为列或表设定别名"></a>为列或表设定别名</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名<span class="number">1</span> <span class="keyword">AS</span> 别名<span class="number">1</span>,</span><br><span class="line">       列名<span class="number">2</span> <span class="keyword">AS</span> 别名<span class="number">2</span></span><br><span class="line">  <span class="keyword">FROM</span> 表名 <span class="keyword">AS</span> 表别名;</span><br></pre></td></tr></table></figure><ul><li>别名可使用中文，使用时将中文用双引号 &lt;” “&gt; 括起来</li><li>别名中空格建议用下划线取代。使用双引号可以设定包含空格的别名，但若忘记使用双引号可能导致错误</li><li>Oracle 的 FROM 子句中不能使用 AS（会发生错误），表别名直接跟在表名后即可（即不加 AS）</li></ul><h4 id="从结果中删除重复行"><a href="#从结果中删除重复行" class="headerlink" title="从结果中删除重复行"></a>从结果中删除重复行</h4><p>使用 DISTINCT 实现删除由<strong>选择列出的列合成的数据</strong>中的重复行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> &lt;列名&gt;, ……</span><br><span class="line">  <span class="keyword">FROM</span> Product;</span><br></pre></td></tr></table></figure><ul><li>使用 DISTINCT 时， NULL 也被视为一类数据（显示为空白）</li><li>DISTINCT 关键字只能用在第一个列名之前</li></ul><h4 id="通过-WHERE-子句来指定查询数据的条件"><a href="#通过-WHERE-子句来指定查询数据的条件" class="headerlink" title="通过 WHERE 子句来指定查询数据的条件"></a>通过 WHERE 子句来指定查询数据的条件</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;列名&gt;, ……</span><br><span class="line">  <span class="keyword">FROM</span> &lt;表名&gt;</span><br><span class="line"> <span class="keyword">WHERE</span> &lt;条件表达式&gt;;</span><br></pre></td></tr></table></figure><ul><li>书写顺序：WHERE 子句必须紧跟在 FROM 子句之后，否则会造成执行错误</li><li>执行顺序：首先通过 WHERE 子句查询出符合指定条件的记录，然后再选取出 SELECT 语句指定的列</li></ul><h4 id="注释的书写方法"><a href="#注释的书写方法" class="headerlink" title="注释的书写方法"></a>注释的书写方法</h4><ul><li>英汉字皆可</li><li>单行注释：书写在 “—“ 之后</li><li>多行注释：书写在 “/“ 和 “/“ 之间</li></ul><h3 id="算术运算符和比较运算符"><a href="#算术运算符和比较运算符" class="headerlink" title="算术运算符和比较运算符"></a>算术运算符和比较运算符</h3><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>SELECT 子句中可以使用<strong>常数</strong>或者<strong>表达式</strong>：+ - * ÷ ()</p><ul><li>所有包含 NULL 的计算，结果肯定是 NULL（包括“NULL/0”的情况，不会报错）</li><li><p>FROM 子句在 SELECT 语句中并不是必不可少的，只使用SELECT子句进<br>行计算也是可以的，但使用场景很少。如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> (<span class="number">1</span> + <span class="number">2</span>) * <span class="number">3</span> <span class="keyword">AS</span> calculation;</span><br></pre></td></tr></table></figure></li><li><p>存在不允许省略 SELECT 语句中的 FROM 子句的 RDBMS。如：Oracle</p></li></ul><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><ul><li>=、&lt;、&gt;：等于、小于、大于</li><li>&lt;&gt;:不相等。“!=” 非标准 SQL，考虑可移植性和安全问题 , 不建议使用</li><li>&lt;=、&gt;=：不大于、不小于。必须不等号在左，等号在右</li><li>字符串类型的数据原则上按照<strong>字典顺序</strong>进行排序。该规则对定长字符串和可变长字符串都适用</li><li>SQL 用“IS NULL”和“IS NOT NULL”判断数据是否为NULL。因为SQL 不识别“= NULL”和“&lt;&gt; NULL”，所以不能对 NULL 使用比较运算符</li></ul><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><h4 id="NOT运算符"><a href="#NOT运算符" class="headerlink" title="NOT运算符"></a>NOT运算符</h4><ul><li>NOT 不能单独使用，必须组合其他查询条件表“不是该条件”</li><li>为保持程序清晰可读，不滥用 NOT</li></ul><h4 id="AND-运算符和-OR-运算符"><a href="#AND-运算符和-OR-运算符" class="headerlink" title="AND 运算符和 OR 运算符"></a>AND 运算符和 OR 运算符</h4><ul><li>AND 运算符在其两侧的查询条件都成立时整个查询条件才成立，其<br>意思相当于“并且”</li><li>OR 运算符在其两侧的查询条件有一个成立时整个查询条件都成立，<br>其意思相当于“或者”</li><li>AND 运算符的优先级高于 OR 运算符</li><li>建议使用括号强化优先级，使语句更清晰可读</li></ul><h4 id="真值"><a href="#真值" class="headerlink" title="真值"></a>真值</h4><ul><li>真值：值为真（TRUE） 或假（FALSE） 其中之一的值</li><li>AND 运算的结果与乘法运算（积）的结果一样，称逻辑积</li><li>OR 运算的结果与加法运算（和）的结果一样，称逻辑和</li><li>SQL 特有情况 — 三值逻辑：除真值外，还存在“不确定”（UNKNOWN）这样的值：<br>P | Q |P AND Q|P OR Q|<br>-|-|-|-<br>真|不确定|不确定|真<br>假|不确定|假|不确定<br>不确定|真|不确定|真<br>不确定|假|假|不确定<br>不确定|不确定|不确定|不确定</li><li>建议尽量不使用 NULL，为列设置 NOT NULL 约束，以避免繁琐的条件判断</li></ul><hr><h2 id="聚合与排序"><a href="#聚合与排序" class="headerlink" title="聚合与排序"></a>聚合与排序</h2><h3 id="对表进行聚合查询"><a href="#对表进行聚合查询" class="headerlink" title="对表进行聚合查询"></a>对表进行聚合查询</h3><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><p>将多行输入汇总为一行输出</p><ul><li>COUNT： 计算表中的记录数（行数）<ul><li>COUNT(<em>) 特性：不会排除 NULL。故 COUNT(</em>)会得到包含 NULL 的数据行数，而 COUNT(&lt;列名&gt;) 会得到 NULL 之外的数据行数</li></ul></li><li>所有的聚合函数，如果以列名为参数，那么在计算之前会把 NULL 排除在外，<strong>与“等价为 0”并不相同</strong></li><li>SUM： 计算表中 <strong>数值列</strong> 中数据的合计值</li><li>AVG： 计算表中 <strong>数值列</strong> 中数据的平均值<ul><li>会事先删除 NULL 同时减少相应数据条数再计算。但也可以选择将 NULL 改变为 0 进行计算</li></ul></li><li>MAX： 求出表中 <strong>任意列（如日期）</strong> 中数据的最大值</li><li>MIN： 求出表中 <strong>任意列（如日期）</strong>中 数据的最小值</li></ul><h4 id="使用聚合函数删除重复值（关键字DISTINCT）"><a href="#使用聚合函数删除重复值（关键字DISTINCT）" class="headerlink" title="使用聚合函数删除重复值（关键字DISTINCT）"></a>使用聚合函数删除重复值（关键字DISTINCT）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> &lt;列名&gt;)</span><br><span class="line">  <span class="keyword">FROM</span> &lt;表名&gt;;</span><br></pre></td></tr></table></figure><ul><li>DISTINCT 必须写在聚合函数参数（即括号）中，因为必须要在执行之前删除列中的重复数据</li><li>计算值的种类：在 COUNT() 的参数中使用 DISTINCT</li></ul><h3 id="对表进行分组"><a href="#对表进行分组" class="headerlink" title="对表进行分组"></a>对表进行分组</h3><h4 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;列名<span class="number">1</span>&gt;, &lt;列名<span class="number">2</span>&gt;, &lt;列名<span class="number">3</span>&gt;, ……</span><br><span class="line">  <span class="keyword">FROM</span> &lt;表名&gt;</span><br><span class="line"> <span class="keyword">WHERE</span></span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;列名<span class="number">1</span>&gt;, &lt;列名<span class="number">2</span>&gt;, &lt;列名<span class="number">3</span>&gt;, ……;</span><br></pre></td></tr></table></figure><ul><li>聚合键/分组列：GROUP BY 子句中指定的列</li><li>书写顺序：SELECT → FROM → WHERE → GROUP BY</li><li>执行顺序：FROM → WHERE → GROUP BY → SELECT</li><li>聚合键中包含 NULL 时，在结果中会以“不确定”行（空行）的形式表现出来</li></ul><h3 id="使用聚合函数和-GROUP-BY-注意事项"><a href="#使用聚合函数和-GROUP-BY-注意事项" class="headerlink" title="使用聚合函数和 GROUP BY 注意事项"></a>使用聚合函数和 GROUP BY 注意事项</h3><ul><li>使用聚合函数时， SELECT 子句中<strong>只能</strong>存在以下三种元素：<ul><li>常数</li><li>聚合函数</li><li>GROUP BY 子句中指定的列名（也就是聚合键）</li></ul></li><li>虽然 MySQL 支持使用GROUP BY子句时， SELECT 子句中出现聚合键之外的列名，但是 MySQL 以外的 DBMS 都不支持这样的语法，因此不建议使用</li><li>在 GROUP BY子 句中不能使用 SELECT 子句中定义的别名。根据执行顺序，执行 GROUP BY 子句时，DBMS 还不知道 SELECT 子句中定义的别名</li><li>GROUP BY子句结果的显示是无序的。可在 SELECT 语句中进行指定特定顺序</li><li>只有 SELECT 子句和 HAVING 子句（以及 ORDER BY 子句）中能够使用聚合函数</li><li>DISTINCT 和 GROUP BY：都是通过数据的内部排序处理实现的（执行速度相近），可删除重复数据。根据使用场景，选择能清晰表明语义的写法</li></ul><h3 id="为聚合结果指定条件"><a href="#为聚合结果指定条件" class="headerlink" title="为聚合结果指定条件"></a>为聚合结果指定条件</h3><h4 id="HAVING-子句"><a href="#HAVING-子句" class="headerlink" title="HAVING 子句"></a>HAVING 子句</h4><p>WHERE 子句只能指定记录（行）的条件，而不能用来指定组的条件。对集合指定条件使用 HAVING 子句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;列名<span class="number">1</span>&gt;, &lt;列名<span class="number">2</span>&gt;, &lt;列名<span class="number">3</span>&gt;, ……</span><br><span class="line">  <span class="keyword">FROM</span> &lt;表名&gt;</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;列名<span class="number">1</span>&gt;, &lt;列名<span class="number">2</span>&gt;, &lt;列名<span class="number">3</span>&gt;, ……</span><br><span class="line"><span class="keyword">HAVING</span> &lt;分组结果对应的条件&gt;</span><br></pre></td></tr></table></figure><ul><li>书写顺序：SELECT → FROM → WHERE → GROUP BY → HAVING</li><li>执行顺序：FROM → WHERE → GROUP BY → SELECT</li></ul><h4 id="HAVING-注意事项"><a href="#HAVING-注意事项" class="headerlink" title="HAVING 注意事项"></a>HAVING 注意事项</h4><ul><li>HAVING 子句中<strong>只能</strong>存在以下三种元素：<ul><li>常数</li><li>聚合函数</li><li>GROUP BY 子句中指定的列名（即聚合键）</li></ul></li><li>聚合键所对应的条件应该书写在 WHERE 子句当中，而不应该书写在 HAVING 子句当中。理由如下：<ul><li>HAVING 子句是用来指定“组”的条件的。因此，“行”所对应的条件还是应该写在 WHERE 子句当中，便于理解区分功能</li><li>通常情况下，为了得到相同的结果，将条件写在 WHERE 子句中要比写在 HAVING 子句中的处理速度更快，返回结果所需的时间更短<blockquote><p>为了理解其中原因，就要从 DBMS 的内部运行机制来考虑。使用 COUNT 函<br>数等对表中的数据进行聚合操作时，DBMS 内部就会进行排序处理。排序处理是会大大增加机器负担的高负荷的处理 A。因此，只有尽可能减少排序的行数，才能提高处理速度。通过 WHERE 子句指定条件时，由于排序之前就对数据进行了过滤，因此能够减少排序的数据量。但 HAVING 子句是在排序之后才对数据进行分的，因此与在 WHERE 子句中指定条件比起来，需要排序的数据量就会多得多。虽然 DBMS 的内部处理不尽相同，但是对于排序处理来说，基本上都是一样的。此外， WHERE 子句更具速度优势的另一个理由是，可以对 WHERE 子句指定条件所对应的列创建索引，这样也可以大幅提高处理速度。创建索引是一种非常普遍的提高 DBMS 性能的方法，效果也十分明显，这对 WHERE 子句来说也十分有利。</p></blockquote></li></ul></li></ul><h3 id="对查询结果进行排序"><a href="#对查询结果进行排序" class="headerlink" title="对查询结果进行排序"></a>对查询结果进行排序</h3><h4 id="ORDER-BY子句"><a href="#ORDER-BY子句" class="headerlink" title="ORDER BY子句"></a>ORDER BY子句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;列名<span class="number">1</span>&gt;, &lt;列名<span class="number">2</span>&gt;, &lt;列名<span class="number">3</span>&gt;, ……</span><br><span class="line">  <span class="keyword">FROM</span> &lt;表名&gt;</span><br><span class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;排序基准列<span class="number">1</span>&gt;, &lt;排序基准列<span class="number">2</span>&gt;, ……;</span><br></pre></td></tr></table></figure><ul><li>书写顺序：SELECT → FROM → WHERE → GROUP BY → HAVING → ORDER BY</li><li>ORDER BY 子句通常写在 SELECT 语句的<strong>末尾</strong></li><li>未指定 ORDER BY子句中排列顺序时会默认使用升序进行排列；使用 DESC 关键字降序排列</li></ul><h4 id="ORDER-BY-注意事项"><a href="#ORDER-BY-注意事项" class="headerlink" title="ORDER BY 注意事项"></a>ORDER BY 注意事项</h4><ul><li>多键排序规则：优先使用左侧的键，如果该列存在相同值的话，再接着参考右侧的键</li><li>排序键中包含 NULL 时，会在开头或末尾进行汇总（因为不能对 NULL 使用比较运算符）</li><li>在 ORDER BY 子句中可以使用 SELECT 子句中定义的别名。因为 <strong>SELECT 子句的执行顺序在 GROUP BY 子句之后， ORDER BY 子句之前</strong></li><li>在 ORDER BY 子句中可以使用 SELECT 子句中未使用的列和聚合函数</li><li>不要使用列编号指定排序键：<ul><li>可读性差</li><li>SQL-92A 中明确该功能将来会被删除<blockquote><p>列编号 — SELECT 子句中的列按照从左到右的顺序进行排列时所对应的编号（1, 2, 3, …）</p></blockquote></li></ul></li></ul><hr><h2 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h2><h3 id="数据的插入（INSERT语句的使用方法）"><a href="#数据的插入（INSERT语句的使用方法）" class="headerlink" title="数据的插入（INSERT语句的使用方法）"></a>数据的插入（INSERT语句的使用方法）</h3><h4 id="INSERT-语句"><a href="#INSERT-语句" class="headerlink" title="INSERT 语句"></a>INSERT 语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> &lt;表名&gt; (列<span class="number">1</span>, 列<span class="number">2</span>, 列<span class="number">3</span>, ……) <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, 值<span class="number">3</span>, ……);</span><br></pre></td></tr></table></figure><ul><li>原则上，执行一次INSERT语句会插入一行数据,表名后面的列清单和 VALUES 子句中的值清单的列数必须保持一致</li><li><p>很多 RDBMS 都支持多行 INSERT：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> &lt;表名&gt; (列<span class="number">1</span>, 列<span class="number">2</span>, 列<span class="number">3</span>, ……) <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, 值<span class="number">3</span>, ……), (值<span class="number">1</span>, 值<span class="number">2</span>, 值<span class="number">3</span>, ……) …… ;</span><br></pre></td></tr></table></figure></li><li><p>列清单的省略</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> &lt;表名&gt; <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, 值<span class="number">3</span>, ……), (值<span class="number">1</span>, 值<span class="number">2</span>, 值<span class="number">3</span>, ……) …… ;</span><br></pre></td></tr></table></figure></li><li><p>插入NULL：插入 NOT NULL 约束的列会报错</p></li><li>INSERT， DELETE 和 UPDATE 等更新语句也一样，SQL 语句执行失败时都不会对表中数据造成影响</li><li><p>默认插入值<br>在创建表的 CREATE TABLE 语句中设置 DEFAULT 约束来设定默认值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ProductIns</span><br><span class="line">(&lt;列名&gt; <span class="built_in">CHAR</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"> &lt;列名&gt; <span class="built_in">INTEGER</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>, <span class="comment">-- 销售单价的默认值设定为0;</span></span><br><span class="line">……);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>显式方法插入默认值：在 VALUES 中指定 DEFAULT 关键字</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> &lt;表名&gt; (&lt;列名<span class="number">1</span>&gt;, &lt;列名<span class="number">2</span>&gt;, ……) <span class="keyword">VALUES</span> (<span class="keyword">DEFAULT</span>, <span class="keyword">DEFAULT</span>, ……);</span><br></pre></td></tr></table></figure></li><li><p>隐式方法插入默认值：在列清单和 VALUES 中省略要设定默认值的列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> &lt;表名&gt; (&lt;列名<span class="number">1</span>&gt;, &lt;列名<span class="number">3</span>&gt;, ……) <span class="keyword">VALUES</span> (<span class="keyword">DEFAULT</span>, <span class="keyword">DEFAULT</span>, ……); <span class="comment">-- 列2设定默认值</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="从其他表中复制数据"><a href="#从其他表中复制数据" class="headerlink" title="从其他表中复制数据"></a>从其他表中复制数据</h4><ol><li>创建一张结构一样的表</li><li><p>旧表数据插入新表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 旧表 (&lt;列名<span class="number">1</span>&gt;, &lt;列名<span class="number">2</span>&gt;, ……)</span><br><span class="line"><span class="keyword">SELECT</span> &lt;列名<span class="number">1</span>&gt;, &lt;列名<span class="number">2</span>&gt;, ……</span><br><span class="line"><span class="keyword">FROM</span> 新表;</span><br></pre></td></tr></table></figure></li></ol><ul><li>INSERT 语句的 SELECT 语句中，可以使用 WHERE 子句或者 GROUP BY 子句等何 SQL 语法（除 ORDER BY）</li><li>指定 ORDER BY 子句也没有任何意义，因为无法保证表内部记录的排列顺序</li></ul><h3 id="数据的删除（DELETE语句的使用方法）"><a href="#数据的删除（DELETE语句的使用方法）" class="headerlink" title="数据的删除（DELETE语句的使用方法）"></a>数据的删除（DELETE语句的使用方法）</h3><h4 id="DELETE语句"><a href="#DELETE语句" class="headerlink" title="DELETE语句"></a>DELETE语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> &lt;表名&gt;; <span class="comment">-- 保留数据表，清空表全部数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> &lt;表名&gt; <span class="comment">-- 删除表中指定条件数据</span></span><br><span class="line"> <span class="keyword">WHERE</span> &lt;条件&gt;;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>DELETE 语句中只能使用 WHERE，而不能使用 GROUP BY、HAVING 和 ORDER BY。因为：<ul><li>GROUP BY 和 HAVING 是从表中选取数据时用来改变抽取数据形式的</li><li>ORDER BY 是用来指定取得结果显示顺序的</li></ul></li></ul><h4 id="TRUNCATE：删除表中全部数据"><a href="#TRUNCATE：删除表中全部数据" class="headerlink" title="TRUNCATE：删除表中全部数据"></a>TRUNCATE：删除表中全部数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> &lt;表名&gt;;</span><br></pre></td></tr></table></figure><ul><li>非标准SQL；Oracle、SQL Server、PostgreSQL、MySQL 和 DB2</li><li>不能通过 WHERE 子句指定条件来删除部分数据</li></ul><h3 id="数据的更新（UPDATE语句的使用方法）"><a href="#数据的更新（UPDATE语句的使用方法）" class="headerlink" title="数据的更新（UPDATE语句的使用方法）"></a>数据的更新（UPDATE语句的使用方法）</h3><h4 id="UPDATE-语句"><a href="#UPDATE-语句" class="headerlink" title="UPDATE 语句"></a>UPDATE 语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> &lt;表名&gt;</span><br><span class="line">   <span class="keyword">SET</span> &lt;列名&gt; = &lt;表达式/<span class="literal">NULL</span>&gt; <span class="comment">-- NULL 只限于未设置 NOT NULL 约束的列</span></span><br><span class="line"> <span class="keyword">WHERE</span> &lt;条件&gt;;</span><br></pre></td></tr></table></figure><h4 id="多列更新"><a href="#多列更新" class="headerlink" title="多列更新"></a>多列更新</h4><ul><li>法一：所有 DBMS 通用</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用逗号对列进行分隔排列</span></span><br><span class="line"><span class="keyword">UPDATE</span> &lt;表名&gt;</span><br><span class="line">   <span class="keyword">SET</span> &lt;列名<span class="number">1</span>&gt; = &lt;表达式<span class="number">1</span>&gt;,</span><br><span class="line">       &lt;列名<span class="number">2</span>&gt; = &lt;表达式<span class="number">2</span>&gt;</span><br><span class="line"> <span class="keyword">WHERE</span> &lt;条件&gt;;</span><br></pre></td></tr></table></figure><ul><li>法二：非通用</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将列用()括起来的清单形式</span></span><br><span class="line"><span class="keyword">UPDATE</span> Product</span><br><span class="line">   <span class="keyword">SET</span> (列名<span class="number">1</span>, 列名<span class="number">2</span>) = (表达式<span class="number">1</span>, 表达式<span class="number">2</span>)</span><br><span class="line"> <span class="keyword">WHERE</span> &lt;条件&gt;;</span><br></pre></td></tr></table></figure><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h4><p>需要在同一个处理单元中执行的一系列更新处理的集合。例如：</p><blockquote><p>现要求完成往表1插入新数据并更新一些旧数据的任务。要完成该任务，插入和更新两种操作都要完成，则一定要使用事务进行处理（将一起要完成的操作打包进一个事务中进行处理）</p></blockquote><h4 id="创建事务"><a href="#创建事务" class="headerlink" title="创建事务"></a>创建事务</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">事务开始语句;</span><br><span class="line">DML语句①;</span><br><span class="line">DML语句②;</span><br><span class="line">……</span><br><span class="line">事务结束语句（ <span class="keyword">COMMIT</span>或者<span class="keyword">ROLLBACK</span>） ;</span><br></pre></td></tr></table></figure><ul><li><p>在标准 SQL 中并没有定义事务的<strong>开始语句</strong>，而是由各个 DBMS 自己来定义的</p><ul><li>SQL Server、PostgreSQL：<blockquote><p>BEGIN TRANSACTIONBEGIN TRANSACTION</p></blockquote></li><li>MySQL：<blockquote><p>START TRANSACTION</p></blockquote></li><li>Oracle、DB2：无</li></ul><p>实际上，几乎所有的数据库产品的事务都无需开始指令。因为大部分情况下，事务在数据库连接建立时就已经开始，并不需要用户再明确发出开始指令</p></li><li><p>事务<strong>结束语句</strong>在所有的 RDBMS 中都是通用，只有 COMMIT 和 ROLLBACK 两种：</p><ul><li>COMMIT — 是提交事务包含的全部更新处理的结束指令，相当于文件处理中的覆盖保存。一旦提交，就无法恢复到事务开始前的状态了</li><li>ROLLBACK — 是取消事务包含的全部更新处理的结束指令，相当于文件处理中的放弃保存。一旦回滚，数据库就会恢复到事务开始之前的状态</li></ul></li><li><p>在不使用指令而悄悄开始事务的情况下，区分各个事务有以下两种模式（通常 DBMS 都可以设置任选其一）：</p><ul><li>自动提交模式 — 每条SQL语句就是一个事务（MySQL、SQL Server 和 PostgreSQL 默认使用）</li><li>直到用户执行 COMMIT 或者 ROLLBACK 为止算作一个事务（Oracle 默认使用）</li></ul></li><li><p>若使用 DELETE 语句删除了数据表：</p><ul><li>自动提交模式下，无法回滚恢复</li><li>非自动提交模式下，可以通过 ROLLBACK 命令取消该事务的处理，恢复表中的数据。但这仅限于明示开始事务，或者关闭自动提交的情况</li></ul></li></ul><h4 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h4><ul><li><p>原子性（Atomicity）</p><p>原子性是指在事务结束时，其中所包含的更新处理要么都执行，要么都不执行</p></li><li><p>一致性（Consistency）/完整性</p><p>一致性指的是事务中包含的处理要满足数据库提前设置的约束</p></li><li><p>隔离性（Isolation）</p><p>隔离性指的是保证不同事务之间互不干扰的特性。该特性保证了事务之间不会互相嵌套。此外，在某个事务中进行的更改，在该事务结束之前，对其他事务而言是不可见的</p></li><li><p>持久性（Durability）</p><p>持久性指的是在事务（不论是提交还是回滚）结束后， DBMS 能够保证该时间点的数据状态会被保存的特性。即使由于系统故障导致数据丢失，数据库也一定能通过某种手段进行恢复，如日志系统</p></li></ul><hr><h2 id="复杂查询"><a href="#复杂查询" class="headerlink" title="复杂查询"></a>复杂查询</h2><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><h4 id="视图：保存好的-SELECT-语句"><a href="#视图：保存好的-SELECT-语句" class="headerlink" title="视图：保存好的 SELECT 语句"></a>视图：保存好的 SELECT 语句</h4><ul><li>视图和表区别：表中存储的是实际数据，而视图中保存的是从表中取出数据所使用的SELECT语句</li><li>视图的优点：<ul><li>无需保存数据，节省存储设备的容量</li><li>将频繁使用的 SELECT 语句保存成视图，不用重写重新执行，以提高效率</li></ul></li></ul><h4 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称(&lt;视图列名<span class="number">1</span>&gt;, &lt;视图列名<span class="number">2</span>&gt;, ……)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">&lt;<span class="keyword">SELECT</span>语句&gt;</span><br></pre></td></tr></table></figure><ul><li>SELECT 语句中列的排列顺序和视图中列的排列顺序相同</li><li>多重视图：以视图为基础创建视图。多重视图会降低 SQL 的性能应尽量避免</li></ul><h4 id="使用视图查询"><a href="#使用视图查询" class="headerlink" title="使用视图查询"></a>使用视图查询</h4><ol><li>首先执行定义视图的 SELECT 语句</li><li>根据得到的结果，再执行在 FROM 子句中使用视图的 SELECT 语句</li></ol><h4 id="视图的限制"><a href="#视图的限制" class="headerlink" title="视图的限制"></a>视图的限制</h4><ul><li><p>定义视图时不能使用 ORDER BY 子句</p><p>视图和表一样， 数据行都是没有顺序的</p></li><li><p>对视图进行更新</p><p>标准 SQL 中规定，想要视图可以被更新，定义视图的 SELECT 语句需要满足某些条件（非通过汇总）：</p><ul><li>SELECT 子句中未使用 DISTINCT</li><li>FROM 子句中只有一张表</li><li>未使用 GROUP BY 子句</li><li>未使用 HAVING 子句</li></ul><p>原因：视图和表需要同时进行更新，以保持数据一致性，因此通过汇总得到的视图无法进行更新</p></li></ul><h4 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> 视图名称(&lt;视图列名<span class="number">1</span>&gt;, &lt;视图列名<span class="number">2</span>&gt;, ……)；</span><br></pre></td></tr></table></figure><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><h4 id="子查询和视图"><a href="#子查询和视图" class="headerlink" title="子查询和视图"></a>子查询和视图</h4><p>子查询就是将用来定义视图的 SELECT 语句直接用于 FROM 子句当中（为查询结果命别名）</p><ul><li>子查询作为内层查询会首先执行</li><li>原则上子查询必须设定名称（使用 AS 关键字）</li></ul><h4 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h4><p>标量子查询就是返回单一值的子查询</p><ul><li>优点：返回的是单一值，可以用在 = 或者 &lt;&gt; 等比较运算符之中</li><li>书写位置：能够使用常数或者列名的地方</li><li>注意事项：子查询中只能返回单一值</li></ul><h3 id="关联子查询（建议刷题理解）"><a href="#关联子查询（建议刷题理解）" class="headerlink" title="关联子查询（建议刷题理解）"></a>关联子查询（建议刷题理解）</h3><h4 id="与普通的子查询的区别"><a href="#与普通的子查询的区别" class="headerlink" title="与普通的子查询的区别"></a>与普通的子查询的区别</h4><p>在子查询中添加的 WHERE 子句的条件</p><ul><li>为区别表对应不同的场景，在表所对应的列名之前加上表的别名，形式为“&lt;表名&gt;.&lt;列名&gt;”</li><li>适合在细分的组内进行比较时使用</li><li>结合条件一定要写在子查询中</li></ul><hr><h2 id="函数、谓词、CASE表达式"><a href="#函数、谓词、CASE表达式" class="headerlink" title="函数、谓词、CASE表达式"></a>函数、谓词、CASE表达式</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数的种类"><a href="#函数的种类" class="headerlink" title="函数的种类"></a>函数的种类</h4><ul><li>算术函数：数值计算</li><li>字符串函数：字符串操作</li><li>日期函数：日期操作</li><li>转换函数：转换数据类型和值</li><li>聚合函数：数据聚合</li></ul><h4 id="算术函数"><a href="#算术函数" class="headerlink" title="算术函数"></a>算术函数</h4><ul><li>绝对值函数</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABS(数值)</span><br></pre></td></tr></table></figure><ul><li>求余</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOD(被除数，除数)</span><br></pre></td></tr></table></figure><ul><li><p>[注]</p><ul><li>SQL Server 不支持 MOD()，而使用 <strong>“%”</strong> 求余</li></ul></li><li><p>四舍五入</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROUND(对象数值，保留小数的位数)</span><br></pre></td></tr></table></figure><h4 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h4><ul><li>拼接</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串1 || 字符串2 || 字符串3 || ……</span><br></pre></td></tr></table></figure><ul><li><p>[注]</p><ul><li>SQL Server 不支持 ||，而使用 <strong>“+”</strong> 拼接字符串</li><li>MySQL 不支持 ||，而使用 <strong>CONCAT()</strong> 拼接字符串</li></ul></li><li><p>字符串长度</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LENGTH(字符串)</span><br></pre></td></tr></table></figure><ul><li><p>[注]</p><ul><li>SQL Server 不支持 LENGTH()，而使用 <strong>LEN()</strong> 拼接字符串</li><li>同样是 LENGTH 函数，不同 DBMS 的执行结果也不尽相同。MySQL 中的 LENGTH() 以字节为单位的函数进行计算,此外还存在计算字符串长度的自有函数 <strong>CHAR_LENGTH()</strong></li></ul></li><li><p>大小写转换</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPPER/LOWER(字符串)</span><br></pre></td></tr></table></figure><ul><li><p>[注]</p><ul><li>UPPER/LOWER 函数只能针对英文字母使用，将参数中的字符串全都转换为大/小写</li></ul></li><li><p>字符串替换</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REPLACE</span>(对象字符串，替换前的字符串，替换后的字符串)</span><br></pre></td></tr></table></figure><ul><li>字符串截取</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSTRING（对象字符串 FROM 截取的起始位置 FOR 截取的字符数）</span><br></pre></td></tr></table></figure><ul><li>[注]<ul><li>标准 SQL，但只有 PostgreSQL 和 MySQL 支持该语法</li><li>SQL Server 版本：<blockquote><p>SUBSTRING(对象字符串，截取的起始位置，截取的字符数)</p></blockquote></li><li>Oracle 版本：<blockquote><p>SUBSTR(对象字符串，截取的起始位置，截取的字符数)</p></blockquote></li></ul></li></ul><h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><ul><li>当前日期</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CURRENT_DATE</span><br></pre></td></tr></table></figure><ul><li><p>[注]</p><ul><li>SQL Server 不支持 CURRENT_DATE，而使用 <strong>CAST(CURRENT_TIMESTAMP AS DATE)</strong> 获取当前日期</li></ul></li><li><p>当前时间</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CURRENT_TIME</span><br></pre></td></tr></table></figure><ul><li><p>[注]</p><ul><li>SQL Server 不支持 CURRENT_TIME，而使用 <strong>CAST(CURRENT_TIMESTAMP AS TIME)</strong> 获取当前时间</li></ul></li><li><p>当前日期和时间</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CURRENT_TIMESTAMP</span><br></pre></td></tr></table></figure><ul><li>截取日期元素</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXTRACT(日期元素 FROM 日期)</span><br></pre></td></tr></table></figure><ul><li>[注]<ul><li>日期元素：<ul><li>YEAR</li><li>MONTH</li><li>DAY</li><li>HOUR</li><li>MINUTE</li><li>SECOND</li></ul></li><li>SQL Server 不支持 EXTRACT 函数，而使用 <strong>DATEPART 函数</strong> 获取当前时间<blockquote><p>DATEPART(日期元素 , CURRENT_TIMESTAMP)</p></blockquote></li></ul></li></ul><h4 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h4><ul><li>CAST —— 数据类型转换</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CAST（转换前的值 AS 想要转换的数据类型）</span><br></pre></td></tr></table></figure><ul><li><p>[注]</p><ul><li>使用场景：<ul><li>插入与表中数据类型不匹配的数据</li><li>在进行运算时由于数据类型不一致发生了错误</li><li>进行自动类型转换会造成处理速度低下</li></ul></li></ul></li><li><p>COALESCE —— 将NULL转换为其他值</p><p>返回可变参数 A 中左侧开始第 1个不是 NULL 的值</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COALESCE(数据1，数据2，数据3……)</span><br></pre></td></tr></table></figure><h3 id="谓词-—-返回值是真值的函数"><a href="#谓词-—-返回值是真值的函数" class="headerlink" title="谓词 — 返回值是真值的函数"></a>谓词 — 返回值是真值的函数</h3><h4 id="LIKE-—-模糊查询"><a href="#LIKE-—-模糊查询" class="headerlink" title="LIKE — 模糊查询"></a>LIKE — 模糊查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line">  <span class="keyword">FROM</span> &lt;表名&gt;</span><br><span class="line"> <span class="keyword">WHERE</span> &lt;列名&gt; <span class="keyword">LIKE</span> <span class="string">'模式'</span>;</span><br></pre></td></tr></table></figure><ul><li>% 代表“0 个字符以上的任意字符串”</li><li>_（下划线）代表了“任意 1 个字符”</li></ul><div class="table-container"><table><thead><tr><th>模式</th><th>匹配</th></tr></thead><tbody><tr><td>abc%</td><td><strong>abc</strong>qwe</td></tr><tr><td>%abc%</td><td>qwe<strong>abc</strong>qwe</td></tr><tr><td>%abc</td><td>qwe<strong>abc</strong></td></tr><tr><td>abc__</td><td><strong>abc</strong>qw</td></tr><tr><td><em>abc</em></td><td>e<strong>abc</strong>q</td></tr><tr><td>_abc</td><td>q<strong>abc</strong></td></tr></tbody></table></div><h4 id="BETWEENT-——-范围查询"><a href="#BETWEENT-——-范围查询" class="headerlink" title="BETWEENT —— 范围查询"></a>BETWEENT —— 范围查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line">  <span class="keyword">FROM</span> &lt;表名&gt;</span><br><span class="line"> <span class="keyword">WHERE</span> &lt;列名&gt; <span class="keyword">BETWEEN</span> &lt;上限&gt; <span class="keyword">AND</span> &lt;下限&gt;;</span><br></pre></td></tr></table></figure><ul><li>数据可以是数值、文本或者日期</li><li>BETWEEN 的结果包含 &lt;上限&gt; 和 &lt;下限&gt;。不想让结果包含临界值则使用 &lt; 和 &gt;</li></ul><h4 id="IS-NOT-NULL-——-判断是否为NULL"><a href="#IS-NOT-NULL-——-判断是否为NULL" class="headerlink" title="IS (NOT) NULL —— 判断是否为NULL"></a>IS (NOT) NULL —— 判断是否为NULL</h4><p>选取出某些值为（不为） NULL 的列的数据只能使用特定的谓词 IS (NOT) NULL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line">  <span class="keyword">FROM</span> &lt;表名&gt;</span><br><span class="line"> <span class="keyword">WHERE</span> &lt;列名&gt; <span class="keyword">IS</span> (<span class="keyword">NOT</span>) <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h4 id="IN-谓词-——-OR-的简便用法"><a href="#IN-谓词-——-OR-的简便用法" class="headerlink" title="IN 谓词 —— OR 的简便用法"></a>IN 谓词 —— OR 的简便用法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line">  <span class="keyword">FROM</span> &lt;表名&gt;</span><br><span class="line"> <span class="keyword">WHERE</span> &lt;列名&gt; (<span class="keyword">NOT</span>) <span class="keyword">IN</span> (集合元素……/子查询);</span><br></pre></td></tr></table></figure><ul><li>使用 IN 和 NOT IN 无法选取出 NULL 数据，因为 NULL 只能使用 IS (NOT) NULL 选取</li></ul><h4 id="EXIST-谓词"><a href="#EXIST-谓词" class="headerlink" title="EXIST 谓词"></a>EXIST 谓词</h4><p>判断是否存在满足某条件的<strong>记录</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line">  <span class="keyword">FROM</span> &lt;表名&gt;</span><br><span class="line"> <span class="keyword">WHERE</span> &lt;列名&gt; (<span class="keyword">NOT</span>) EXIST (集合元素……/子查询);</span><br></pre></td></tr></table></figure><ul><li>通常指定关联子查询作为 EXIST 的参数</li><li>由于 EXIST 只关心<strong>记录</strong>是否存在，因此子查询中返回哪些列都没有关系（建议统一在 EXIST 的子查询中书写 SELECT *）</li><li>与 in 执行时的区别：<br>in 先执行子查询中的查询，再执行主查询；exists 先执行主查询，即外层表的查询，再执行子查询。效率视情况而定</li></ul><h3 id="CASE-表达式-—-区分情况执行"><a href="#CASE-表达式-—-区分情况执行" class="headerlink" title="CASE 表达式 — 区分情况执行"></a>CASE 表达式 — 区分情况执行</h3><h4 id="CASE表达式"><a href="#CASE表达式" class="headerlink" title="CASE表达式"></a>CASE表达式</h4><ul><li>搜索 CASE 表达式语法</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CASE WHEN &lt;求值表达式&gt; THEN &lt;表达式&gt;</span><br><span class="line">     WHEN &lt;求值表达式&gt; THEN &lt;表达式&gt;</span><br><span class="line">     WHEN &lt;求值表达式&gt; THEN &lt;表达式&gt;</span><br><span class="line">     ……</span><br><span class="line">     ELSE &lt;表达式&gt;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><ul><li>执行过程：<ol><li>第一条 WHEN 子句中的“&lt; 求值表达式 &gt;”求值</li><li>结果为真（TRUE），返回 THEN 子句中的表达式， 执行完毕；结果不为真，顺次转到下一条 WHEN 子句进行求值……</li><li>若到最后一条 WHEN 子句为止返回结果都不为真，则返回 ELSE 中的表达式</li><li>执行完毕</li></ol></li><li>ELSE 子句也可以省略不写，这时会被默认为 ELSE NULL，但不建议省略</li><li>END 不能省略</li></ul><hr><h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><h3 id="表的集合运算（以行方向为单位进行操作）"><a href="#表的集合运算（以行方向为单位进行操作）" class="headerlink" title="表的集合运算（以行方向为单位进行操作）"></a>表的集合运算（以行方向为单位进行操作）</h3><h4 id="Def"><a href="#Def" class="headerlink" title="Def"></a>Def</h4><p>进行这些集合运算时，会导致记录行数的增减，但不会导致列数的改变</p><h4 id="UNION（并集）"><a href="#UNION（并集）" class="headerlink" title="UNION（并集）"></a>UNION（并集）</h4><p>表 a 和 表 b 的并集</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;列名&gt;, ……</span><br><span class="line">  <span class="keyword">FROM</span> &lt;a 表名&gt;</span><br><span class="line"> <span class="keyword">UNION</span> （<span class="keyword">ALL</span>）</span><br><span class="line"><span class="keyword">SELECT</span> &lt;列名&gt;, ……</span><br><span class="line">  <span class="keyword">FROM</span> &lt;b 表名&gt;;</span><br></pre></td></tr></table></figure><h4 id="INTERSECT（交集）"><a href="#INTERSECT（交集）" class="headerlink" title="INTERSECT（交集）"></a>INTERSECT（交集）</h4><p>表 a 和 表 b 的交集</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;列名&gt;, ……</span><br><span class="line">  <span class="keyword">FROM</span> &lt;a 表名&gt;</span><br><span class="line"><span class="keyword">INTERSECT</span> （<span class="keyword">ALL</span>）</span><br><span class="line"><span class="keyword">SELECT</span> &lt;列名&gt;, ……</span><br><span class="line">  <span class="keyword">FROM</span> &lt;b 表名&gt;;</span><br></pre></td></tr></table></figure><h4 id="EXCEPT（差集）"><a href="#EXCEPT（差集）" class="headerlink" title="EXCEPT（差集）"></a>EXCEPT（差集）</h4><p>表 a 和 表 b 的差集，即表 a 除去与表 b 交集部分所剩余的部分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;列名&gt;, ……</span><br><span class="line">  <span class="keyword">FROM</span> &lt;a 表名&gt;</span><br><span class="line"><span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span> &lt;列名&gt;, ……</span><br><span class="line">  <span class="keyword">FROM</span> &lt;b 表名&gt;;</span><br></pre></td></tr></table></figure><ul><li>MySQL 不支持 EXCEPT</li><li>Oracle 中求差集将 “EXCEPT” 改为 “MINUS”</li></ul><h4 id="集合运算注意事项"><a href="#集合运算注意事项" class="headerlink" title="集合运算注意事项"></a>集合运算注意事项</h4><ul><li>集合运算符会除去重复的记录。使用 <strong>ALL</strong> 选项，可以保留重复行</li><li>作为运算对象的记录的<strong>列数必须相同</strong></li><li>作为运算对象的记录中列的类型必须一致</li><li>可以使用任何 SELECT 语句，但 ORDER BY 子句只能在最后使用一次</li></ul><h3 id="联结（以列为单位对表进行联结）"><a href="#联结（以列为单位对表进行联结）" class="headerlink" title="联结（以列为单位对表进行联结）"></a>联结（以列为单位对表进行联结）</h3><h4 id="Def-1"><a href="#Def-1" class="headerlink" title="Def"></a>Def</h4><p>将其他表中的列添加过来，进行“添加列”的运算</p><h4 id="内联结——INNER-JOIN"><a href="#内联结——INNER-JOIN" class="headerlink" title="内联结——INNER JOIN"></a>内联结——INNER JOIN</h4><p>以<strong>两张表中都包含的列（联结键）</strong>作为桥梁，将<strong>只存在于一张表内的列</strong>汇集到同一结果之中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;表<span class="number">1</span>别名&gt;.&lt;列名&gt;, …， &lt;表<span class="number">2</span>别名&gt;.&lt;列名&gt;, …</span><br><span class="line">  <span class="keyword">FROM</span> &lt;表<span class="number">1</span>&gt; <span class="keyword">AS</span> &lt;表<span class="number">1</span>别名&gt;</span><br><span class="line"> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> &lt;表<span class="number">2</span>&gt; <span class="keyword">AS</span> &lt;表<span class="number">2</span>别名&gt;</span><br><span class="line">    <span class="keyword">ON</span> 表<span class="number">1.</span>&lt;共同列&gt; = 表<span class="number">2.</span>&lt;共同列&gt;</span><br><span class="line"> <span class="keyword">WHERE</span> ……</span><br></pre></td></tr></table></figure><h4 id="外联结——OUTER-JOIN"><a href="#外联结——OUTER-JOIN" class="headerlink" title="外联结——OUTER JOIN"></a>外联结——OUTER JOIN</h4><p>通过 ON 子句的联结键将两张表进行联结，并从两张表中同时选取相应的列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;表<span class="number">1</span>别名&gt;.&lt;列名&gt;, …， &lt;表<span class="number">2</span>别名&gt;.&lt;列名&gt;, …</span><br><span class="line">  <span class="keyword">FROM</span> &lt;表<span class="number">1</span>&gt; <span class="keyword">AS</span> &lt;表<span class="number">1</span>别名&gt;</span><br><span class="line">  <span class="keyword">LEFT</span>/<span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> &lt;表<span class="number">2</span>&gt; <span class="keyword">AS</span> &lt;表<span class="number">2</span>别名&gt;</span><br><span class="line">    <span class="keyword">ON</span> 表<span class="number">1.</span>&lt;共同列&gt; = 表<span class="number">2.</span>&lt;共同列&gt;</span><br><span class="line"> <span class="keyword">WHERE</span> ……</span><br></pre></td></tr></table></figure><ul><li>与内联结区别<ul><li>内联结只能选取出同时存在于两张表中的数据</li><li>对于外联结，只要数据存在于某一张表当中，就能够读取<br>出来</li></ul></li><li>外联结中使用LEFT、RIGHT来指定主表，最终的结果中会包含主表内所有的数据</li></ul><h4 id="多表联结"><a href="#多表联结" class="headerlink" title="多表联结"></a>多表联结</h4><p>通过 ON 子句的联结键将多张表进行联结。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;表<span class="number">1</span>别名&gt;.&lt;列名&gt;, …， &lt;表<span class="number">2</span>别名&gt;.&lt;列名&gt;, …</span><br><span class="line">  <span class="keyword">FROM</span> &lt;表<span class="number">1</span>&gt; <span class="keyword">AS</span> &lt;表<span class="number">1</span>别名&gt;</span><br><span class="line"> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> &lt;表<span class="number">2</span>&gt; <span class="keyword">AS</span> &lt;表<span class="number">2</span>别名&gt;</span><br><span class="line">    <span class="keyword">ON</span> 表<span class="number">1.</span>&lt;共同列&gt; = 表<span class="number">2.</span>&lt;共同列&gt;</span><br><span class="line">      <span class="keyword">INNER</span> <span class="keyword">JOIN</span> &lt;表<span class="number">3</span>&gt; <span class="keyword">AS</span> &lt;表<span class="number">3</span>别名&gt;</span><br><span class="line">         <span class="keyword">ON</span> 表<span class="number">1.</span>&lt;共同列&gt; = 表<span class="number">3.</span>&lt;共同列&gt;</span><br><span class="line"> <span class="keyword">WHERE</span> ……</span><br></pre></td></tr></table></figure><ul><li>如下例子中表 1 与表 2 联结，表 1 与表 3 联结，则表 2 与表 3 无需再联结</li><li>“表 1 与表 3 联结”改为“表 2 与表 3 联结”，效果一样</li></ul><hr><h2 id="SQL-高级处理"><a href="#SQL-高级处理" class="headerlink" title="SQL 高级处理"></a>SQL 高级处理</h2><h3 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h3><h4 id="窗口函数的语法"><a href="#窗口函数的语法" class="headerlink" title="窗口函数的语法"></a>窗口函数的语法</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;窗口函数&gt; OVER (PARTITION BY &lt;列清单&gt;)</span><br><span class="line">                  ORDER BY &lt;排序用列清单&gt;)</span><br></pre></td></tr></table></figure><ul><li>通过 PARTITION BY 分组后的记录集合称为“窗口”（意指“范围”）。PARTITION BY 并非必需，不指定 PARTITION BY 时，将整个表作为一个大的窗口来使用</li><li>OVER 子句中的 ORDER BY 只是用来决定<br>窗口函数按照什么样的顺序进行计算的，对结果的排列顺序并没有影响。对结果排序需要在 SELECT 语句的最后使用 ORDER BY 子句，此时两个 ORDER BY 功能完全不同</li><li>窗口函数兼具分组和排序两种功能</li><li>能够作为窗口函数使用的函数<ul><li>能够作为窗口函数的聚合函数（SUM、AVG、COUNT、MAX、MIN）</li><li>RANK、DENSE_RANK、ROW_NUMBER 等专用窗口函数</li></ul></li><li><p>以专用窗口函数 RANK 为例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;列<span class="number">1</span>&gt;, &lt;列<span class="number">2</span>&gt;, &lt;列<span class="number">3</span>&gt;， …</span><br><span class="line">  <span class="keyword">RANK</span> () <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> &lt;列<span class="number">2</span>&gt;</span><br><span class="line">                  <span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;列<span class="number">3</span>&gt;) <span class="keyword">AS</span> ranking</span><br><span class="line">  <span class="keyword">FROM</span> &lt;表名&gt;;</span><br></pre></td></tr></table></figure><ul><li>PARTITION BY 能够设定排序的对象范围</li><li>ORDER BY 能够指定按照哪一列、何种顺序进行排序</li></ul></li></ul><h4 id="专用窗口函数"><a href="#专用窗口函数" class="headerlink" title="专用窗口函数"></a>专用窗口函数</h4><ul><li><p>RANK函数</p><p>计算排序时，如果存在相同位次的记录，则会跳过之后的位次。</p><ul><li>例：有 3 条记录排在第 1 位时：1 位、1 位、1 位、4 位……</li></ul></li><li><p>DENSE_RANK函数</p><p>同样是计算排序，即使存在相同位次的记录，也不会跳过之后的位次。</p><ul><li>例：有 3 条记录排在第 1 位时：1 位、1 位、1 位、2 位……</li></ul></li><li><p>ROW_NUMBER函数</p><p>赋予唯一的连续位次。</p><ul><li>例：有 3 条记录排在第 1 位时：1 位、2 位、3 位、4 位……</li></ul></li><li><p>专用窗口函数无需参数，因此通常参数括号中都是空的</p></li></ul><h4 id="作为窗口函数使用的聚合函数"><a href="#作为窗口函数使用的聚合函数" class="headerlink" title="作为窗口函数使用的聚合函数"></a>作为窗口函数使用的聚合函数</h4><p>以专用 AVG() 为例</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;列<span class="number">1</span>&gt;, &lt;列<span class="number">2</span>&gt;, &lt;列<span class="number">3</span>&gt;， …，</span><br><span class="line">  <span class="keyword">AVG</span> (指定列) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;指定列&gt;) <span class="keyword">AS</span> ranking</span><br><span class="line">  <span class="keyword">FROM</span> &lt;表名&gt;;</span><br></pre></td></tr></table></figure><ul><li>得到的结果按照 ORDER BY 子句指定列的升序排列，一行一行逐渐添加计算对象，<strong>累计</strong>进行聚合函数运算</li><li>聚合函数作为窗口函数时的最大特征：以当前记录作为基准进行统计</li></ul><h4 id="窗口函数的适用范围"><a href="#窗口函数的适用范围" class="headerlink" title="窗口函数的适用范围"></a>窗口函数的适用范围</h4><p>原则上，窗口函数只能书写在 SELECT 子句中。</p><blockquote><p>在 DBMS 内部，窗口函数是对 WHERE 子句或者 GROUP BY 子句处理后的“结果”进行的操作。大家仔细想一想就会明白，在得到用户想要的结果之前，即使进行了排序处理，结果也是错误的。在得到排序结果之后，如果通过 WHERE 子句中的条件除去了某些记录，或者使用 GROUP BY 子句进行了汇总处理，那好不容易得到的排序结果也无法<br>使用了。反之，之所以在 ORDER BY 子句中能够使用窗口函数，是因为 ORDER BY 子句会在 SELECT 子句之后执行，并且记录保证不<br>会减少。</p></blockquote><p>因此，在 SELECT 子句之外“使用窗口函数是没有意义的。</p><h4 id="计算移动平均"><a href="#计算移动平均" class="headerlink" title="计算移动平均"></a>计算移动平均</h4><p>移动平均（moving average）常用于希望实时把握“最近状态”的场景，如数据的实时跟踪</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;列<span class="number">1</span>&gt;, &lt;列<span class="number">2</span>&gt;, &lt;列<span class="number">3</span>&gt;， …，</span><br><span class="line">   <span class="keyword">AVG</span> &lt;指定列&gt; <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;指定列&gt; <span class="keyword">ROWS</span> n <span class="keyword">PRECEDING</span>)</span><br><span class="line"><span class="keyword">FROM</span> &lt;表名&gt;;</span><br></pre></td></tr></table></figure><p>使用了 ROWS（“行”）和 PRECEDING（“之前”）两个关键字，将框架指定为“截止到之前 n 行”<br>，即：自身（当前记录）、之前第 1 行、 ……、 之前第 ~ 行，共 n+1 行</p><ul><li>框架:在窗口中指定更加详细的汇总范围</li><li>FOLLOWING（“之后”）可替换 PRECEDING，指定“截止到之后 ~ 行”作为框架</li></ul><h3 id="GROUPING-运算符"><a href="#GROUPING-运算符" class="headerlink" title="GROUPING 运算符"></a>GROUPING 运算符</h3><h4 id="ROLLUP"><a href="#ROLLUP" class="headerlink" title="ROLLUP"></a>ROLLUP</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">GROUPING</span>(聚合键)， <span class="keyword">SUM</span>(求和列) <span class="keyword">AS</span> sum_指定列</span><br><span class="line">  <span class="keyword">FROM</span> &lt;表名&gt;</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">ROLLUP</span>(聚合键);</span><br></pre></td></tr></table></figure><p>可一次计算出按不同聚合键组合的求和结果</p><ul><li>此处聚合键和 GROUP BY 子句使用一样，可以为 NULL，可以指定多列</li><li>GROUP BY 不指定聚合键时会默认使用 NULL 作为聚合键（相当于没有使用 GROUP BY），此时会得到全部数据的合计行的记录，称超级分组</li><li>GROUPING 函数在其参数列的值为超级分组记录所产生的 NULL 时返回 1，其他情况返回 0，以分辨出原始数据中的 NULL 和超级分组记录中的 NULL</li><li>在 MySQL 中 GROUP BY 子句应改写为“GROUP BY &lt;指定列&gt; WITH ROLLUP;”</li></ul><h4 id="CUBE"><a href="#CUBE" class="headerlink" title="CUBE"></a>CUBE</h4><p>CUBE 将 GROUP BY 子句中聚合键的“所有可能的组合”的汇总结果集中到一个结果中。因此，组合的个数就是 $2^n$（n 是聚合键的个数）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">GROUPING</span>(聚合键)， <span class="keyword">SUM</span>(求和列) <span class="keyword">AS</span> sum_指定列</span><br><span class="line">  <span class="keyword">FROM</span> &lt;表名&gt;</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">CUBE</span>(聚合键);</span><br></pre></td></tr></table></figure><p>可以把 CUBE 理解为将使用聚合键进行切割的模块堆积成一个立方体</p><h4 id="GROUPING-SETS"><a href="#GROUPING-SETS" class="headerlink" title="GROUPING SETS"></a>GROUPING SETS</h4><p>CUBE 的结果就是根据聚合键的所有可能的组合计算而来的，使用 GROUPING SETS 可以取得部分组合的结果</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">GROUPING</span>(聚合键)， <span class="keyword">SUM</span>(求和列) <span class="keyword">AS</span> sum_指定列</span><br><span class="line">  <span class="keyword">FROM</span> &lt;表名&gt;</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">GROUPING</span> <span class="keyword">SETS</span>(&lt;聚合键组合<span class="number">1</span>&gt;, &lt;聚合键组合<span class="number">2</span>&gt;, …);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + NexT 的问题汇总</title>
      <link href="/2019/06/30/hexo_problem_list/"/>
      <url>/2019/06/30/hexo_problem_list/</url>
      
        <content type="html"><![CDATA[<p><font color="#FF0000"> [Updating] </font> 本文记录了 Hexo + NexT 使用过程中的一些问题</p><a id="more"></a><p>版本声明</p><ul><li>hexo: 3.9.0</li><li>next: 7.0.1</li></ul><h2 id="local-search-不能用"><a href="#local-search-不能用" class="headerlink" title="local_search 不能用"></a>local_search 不能用</h2><p>打开首页（本地or线上），打开浏览器开发工具 Network 选项卡，点击首页“搜索”按钮，观察 search.xml 状态：</p><ul><li>200<ul><li>问题：Algolia 问题</li><li>解决：<strong>主题配置</strong>文件中关闭 Algolia</li></ul></li><li>404</li><li>其他<ul><li>问题：存在非法字符</li><li>解决：sublime 排查 .md 文件中所存在非法字符</li></ul></li></ul><h2 id="post-meta-不显示更新时间"><a href="#post-meta-不显示更新时间" class="headerlink" title="post_meta 不显示更新时间"></a>post_meta 不显示更新时间</h2><p>修改主题配置文件，post_meta 模块中设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">updated:</span><br><span class="line"> enable: true</span><br><span class="line"> anotherday: false</span><br></pre></td></tr></table></figure></p><h2 id="修改新建文章模板"><a href="#修改新建文章模板" class="headerlink" title="修改新建文章模板"></a>修改新建文章模板</h2><p>hexo 会根据 scaffolds 文件夹内相应的模板文件来建立文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &lt;模板：post/page/draft&gt; &lt;filename&gt;  -- 以 /scaffolds/&lt;模板：post/page/draft&gt;.md 为模板新建名为 &lt;filename&gt; 的文章</span><br></pre></td></tr></table></figure></p><p>post 模板添加内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">updated: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">&lt;font color=#008000&gt; [Updated] &lt;/font&gt; 已完成</span><br><span class="line">&lt;font color=#FF0000&gt; [Updating] &lt;/font&gt; 更新中</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure></p><h2 id="数学公式不显示"><a href="#数学公式不显示" class="headerlink" title="数学公式不显示"></a>数学公式不显示</h2><ol><li><p>更换渲染引擎为 hexo-renderer-marked</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save # 卸载 hexo 默认引擎 hexo-renderer-marked</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure></li><li><p>Next 配置文件开启 MathJax</p><p>找到 math 模块，开启：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">math：</span><br><span class="line">  enable： true # 此处设为 true</span><br><span class="line"></span><br><span class="line">  ……</span><br></pre></td></tr></table></figure></li><li><p>在需要渲染公式的文章开头的 Front-matter 设置 MathJax</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: ……</span><br><span class="line">date: ……</span><br><span class="line">tags:</span><br><span class="line">mathjax: true # 添加此项</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li></ol><h2 id="图片不显示"><a href="#图片不显示" class="headerlink" title="图片不显示"></a>图片不显示</h2><p>传统的 Makrdown 插入图片的语法无法显示图片。</p><p>查阅<a href="#https://hexo.io/zh-cn/docs/asset-folders">官方文档</a>，发现可用资源文件来解决。</p><ol><li>修改 hexo 的配置文件 _config.yml，将 post_asset_folder 选项设置为 true；</li><li><p>插入图片的语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img example.jpg This is an example image %&#125;</span><br></pre></td></tr></table></figure></li><li><p>在资源文件夹中放入图片 example.jpg 即可。</p></li></ol><p>注：安装 hexo-asset-image 插件，每次新建文章后会自动在 source/_post 文件夹下创建文章同名的资源文件夹：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github + Hexo 搭建博客</title>
      <link href="/2019/05/30/hexo/"/>
      <url>/2019/05/30/hexo/</url>
      
        <content type="html"><![CDATA[<p><font color="#FF0000"> [Updating] </font> 本文记录了使用Github和Hexo搭建该博客的过程</p><a id="more"></a><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>系统：ubuntu 18.04</li><li>nodejs:：</li></ul><h2 id="Hexo-的安装"><a href="#Hexo-的安装" class="headerlink" title="Hexo 的安装"></a>Hexo 的安装</h2><h3 id="Node-js-的安装"><a href="#Node-js-的安装" class="headerlink" title="Node.js 的安装"></a>Node.js 的安装</h3><h3 id="Hexo-的安装-1"><a href="#Hexo-的安装-1" class="headerlink" title="Hexo 的安装"></a>Hexo 的安装</h3><h2 id="Git-的安装"><a href="#Git-的安装" class="headerlink" title="Git 的安装"></a>Git 的安装</h2><h2 id="初步优化"><a href="#初步优化" class="headerlink" title="初步优化"></a>初步优化</h2>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
            <tag> next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 命令</title>
      <link href="/2019/02/07/mycli-cmd/"/>
      <url>/2019/02/07/mycli-cmd/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从 pip 到 Pipfile</title>
      <link href="/2018/03/21/pip/"/>
      <url>/2018/03/21/pip/</url>
      
        <content type="html"><![CDATA[<p><font color="#008000"> [Updated] </font> 本文记录了 Python 软件包管理相关的 pip、requirements.txt、Pipfile，以及 Python 虚拟环境的内容。</p><a id="more"></a><h1 id="从-pip-到-Pipfile"><a href="#从-pip-到-Pipfile" class="headerlink" title="从 pip 到 Pipfile"></a>从 pip 到 Pipfile</h1><h2 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h2><p>pip 是一个通用的 Python 软件包管理工具，可以从 Python 官方的第三方库仓库 PyPI （默认）或其他索引安装软件包。</p><h3 id="pip-安装"><a href="#pip-安装" class="headerlink" title="pip 安装"></a>pip 安装</h3><p>注：Python 2.7.9 + 或 Python 3.4+ 内置 pip。</p><p>在终端使用以下命令在当前全局 Python 解释器下安装 pip：</p><pre><code>sudo python get-pip.py</code></pre><p>查看安装版本：</p><pre><code>pip --version</code></pre><p>升级 pip 到最新版本：</p><pre><code>pip install -U pip</code></pre><h3 id="pip-使用"><a href="#pip-使用" class="headerlink" title="pip 使用"></a>pip 使用</h3><p>查看 pip 用法：</p><pre><code>pip --help</code></pre><p>pip 常用命令：</p><ol><li><p>查看已安装包列表</p><pre><code>pip list</code></pre></li><li><p>查找/安装/卸载包</p><pre><code>pip search/install/uninstall &lt;Package&gt; # 安装时使用 “&lt;Package&gt;=版本号” 可指定下载版本</code></pre></li><li><p>升级包</p><pre><code>pip install --upgrade &lt;Package&gt;</code></pre></li><li><p>查看包的详细信息</p><pre><code>pip show -f &lt;Package&gt;</code></pre></li></ol><h2 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h2><h3 id="虚拟环境作用"><a href="#虚拟环境作用" class="headerlink" title="虚拟环境作用"></a>虚拟环境作用</h3><p>Python 虚拟环境允许将 Python 包安装在特定应用程序的隔离位置，而不是全局安装，避免了不同程序因 Python 包的依赖版本不同而导致彼此的运行受到影响。</p><p>因为不同的项目通常会依赖不同版本的库或 Python 版本，所以建议使用虚拟环境为每一个项目创建独立的 Python 环境。</p><h3 id="虚拟环境的使用"><a href="#虚拟环境的使用" class="headerlink" title="虚拟环境的使用"></a>虚拟环境的使用</h3><ol><li><p>安装虚拟环境：</p><pre><code>pip install virtualenv</code></pre></li><li><p>项目根目录下创建虚拟环境：</p><pre><code>virtualenv --no-site-packages &lt;虚拟环境名&gt; # --no-site-packages 参数：不复制全局 python 解释器下的任何第三方库</code></pre><p> 此时，项目根目录下会创建 venv 目录，用以存放虚拟环境。</p></li><li><p>激活虚拟环境：</p><pre><code>source venv/bin/activate</code></pre><p>此时，终端前缀会出现字样“(&lt;虚拟环境名&gt;)”，表示已进入虚拟环境。</p></li><li><p>关闭当前虚拟环境：</p><pre><code>deactivate</code></pre><p>此时，终端前缀消失，回到全局环境。</p></li></ol><h2 id="requirements-txt"><a href="#requirements-txt" class="headerlink" title="requirements.txt"></a>requirements.txt</h2><p>为了解决不同环境下构建项目时可能产生的依赖问题，Python 项目中一般会包含 requirements.txt 文件，文件内记录了该项目所使用到全部依赖包及其精确版本号，以便在新环境中安装该项目所需要的运行环境依赖。</p><h3 id="生成-requirements-txt"><a href="#生成-requirements-txt" class="headerlink" title="生成 requirements.txt"></a>生成 requirements.txt</h3><p>在 Python 项目的根目录终端执行以下命令：</p><pre><code>pip freeze &gt; requirements.txt</code></pre><h3 id="使用-requirements-txt"><a href="#使用-requirements-txt" class="headerlink" title="使用 requirements.txt"></a>使用 requirements.txt</h3><p>使用 requirements.txt 安装依赖</p><pre><code>pip install -r requirements.txt # -r 可以防止安装过程中的某个错误而提前终止安装</code></pre><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>requirements.txt 是一个简单的纯文本文件，需要手动维护，灵活性低。</p><h2 id="Pipfile-和-Pipfile-lock"><a href="#Pipfile-和-Pipfile-lock" class="headerlink" title="Pipfile 和 Pipfile.lock"></a>Pipfile 和 Pipfile.lock</h2><h3 id="Pipfile"><a href="#Pipfile" class="headerlink" title="Pipfile"></a>Pipfile</h3><p>Pipfile 与 Pipfile.lock 是社区拟定的依赖管理文件，用于替代 requirements.txt。一个项目对应一个 Pipfile，支持开发环境与正式环境区分。默认提供 default 和 development 区分。</p><p>与 requirements.txt 区别：</p><ol><li>Pipfile 文件是 TOML 格式； requirements.txt 是纯文本。</li></ol><h3 id="Pipfile-lock"><a href="#Pipfile-lock" class="headerlink" title="Pipfile.lock"></a>Pipfile.lock</h3><p>根据 Pipfile 和当前环境<strong>自动生成</strong>的 JSON 格式的依赖文件。</p><p>注：</p><ol><li>不可手动修改！</li></ol><h3 id="pipenv"><a href="#pipenv" class="headerlink" title="pipenv"></a>pipenv</h3><p>pipenv 结合了 Pipfile 、pip 和 virtualenv。其作用主要有如下几点：</p><ol><li>自动在项目目录的 .venv 目录创建虚拟环境。</li><li>自动生成 Pipfile 和 Pipfile.lock。</li><li>自动管理 Pipfile 新安装和删除的包。</li></ol><h3 id="使用-pipenv"><a href="#使用-pipenv" class="headerlink" title="使用 pipenv"></a>使用 pipenv</h3><ol><li><p>创建虚拟环境并安装 Pipfile 中所列的所有包：</p><p>在 Python 项目的根目录终端执行以下命令：</p><pre><code>pipenv install</code></pre><p>此时，当前项目根目录下会创建 .venv 文件夹，并安装 Pipfile 中的所有第三方软件包。</p></li><li><p>确认 Pipfile 中所有包已安装：</p><p>   pipenv lock</p><p>确认并根据安装版本生成 Pipfile.lock。</p></li><li><p>激活虚拟环境：</p><p>在 Python 项目的根目录终端执行以下命令：</p><pre><code>pipenv shell</code></pre></li><li><p>运行程序：</p><pre><code>pipenv run python **.py  # 运行 python 文件pipenv run flask run # 启动 flask 程序</code></pre><p>注：</p><ul><li>这里会调用虚拟环境中的 python 解释器，而不是全局的 python 解释器。</li><li>在激活虚拟环境后，pipenv run 可以省略，但养成使用 pipenv run 的习惯可以避免运行时忘记启用虚拟环境。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pip </tag>
            
            <tag> 虚拟环境 </tag>
            
            <tag> pipfile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式语法速览</title>
      <link href="/2018/03/21/regex/"/>
      <url>/2018/03/21/regex/</url>
      
        <content type="html"><![CDATA[<p><font color="#008000"> [Updated] </font> 本文记录了正则表达式的常用语法。</p><a id="more"></a><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="Def"><a href="#Def" class="headerlink" title="Def"></a>Def</h2><p>描述复杂文本规则的代码，用以匹配符合规则的字符串</p><ul><li>转义字符用 “\” 转义。如：表达文本 “\”，表达式中应使用 “\“</li></ul><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><div class="table-container"><table><thead><tr><th>元字符</th><th>含义</th><th>表达式</th><th>匹配示例</th></tr></thead><tbody><tr><td>.</td><td>除换行符以外任意字符</td><td>q.e</td><td>qwe、qse</td></tr><tr><td>^</td><td>字符串的开始（位置）</td><td>^qw</td><td>（行首）qw</td></tr><tr><td>$</td><td>匹配字符串的结束（位置）</td><td>we$</td><td>we（行尾）</td></tr><tr><td>\b</td><td>单词的开头或结尾，即单词交界处（位置）</td></tr><tr><td>\d</td><td>一位数字</td><td>q\dw</td><td>q1w</td></tr><tr><td>\s</td><td>空白字符(半/全角空格，制表符，换行符等)</td><td>qw\se</td><td>qw e</td></tr><tr><td>\w</td><td>任意的字母，数字，下划线等</td><td>q\we</td><td>q_e</td></tr><tr><td>\A</td><td>仅匹配字符串开头</td><td>\Aqwe</td><td>qwe</td></tr><tr><td>\Ｚ</td><td>仅匹配字符串结尾</td><td>qwe\Z</td><td>qwe</td></tr><tr><td>[\u4E00-\u9FA5]</td><td>匹配汉字</td><td>q[\u4E00-\u9FA5]e</td><td>q我e</td></tr></tbody></table></div><h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><div class="table-container"><table><thead><tr><th>限定符</th><th>含义</th><th>表达式</th><th>匹配示例</th></tr></thead><tbody><tr><td>*</td><td>重复零次或更多次</td><td>qwe*</td><td>qweeeee、qw</td></tr><tr><td>+</td><td>重复一次或更多次</td><td>qw\s+e</td><td>qw    e</td></tr><tr><td>?</td><td>重复零次或一次</td><td>qw?e</td><td>qwe、qe</td></tr><tr><td>{n}</td><td>重复 n 次</td><td>qw{3}e</td><td>qwwwe</td></tr><tr><td>{n,}</td><td>重复 n 次或更多次</td><td>qw{3,}e</td><td>qwwwwe</td></tr><tr><td>{n,m}</td><td>重复 n 到 m 次(n ≠ m)</td><td>qw{5,6}e</td><td>qwwwwwwe</td></tr></tbody></table></div><h2 id="分支条件"><a href="#分支条件" class="headerlink" title="| 分支条件"></a>| 分支条件</h2><div class="table-container"><table><thead><tr><th>分支</th><th>含义</th><th>表达式</th><th>匹配示例</th></tr></thead><tbody><tr><td>&#124;</td><td>使用分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再测试后面的条件，因此要注意各个条件的顺序</td><td>qw?e &#124; qw*q</td><td>qe、qwwwwq</td></tr></tbody></table></div><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>表达式中，被小括号括起来的子表达式称分组：</p><ul><li>表达式左到右顺序按次遇到的左括号及其括号内容即编号第n个分组</li><li>分组作为一个整体，后可接数量词：(分组){重复次数}</li><li>分组中 “|” 仅分组内有效</li></ul><div class="table-container"><table><thead><tr><th>分组</th><th>含义</th><th>表达式</th><th>匹配示例</th></tr></thead><tbody><tr><td>(……)</td><td>分组</td><td>q(w &#124; e)r</td><td>qer、qwr</td></tr><tr><td>\&lt;编号&gt;</td><td>引用指定编号分组</td><td>(\d)qwe\1</td><td>1qwe1</td></tr><tr><td>(?&lt;别名&gt;)</td><td>为分组指定别名（仍可使用编号）</td><td>(?P<id>\d)abc(?P=id)</id></td><td>1abc1</td></tr><tr><td>(?=&lt;别名&gt;)</td><td>引用指定别名分组</td><td>(?P<id>\d)abc(?P=id)</id></td><td>1abc1</td></tr></tbody></table></div><h2 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h2><p>查找不属于该定义的字符</p><div class="table-container"><table><thead><tr><th>反义代码</th><th>说明</th><th>表达式</th><th>匹配示例</th></tr></thead><tbody><tr><td>\W</td><td>匹配任意不是字母，数字，下划线，汉字的字符</td><td>q\We</td><td>q e</td></tr><tr><td>\S</td><td>匹配任意不是空白符的字符</td><td>q\Se</td><td>q!e</td></tr><tr><td>\D</td><td>匹配任意非数字的字符</td><td>q\De</td><td>qwe</td></tr><tr><td>\B</td><td>匹配不是单词开头或结束的位置</td><td>q\Bwe</td><td>qwe</td></tr><tr><td><sup><a href="#fn_字符集合" id="reffn_字符集合">字符集合</a></sup></td><td>匹配除了字符集合中所有字符以外的任意字符</td><td>q<sup><a href="#fn_we" id="reffn_we">we</a></sup>t</td><td>qrt</td></tr></tbody></table></div><h2 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h2><div class="table-container"><table><thead><tr><th>捕获</th><th>含义</th></tr></thead><tbody><tr><td>(exp)</td><td>匹配exp,并捕获文本到自动命名的组里</td></tr><tr><td>(?&lt;组名&gt;exp)</td><td>匹配exp,并捕获文本到名称为组名的组里，也可以写成(?’组名’exp)</td></tr><tr><td>(?:exp)</td><td>匹配exp,不捕获匹配的文本，也不给此分组分配组号</td></tr></tbody></table></div><h2 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h2><div class="table-container"><table><thead><tr><th>零宽断言</th><th>含义</th></tr></thead><tbody><tr><td>(?=exp)</td><td>匹配exp前面的位置</td></tr><tr><td>(?&lt;=exp)</td><td>匹配exp后面的位置</td></tr><tr><td>(?!exp)</td><td>匹配后面跟的不是exp的位置</td></tr><tr><td>(?&lt;!exp)</td><td>匹配前面不是exp的位置</td></tr></tbody></table></div><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>表达式中添加注释：</p><blockquote><p>(?#注释)</p></blockquote><p>示例：</p><blockquote><p>\d{3}<strong>(?#区号)</strong>-\d{7}</p></blockquote><p>加粗部分即注释</p><h2 id="懒惰限定符"><a href="#懒惰限定符" class="headerlink" title="懒惰限定符"></a>懒惰限定符</h2><p>匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复</p><div class="table-container"><table><thead><tr><th>懒惰限定符</th><th>含义</th></tr></thead><tbody><tr><td>*?</td><td>重复任意次，但尽可能少重复</td></tr><tr><td>+?</td><td>重复1次或更多次，但尽可能少重复</td></tr><tr><td>??</td><td>重复0次或1次，但尽可能少重复</td></tr><tr><td>{n,m}?</td><td>重复n到m次，但尽可能少重复</td></tr><tr><td>{n,}?</td><td>重复n次以上，但尽可能少重复</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> regex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> regex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 使用速览</title>
      <link href="/2018/02/23/linux-quick-use/"/>
      <url>/2018/02/23/linux-quick-use/</url>
      
        <content type="html"><![CDATA[<p><font color="#008000"> [Updated] </font> 本文整理了能够快速上手 Linux 的一些常用操作和基本知识。</p><a id="more"></a><h1 id="Linux-使用速览"><a href="#Linux-使用速览" class="headerlink" title="Linux 使用速览"></a>Linux 使用速览</h1><h2 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h2><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><h4 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h4><ul><li>Ctrl+d ： 键盘输入结束或退出终端</li><li>Ctrl+C ： 杀死当前进程(也可以用来清空当前行)</li><li>Ctrl+s ： 暂停当前程序，暂停后按下任意键恢复运行</li><li>Ctrl+z ： 将当前程序放到后台运行，恢复到前台为命令fg</li></ul><h4 id="编辑控制"><a href="#编辑控制" class="headerlink" title="编辑控制"></a>编辑控制</h4><ul><li>Ctrl+A ： 将光标移至输入行头，相当于Home键</li><li>Ctrl+E ： 将光标移至输入行末，相当于End键</li><li>Ctrl+F ： 向前移动一个字符</li><li>Ctrl+B ： 向后移动一个字符</li><li>Ctrl+U ： 剪切文本直到行的起始(可以用于清空行)</li><li>Ctrl+K ： 剪切文本直到行的末尾</li><li>Ctrl+Y ： 粘贴最近剪切的文本</li><li>Alt+Backspace ： 向前删除一个单词</li><li>Ctrl+P / Ctrl+N ： 上下历史记录，相当于↑↓键</li><li>Shift+PgUp ： 将终端显示向上滚动</li><li>Shift+PgDn ： 将终端显示向下滚动</li></ul><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><div class="table-container"><table><thead><tr><th>通配符</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>匹配 0 或多个字符</td></tr><tr><td>?</td><td>匹配任意一个字符</td></tr><tr><td>[list]</td><td>匹配 list 中的任意单一字符</td></tr><tr><td>[!list]</td><td>匹配 除list 中的任意单一字符以外的字符</td></tr><tr><td>[c1-c2]</td><td>匹配 c1-c2 中的任意单一字符 如：[0-9] [a-z]</td></tr><tr><td>{string1,string2,…}</td><td>匹配 string1 或 string2 (或更多)其一字符串</td></tr><tr><td>{c1..c2}</td><td>匹配 c1-c2 中全部字符 如{1..10}</td></tr></tbody></table></div><h3 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h3><h4 id="man-的用法"><a href="#man-的用法" class="headerlink" title="man 的用法"></a>man 的用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man k（区段） 内容</span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 1（一般命令） ls（命令）</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>区段 k</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>一般命令</td></tr><tr><td>2</td><td>系统调用</td></tr><tr><td>3</td><td>库函数，涵盖了C标准函数库</td></tr><tr><td>4</td><td>特殊文件（通常是/dev中的设备）和驱动程序</td></tr><tr><td>5</td><td>文件格式和约定</td></tr><tr><td>6</td><td>游戏和屏保</td></tr><tr><td>7</td><td>杂项</td></tr><tr><td>8</td><td>系统管理命令和守护进程</td></tr></tbody></table></div><h4 id="man-手册快捷键"><a href="#man-手册快捷键" class="headerlink" title="man 手册快捷键"></a>man 手册快捷键</h4><ul><li>/关键字 ： 搜索</li><li>n ： 切换到下一个关键字所在处</li><li>shift+n ： 切换到上一个关键字所在处</li><li>Space ： 翻页</li><li>Enter ： 向下滚动一行</li></ul><h2 id="用户及文件权限管理"><a href="#用户及文件权限管理" class="headerlink" title="用户及文件权限管理"></a>用户及文件权限管理</h2><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><ol><li>查看用户</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who -[a/d/q/u]</span><br></pre></td></tr></table></figure><ol><li>创建用户</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser USERNAME</span><br></pre></td></tr></table></figure><ol><li>删除用户</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo deluser USERNAME ：remove-home</span><br></pre></td></tr></table></figure><ol><li>用户组</li></ol><ul><li>查找所属用户组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groups USERNAME</span><br></pre></td></tr></table></figure><ul><li>查看 /etc/group</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/group | sort</span><br></pre></td></tr></table></figure><ul><li>将其他用户加入 sudo 用户组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -G sudo USERNAME</span><br></pre></td></tr></table></figure><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><h4 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h4><ol><li>文件类型</li></ol><ul><li>d ： 目录</li><li>l ： 软链接</li><li>b ： 块设备</li><li>c ： 字符设备</li><li>s ： socket</li><li>p ： 管道</li></ul><ol><li>文件权限</li></ol><ul><li>r ： 读</li><li>w ： 写</li><li>x ： 执行</li></ul><ol><li>链接数</li></ol><p>连接到该文件所在的 inode 结点的文件名数目</p><ol><li>文件大小</li></ol><p>以 inode 结点大小为单位来表示的文件大小（ls -lh：直观的查看文件的大小）</p><h4 id="查看权限-1"><a href="#查看权限-1" class="headerlink" title="查看权限"></a>查看权限</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll FILENAME</span><br></pre></td></tr></table></figure><p>显示内容依次为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drwxrwxrwx INODE_LINKS USERNAE GROUPNAME INODE_SIZE TIME FILENAME</span><br></pre></td></tr></table></figure><h4 id="修改文件所有者"><a href="#修改文件所有者" class="headerlink" title="修改文件所有者"></a>修改文件所有者</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown USEENAME FILENAME</span><br></pre></td></tr></table></figure><h4 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h4><ol><li>二进制修改：rwx (421)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 FILENAME</span><br></pre></td></tr></table></figure><ol><li>加减赋值修改：[ u | g | o ] [+ | -] [r | w | x]</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod ugo+rwx FILENAME</span><br></pre></td></tr></table></figure><h2 id="Linux-文件基本操作及目录结构"><a href="#Linux-文件基本操作及目录结构" class="headerlink" title="Linux 文件基本操作及目录结构"></a>Linux 文件基本操作及目录结构</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><p>文件名以 “test_file” 为例；以下&lt;位置&gt;默认为当前工作目录&lt;.&gt;</p><ol><li>创建</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch &lt;创建位置&gt;/test_file</span><br></pre></td></tr></table></figure><ol><li>移动/重命名</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv &lt;文件位置&gt;/test_file &lt;移动位置&gt;</span><br></pre></td></tr></table></figure><ul><li>重命名<ul><li>当移动位置为不存在的目录名，即将文件 test_file 重命名为该目录名</li></ul></li></ul><ol><li>复制</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp &lt;文件位置&gt;/test_file &lt;移动位置/复制名&gt;</span><br></pre></td></tr></table></figure><ol><li>删除</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm &lt;文件位置&gt;/test_file &lt;移动位置/复制名&gt;</span><br></pre></td></tr></table></figure><ol><li>查看</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat test_file &lt;移动位置/复制名&gt;</span><br></pre></td></tr></table></figure><ul><li>一次性查看文件所有内容</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less test_file &lt;移动位置/复制名&gt;</span><br></pre></td></tr></table></figure><ul><li>可以上下键翻页查看内容，按 q 退出</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head/tail test_file &lt;移动位置/复制名&gt;</span><br></pre></td></tr></table></figure><ul><li>查看文件内容的前/后10行</li><li>参数<ul><li>(-n 行数)：查看前/后几行</li></ul></li></ul><ol><li>编辑</li></ol><p>通常 Linux 的自带编辑器有终端下的 vi/vim 编辑器（vim 可看做 vi 的高级版，对 vi 完全兼容），以及可视化编辑器 gedit。使用下方命令新建或打开已有文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi file.txt</span><br><span class="line">gedit file.txt</span><br></pre></td></tr></table></figure><h4 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h4><p>目录名以 “test_dir” 为例；缺省位置为当前工作目录&lt;.&gt;</p><ol><li>创建</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir test_dir &lt;创建位置/目录名&gt;</span><br></pre></td></tr></table></figure><ol><li>移动/重命名</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv test_dir &lt;移动位置/目录名&gt;</span><br></pre></td></tr></table></figure><ul><li>重命名<ul><li>当移动位置为不存在的目录名，即将目录 test_dir 重命名为该目录名</li></ul></li></ul><ol><li>复制目录及目录内容</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r test_dir &lt;创建位置/目录名&gt;</span><br></pre></td></tr></table></figure><ol><li>删除</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm test_dir &lt;删除位置/目录名&gt;</span><br></pre></td></tr></table></figure><ul><li>参数<ul><li>-r：递归删除</li><li>-f：强制删除</li></ul></li></ul><h3 id="Linux-目录结构"><a href="#Linux-目录结构" class="headerlink" title="Linux 目录结构"></a>Linux 目录结构</h3><ul><li>/ : 根目录<ul><li>bin : 一般用户可用，启动时用到的命令<ul><li>boot : 启动项<ul><li>grub : 开关机设置相关文件</li><li>内核文件（vmlinuz）</li></ul></li></ul></li><li>dev : 存放设备文件</li><li>etc : 包含系统特有的可配置文件，即用于控制程序运行的本地文件</li><li>home : 用户家目录</li><li>lib : 用于存放程序的动态库和模块文件</li><li>media : 挂载本地磁盘或其他存储设备。如：cdrom、floppy、U 盘</li><li>mnt : 用于挂载其他临时文件系统</li><li>opt : 发行版附加软件包的安装目录</li><li>root : 根用户的家</li><li>sbin : 存放大多数 root 用户才能执行的命令，系统进行更新、备份、还原和开关机所用的命令</li><li>srv : 存放服务进程所需的数据文件（如 ftp 服务）和一些服务的执行脚本</li><li>tmp : 存放各种临时文件</li><li>usr : 存储只读用户数据的第二层次，包含大多数用户工具和应用程序<ul><li>bin : 非必要可执行文件，面向所有用户</li><li>include : 包含标准头文件</li><li>lib : /usr/bin 和 /usr/sbin 中二进制文件的库</li><li>local : 本地数据的第三层次，具体到本台主机<ul><li>bin</li><li>etc</li><li>include</li><li>lib</li><li>share</li><li>src</li><li>share : 共享数据</li><li>sbin : 非必要的系统二进制文件</li><li>src : 源代码</li></ul></li></ul></li><li>var : 变量文件<ul><li>account</li><li>cache</li><li>lib</li><li>lock</li><li>log</li><li>run</li><li>tmp</li><li>spool</li><li>mail</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 数学公式语法</title>
      <link href="/2018/01/28/markdown-formula/"/>
      <url>/2018/01/28/markdown-formula/</url>
      
        <content type="html"><![CDATA[<p><font color="#008000"> [Updated] </font> 本文记录了 Markdown 数学公式语法</p><a id="more"></a><h1 id="Markdown-数学公式语法"><a href="#Markdown-数学公式语法" class="headerlink" title="Markdown 数学公式语法"></a>Markdown 数学公式语法</h1><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><h3 id="公式类型"><a href="#公式类型" class="headerlink" title="公式类型"></a>公式类型</h3><h4 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h4><p>将公式插入到本行内。使用一个 “$” 包裹数学公式。</p><p>极限：$\displaystyle \lim_{n \to +\infty}{x_n = \alpha}$</p><h4 id="独行公式"><a href="#独行公式" class="headerlink" title="独行公式"></a>独行公式</h4><p>将公式插入到新的一行内，并且居中。使用两个 “$$” 包裹数学公式。极限：</p><script type="math/tex; mode=display">\displaystyle \lim_{n \to +\infty}{x_n = \alpha}</script><h3 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h3><div class="table-container"><table><thead><tr><th>上下标</th><th>语法</th><th>预览</th></tr></thead><tbody><tr><td>^</td><td>x^2</td><td>$x^2$</td></tr><tr><td>_</td><td>x_1</td><td>$x_1$</td></tr></tbody></table></div><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="普通运算"><a href="#普通运算" class="headerlink" title="普通运算"></a>普通运算</h4><div class="table-container"><table><thead><tr><th>运算</th><th>语法</th><th>预览</th></tr></thead><tbody><tr><td>加</td><td>+</td><td>$+$</td></tr><tr><td>减</td><td>-</td><td>$-$</td></tr><tr><td>乘</td><td>\times</td><td>$\times$</td></tr><tr><td>除</td><td>\div</td><td>$\times$</td></tr><tr><td>开方</td><td>\sqrt[n]{x}</td><td>$\sqrt[n]{x}$</td></tr><tr><td>加减</td><td>\pm</td><td>$\pm$</td></tr><tr><td>减加</td><td>\mp</td><td>$\mp$</td></tr><tr><td>绝对值</td><td>\</td><td>\</td><td></td><td>$</td><td>x+y</td><td>$</td></tr><tr><td>分数</td><td>\frac{b}{a}</td><td>$\frac{b}{a}$</td></tr><tr><td>分数</td><td>{b} \voer {a}</td><td>${b} \over {a}$</td></tr></tbody></table></div><h4 id="对数运算"><a href="#对数运算" class="headerlink" title="对数运算"></a>对数运算</h4><div class="table-container"><table><thead><tr><th>运算</th><th>语法</th><th>预览</th></tr></thead><tbody><tr><td>对数</td><td>\log</td><td>$\log$</td></tr><tr><td>ln</td><td>\ln</td><td>$\ln$</td></tr><tr><td>lg</td><td>\lg</td><td>$\lg$</td></tr></tbody></table></div><h4 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h4><div class="table-container"><table><thead><tr><th>运算</th><th>语法</th><th>预览</th></tr></thead><tbody><tr><td>空集</td><td>\emptyset</td><td>$\emptyset$</td></tr><tr><td>属于</td><td>\in</td><td>$\in$</td></tr><tr><td>不属于</td><td>\notin</td><td>$\notin$</td></tr><tr><td>⊂</td><td>\subset</td><td>$\subset$</td></tr><tr><td>⊃</td><td>\supset</td><td>$\supset$</td></tr><tr><td>⊆</td><td>\subseteq</td><td>$\subseteq$</td></tr><tr><td>⊇</td><td>\supseteq</td><td>$\supseteq$</td></tr><tr><td>⊇</td><td>\bigcap</td><td>$\bigcap$</td></tr><tr><td>⋃</td><td>\bigcup</td><td>$\bigcup$</td></tr><tr><td>⋁</td><td>\bigvee</td><td>$\bigvee$</td></tr><tr><td>⋀</td><td>\bigwedge</td><td>$\bigwedge$</td></tr></tbody></table></div><h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><div class="table-container"><table><thead><tr><th>运算</th><th>语法</th><th>预览</th></tr></thead><tbody><tr><td>因为</td><td>\because</td><td>$\because$</td></tr><tr><td>所以</td><td>\therefore</td><td>$\therefore$</td></tr><tr><td>任取</td><td>\forall</td><td>$\forall$</td></tr><tr><td>存在</td><td>\exists</td><td>$\exists$</td></tr><tr><td>不等于</td><td>\neq</td><td>$\neq$</td></tr><tr><td>不属于</td><td>\not\subset</td><td>$\not\subset$</td></tr></tbody></table></div><h4 id="微积分运算"><a href="#微积分运算" class="headerlink" title="微积分运算"></a>微积分运算</h4><div class="table-container"><table><thead><tr><th>运算</th><th>语法</th><th>预览</th></tr></thead><tbody><tr><td>极限</td><td>\lim</td><td>$\lim$</td></tr><tr><td>无穷</td><td>\infty</td><td>$\infty$</td></tr><tr><td>积分</td><td>\int</td><td>$\int$</td></tr><tr><td>重积分</td><td>\int（i 的个数为重数）</td><td>$\iiint$</td></tr><tr><td>曲线积分</td><td>\oint</td><td>$\oint$</td></tr></tbody></table></div><h4 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h4><div class="table-container"><table><thead><tr><th>运算</th><th>语法</th><th>预览</th></tr></thead><tbody><tr><td>度数</td><td>90^\circ</td><td>$90^\circ$</td></tr><tr><td>∠</td><td>\angle</td><td>$\angle$</td></tr><tr><td>sin</td><td>\sin</td><td>$\sin$</td></tr><tr><td>cos</td><td>\cos</td><td>$\cos$</td></tr><tr><td>tan</td><td>\tan</td><td>$\tan$</td></tr></tbody></table></div><h3 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h3><div class="table-container"><table><thead><tr><th>字母</th><th>语法</th><th>预览</th></tr></thead><tbody><tr><td>Δ</td><td>\Delta</td><td>$\Delta$</td></tr><tr><td>Θ</td><td>\Theta</td><td>$\Theta$</td></tr><tr><td>Σ</td><td>\Sigma（’S’ 大写）</td><td>$\Sigma$</td></tr><tr><td>Ω</td><td>\Omega（’O’ 大写）</td><td>$\Omega$</td></tr><tr><td>α</td><td>\alhpa</td><td>$\alpha$</td></tr><tr><td>β</td><td>\beta</td><td>$\beta$</td></tr><tr><td>γ</td><td>\gamma</td><td>$\gamma$</td></tr><tr><td>δ</td><td>\delta</td><td>$\delta$</td></tr><tr><td>ϵ</td><td>\epsilon</td><td>$\epsilon$</td></tr><tr><td>η</td><td>\eta</td><td>$\eta$</td></tr><tr><td>θ</td><td>\theta</td><td>$\theta$</td></tr><tr><td>κ</td><td>\kappa</td><td>$\kappa$</td></tr><tr><td>λ</td><td>\lambda</td><td>$\lambda$</td></tr><tr><td>μ</td><td>\mu</td><td>$\mu$</td></tr><tr><td>ν</td><td>\nu</td><td>$\nu$</td></tr><tr><td>π</td><td>\pi</td><td>$\pi$</td></tr><tr><td>σ</td><td>\sigma（’s’ 小写）</td><td>$\sigma$</td></tr><tr><td>τ</td><td>\tau</td><td>$\tau$</td></tr><tr><td>ω</td><td>\omega（’o’ 小写）</td><td>$\omega$</td></tr><tr><td>ξ</td><td>\xi</td><td>$\xi$</td></tr><tr><td>ρ</td><td>\rho</td><td>$\rho$</td></tr></tbody></table></div><h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><h4 id="求和公式"><a href="#求和公式" class="headerlink" title="求和公式"></a>求和公式</h4><pre><code>\displaystyle \sum_{i=1}^n \frac{1}{i}</code></pre><p>预览：</p><script type="math/tex; mode=display">\displaystyle \sum_{i=1}^n \frac{1}{i}</script><h4 id="求积公式"><a href="#求积公式" class="headerlink" title="求积公式"></a>求积公式</h4><pre><code>\displaystyle \prod_{i=1}^n i</code></pre><p>预览：</p><script type="math/tex; mode=display">\displaystyle \prod_{i=1}^n i</script><h4 id="求积分"><a href="#求积分" class="headerlink" title="求积分"></a>求积分</h4><pre><code>\displaystyle \int_0^{1} x dx</code></pre><p>预览：</p><script type="math/tex; mode=display">\displaystyle \int_0^{1} x dx</script><h4 id="求极限"><a href="#求极限" class="headerlink" title="求极限"></a>求极限</h4><pre><code>\displaystyle \lim_{n \rightarrow +\infty} \frac{1}{n(n+1)}</code></pre><p>预览：</p><script type="math/tex; mode=display">\displaystyle \lim_{n \rightarrow +\infty} \frac{1}{n}</script>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 基础语法</title>
      <link href="/2018/01/22/markdown-basic/"/>
      <url>/2018/01/22/markdown-basic/</url>
      
        <content type="html"><![CDATA[<p><font color="#008000"> [Updated] </font> 本文记录了 Markdown 基础语法</p><a id="more"></a><h1 id="Markdown-基础语法"><a href="#Markdown-基础语法" class="headerlink" title="Markdown 基础语法"></a>Markdown 基础语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure><h3 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h3><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><hr><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*这是斜体*</span></span><br><span class="line"><span class="emphasis">_这是斜体_</span></span><br><span class="line"><span class="strong">**这是粗体**</span></span><br><span class="line"><span class="strong">__这是粗体__</span></span><br><span class="line"><span class="strong">***这是粗斜体**</span>*</span><br><span class="line"><span class="strong">___这是粗斜体__</span>_</span><br></pre></td></tr></table></figure><h3 id="预览-1"><a href="#预览-1" class="headerlink" title="预览"></a>预览</h3><p><em>这是斜体</em></p><p><em>这是斜体</em></p><p><strong>这是粗体</strong></p><p><strong>这是粗体</strong></p><p><strong><em>这是粗斜体</em></strong></p><p><strong><em>这是粗斜体</em></strong></p><hr><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">* </span>第一项</span><br><span class="line"><span class="bullet">* </span>第二项</span><br><span class="line"></span><br><span class="line"><span class="bullet">+ </span>第一项</span><br><span class="line"><span class="bullet">+ </span>第二项</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>第一项</span><br><span class="line"><span class="bullet">- </span>第二项</span><br></pre></td></tr></table></figure><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>第一项</span><br><span class="line"><span class="bullet">2. </span>第二项</span><br><span class="line"><span class="bullet">3. </span>第三项</span><br></pre></td></tr></table></figure><h4 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>第一项</span><br><span class="line"><span class="bullet">2. </span>第二项</span><br><span class="line"><span class="bullet">    - </span>第一项</span><br><span class="line"><span class="bullet">    - </span>第二项</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>第一项</span><br><span class="line"><span class="bullet">    - </span>第一项</span><br><span class="line"><span class="bullet">    - </span>第二项</span><br><span class="line"><span class="bullet">- </span>第二项</span><br></pre></td></tr></table></figure><h3 id="预览-2"><a href="#预览-2" class="headerlink" title="预览"></a>预览</h3><h4 id="无序列表-1"><a href="#无序列表-1" class="headerlink" title="无序列表"></a>无序列表</h4><ul><li>第一项</li><li>第二项</li></ul><ul><li>第一项</li><li>第二项</li></ul><ul><li>第一项</li><li>第二项</li></ul><h4 id="有序列表-1"><a href="#有序列表-1" class="headerlink" title="有序列表"></a>有序列表</h4><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h4 id="嵌套列表-1"><a href="#嵌套列表-1" class="headerlink" title="嵌套列表"></a>嵌套列表</h4><ol><li>第一项</li><li>第二项<ul><li>第一项</li><li>第二项</li></ul></li></ol><ul><li>第一项<ul><li>第一项</li><li>第二项</li></ul></li><li>第二项</li></ul><hr><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 最外层</span></span><br><span class="line">&gt;&gt; 第一层嵌套</span><br><span class="line">&gt;&gt;&gt; 第二层嵌套</span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 区块列表</span></span><br><span class="line"><span class="quote">&gt; 1. 第一项</span></span><br><span class="line"><span class="quote">&gt; 2. 第二项</span></span><br><span class="line"><span class="quote">&gt; 3. 第三项</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>第一项</span><br><span class="line"><span class="code">    &gt; 外层区块</span></span><br><span class="line"><span class="code">        &gt; 内外层区块</span></span><br><span class="line"><span class="bullet">- </span>第二项</span><br></pre></td></tr></table></figure><h3 id="预览-3"><a href="#预览-3" class="headerlink" title="预览"></a>预览</h3><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote><p>区块列表</p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol></blockquote><ul><li>第一项<blockquote><p>区块</p></blockquote></li><li>第二项</li></ul><hr><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><h4 id="单行代码"><a href="#单行代码" class="headerlink" title="单行代码"></a>单行代码</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`import sys`</span></span><br></pre></td></tr></table></figure><h4 id="多行代码"><a href="#多行代码" class="headerlink" title="多行代码"></a>多行代码</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```python    &lt;-指定语言</span></span><br><span class="line"><span class="code">`import sys`</span></span><br><span class="line"><span class="code">```.</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import sys   &lt;-一个Tab指定代码区块</span><br></pre></td></tr></table></figure><h3 id="预览-4"><a href="#预览-4" class="headerlink" title="预览"></a>预览</h3><h4 id="单行代码-1"><a href="#单行代码-1" class="headerlink" title="单行代码"></a>单行代码</h4><p><code>import sys</code></p><h4 id="多行代码-1"><a href="#多行代码-1" class="headerlink" title="多行代码"></a>多行代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br></pre></td></tr></table></figure><p>或</p><pre><code>import sys</code></pre><hr><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><h4 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">col1 | col2 | col3</span><br><span class="line"><span class="bullet">- </span>| - | -</span><br><span class="line">row1<span class="emphasis">_1 | row1_</span>2 | row1_3</span><br><span class="line">row2<span class="emphasis">_1 | row2_</span>2 | row2_3</span><br></pre></td></tr></table></figure><h4 id="预览-5"><a href="#预览-5" class="headerlink" title="预览"></a>预览</h4><div class="table-container"><table><thead><tr><th>col1</th><th>col2</th><th>col3</th></tr></thead><tbody><tr><td>row1_1</td><td>row1_2</td><td>row1_3</td></tr><tr><td>row2_1</td><td>row2_2</td><td>row2_3</td></tr></tbody></table></div><hr><h2 id="插入链接-图片"><a href="#插入链接-图片" class="headerlink" title="插入链接/图片"></a>插入链接/图片</h2><h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><h4 id="插入普通链接"><a href="#插入普通链接" class="headerlink" title="插入普通链接"></a>插入普通链接</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">本站地址</span>](<span class="link">https://xhzs.github.io/</span>)</span><br><span class="line"></span><br><span class="line">这是本站地址：&lt;[链接地址](https://xhzs.github.io/)&gt;</span><br></pre></td></tr></table></figure><h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"图片的本地/线上地址"</span> <span class="attr">width</span>=<span class="string">"50%"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="预览-6"><a href="#预览-6" class="headerlink" title="预览"></a>预览</h3><h4 id="普通链接"><a href="#普通链接" class="headerlink" title="普通链接"></a>普通链接</h4><p><a href="https://xhzs.github.io/" target="_blank" rel="noopener">这是本站地址</a></p><p>这是本站地址：<a href="[链接地址](https://xhzs.github.io/)">[链接地址](https://xhzs.github.io/)</a></p><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p><img src="//ijkter.github.io/2018/01/22/markdown-basic/线上地址" width="50%"></p>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决 chrome 下 jupyter-notebook 异常问题</title>
      <link href="/2018/01/16/chrome-jupyter-exception/"/>
      <url>/2018/01/16/chrome-jupyter-exception/</url>
      
        <content type="html"><![CDATA[<p><font color="#008000"> [Updated] </font>本文记录了 chrome 运行 jupyter-notebook 所出现的异常及解决方法</p><a id="more"></a><h1 id="解决-chrome-下-jupyter-notebook-异常问题"><a href="#解决-chrome-下-jupyter-notebook-异常问题" class="headerlink" title="解决 chrome 下 jupyter-notebook 异常问题"></a>解决 chrome 下 jupyter-notebook 异常问题</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>chrome 下使用 jupyter-notebook 出现以下问题：</p><ul><li>按 tab 键补全后自动移至下一单元格</li><li>括号自动补全出问题。如：按 “(“ 打印 “(()”</li></ul><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>开启了某些 chrome 扩展程序所致</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>采用排除法测试出引起问题的 chrome 拓展程序，将其关闭</p>]]></content>
      
      
      <categories>
          
          <category> chrome 使用问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chrome </tag>
            
            <tag> jupyter-notebook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决 chrome 安装插件失败问题</title>
      <link href="/2018/01/14/chrome-install-extension/"/>
      <url>/2018/01/14/chrome-install-extension/</url>
      
        <content type="html"><![CDATA[<p><font color="#008000"> [Updated] </font>本文记录了 chrome 离线安装插件失败的问题及解决方法</p><a id="more"></a><h1 id="解决-chrome-安装插件失败问题"><a href="#解决-chrome-安装插件失败问题" class="headerlink" title="解决 chrome 安装插件失败问题"></a>解决 chrome 安装插件失败问题</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>chrome 离线安装插件失败。页面左上角显示：</p><blockquote><p>Package is invalid:’CRX_HEADER_INVALID’</p></blockquote><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>以安装 example.crx 为例：</p><ol><li>备份 example.crx，以防误操作或错误情况</li><li>将 example.crx 更改后缀名为 .rar 或 .zip</li><li>解压 example.rar(.zip) 到 example 文件夹，文件夹内包含：example.js、icon.png、manifest.json</li><li>打开 chrome 拓展页面，右上角开关开启开发者模式后，左上角点击“加载已解压拓展程序”，选择步骤 3 中解压的 example 文件夹，安装成功</li></ol>]]></content>
      
      
      <categories>
          
          <category> chrome 使用问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理</title>
      <link href="/2018/01/06/computer-struct/"/>
      <url>/2018/01/06/computer-struct/</url>
      
        <content type="html"><![CDATA[<p><font color="#008000"> [Updated] </font>本文梳理了《计算机组成原理》的基础知识</p><a id="more"></a><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><div class="table-container"><table><thead><tr><th style="text-align:center">Chapter 1</th><th style="text-align:center">Chapter 2</th><th style="text-align:center">Chapter 3</th><th style="text-align:center">Chapter 4</th><th style="text-align:center">Chapter 5</th><th style="text-align:center">Chapter 6</th><th style="text-align:center">Chapter 7</th><th style="text-align:center">Chapter 8</th></tr></thead><tbody><tr><td style="text-align:center"><a href="#bus">总线</a></td><td style="text-align:center"><a href="#mm">存储器</a></td><td style="text-align:center"><a href="#io">I/O</a></td><td style="text-align:center"><a href="#cal">计算的运算方法</a></td><td style="text-align:center"><a href="#instruct">指令系统</a></td><td style="text-align:center"><a href="#cpu">CPU</a></td><td style="text-align:center"><a href="#cu1">控制单元</a></td><td style="text-align:center"><a href="#cu2">控制单元的设计</a></td></tr></tbody></table></div><hr><h4 id="总线"><a href="#总线" class="headerlink" title="总线"></a><span id="bus">总线</span></h4><ul><li><p>判优控制</p><p>  ！当总线上各个主设备同时请求占用总线时，总线控制器按一定优先等级确定某个设备可以占用总线。</p><p>  ？总线特点为某一刻时刻只允许一个设备向总线发送信息，若两个以上部件同时向总线发送信息，势必导致信号冲突传输无效。</p><ul><li>链式查询<ul><li>1 BR、1 BS、1 BG</li><li>优：优先级固定；结构简单、易扩充</li><li>缺：电路故障敏感，第i个有故障，第i个以后皆无法工作</li></ul></li><li>计数器定时查询<ul><li>1 BR、1 BS、1bN设备地址线</li><li>优：优先级可不固定；电路故障不如链式查询敏感</li><li>缺：控制比链式查询复杂</li></ul></li><li>独立请求<ul><li>N BR、N BS、N BG</li><li>优：响应速度快；优先级控制灵活，可预先固定，也可通过程序改变；可屏蔽设备请求</li><li>缺：仲裁线路复杂</li></ul></li></ul></li><li><p>通信控制</p><p>  ！解决通信双方如何获知传输开始和传输结束，以及通信双方如何协调配合。</p><p>  ？因为总线由众多部件共享，在传送时间上只能用分时方式解决，故通信双方必须按某种约定的方式进行通信。</p><ul><li>同步通信<ul><li>采用公共时钟信号控制，统一传输周期（必须按最慢速度部件设计）</li><li>适用：总线长度较短，各部件存取时间相较一致</li></ul></li><li>异步通信<ul><li>没有公共时钟，采用应答式通信，无固定传输周期</li><li>全互锁（完全制约，可靠性最高）/半互锁（简单制约）/不互锁（无制约）</li><li>适用：总线各部件速度不一致</li></ul></li><li>分离式通信<ul><li>总线传输周期分为两个子周期供不同模块占用，总线上无等待时间，最充分发挥了总线的有效占用</li></ul></li><li>半同步通信<ul><li>既有公共时钟，又允许速度不同的模块和谐工作，采用插入等待周期的措施协调通信双方的配合问题</li></ul></li></ul></li><li><p>串行传输与并行传输</p><ul><li>串行传输<ul><li>数据在一条线路上按位依次传输</li><li>成本低，但速度慢，适合远距离的传输</li></ul></li><li>并行传输<ul><li>每个数据位都有一条独立传输线路，所有数据按位同时传输</li><li>成本高，速度快，适合近距离、高速传输</li></ul></li></ul></li><li><p>总线复用</p><ul><li>不同信号（数据/地址）共用同一组物理线路，分时使用</li><li>需先给地址信号，然后用地址锁存信号将其保存</li></ul></li><li><p>总线带宽（MBps）：单位时间总线上可传输数据位数，也称“数据传输率”</p><ul><li>影响因素：总线宽度、传输距离、主频</li><li>总线带宽 = 一个传输周期传输字节数/时钟周期 | 一个传输周期传输字节数*时钟频率</li></ul></li></ul><hr><h4 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a><span id="mm">存储器</span></h4><ul><li><p>芯片：16K×8位/16KB</p><ul><li>地址线 = 14根</li><li>数据线 = 32根</li><li>引出线最少数目 = 数据线+地址线+2</li></ul></li><li><p>多体结构存储器</p><p>  将存储器分成若干个（n个）独立的模块，每个模块的容量和存取周期均相等，且可独立进行读写操作。将独立模块：</p><ul><li>高位交叉编址<ul><li>各模块分别响应不同请求源，实现多体并行</li><li>高位—存体号，低位—选择存储体内的字</li></ul></li><li>低位交叉编址，<ul><li>不改变存取周期的前提下，增加存储器带宽，n个模块则带宽提高至n倍</li><li>高位—选择存储体内的字，低位—存体号</li><li>存取周期T，总线传输周期t，连续读取n个字时间=T+（n-1）t</li></ul></li></ul></li><li><p>提高访存的措施</p><ul><li>采用高速器件，选用存取周期短的芯片，提高存储器速度</li><li>采用缓存，CPU将近期要用的信息先调入缓存，而缓存速度比主存快得多，CPU从缓存存取信息则缩短访存时间，提高了访存速度</li><li>调整主存结构，如采用单体多字结构或多体结构（都增加存储器带宽）</li></ul></li><li><p>程序访问的局部性原理</p><ul><li>由于指令和数据在主存的地址分布不是随机的，而是相对地聚簇，故程序执行时对存储器的访问使不均匀的</li><li>利用该原理：对缓存-主存，把CPU最近期执行的程序放在容量较小速度较高的缓存中；对主存-辅存，把程序中访问频度高、比较活跃的部分放在主存中。既提高了访存速度又扩大了存储器容量</li></ul></li><li><p>地址映射（硬件完成）</p><ul><li>直接<ul><li>假设C块缓存，每个主存块j只与一个缓存块i对应：i = j mod C</li><li>映射简单，但主存块只能固定对应某个缓存块，不够灵活、命中率低</li></ul></li><li>全相联<ul><li>主存任一块都可以映射到缓存中的任一块上</li><li>灵活、命中率高，但所需电路多、成本高</li></ul></li><li>组相联<ul><li>把缓存分Q组，组内分R块，主存块号j映射到缓存组号i内任一块：i = j mod Q，缓存内1~R任一块</li><li>比直接灵活、命中率高，比全相联成本低，是两者的折中，广泛应用</li></ul></li></ul></li><li><p>三级存储系统（平衡—速度、容量、价格）</p><ul><li>高速缓存<ul><li>解决：CPU和主存速度匹配，提高访存速度缓存</li><li>管理：硬件和操作系统完成</li><li>地址对用户透明</li></ul></li><li>虚存<ul><li>解决：扩大存储容量</li><li>管理：硬件和操作系统完成</li><li>CPU不直接访问二级存储器</li></ul></li></ul></li><li><p>RAM刷新</p><ul><li>方式：集中/分散/异步</li><li>原因：存储电荷电容放电    </li></ul></li></ul><hr><h4 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a><span id="io">I/O</span></h4><ul><li><p>I/O编址方式</p><ul><li>独立编址：I/O地址与主存地址分开，不占主存容量，但需要专用I/O指令访I/O</li><li>统一编址：在主存地址划出一定范围作I/O地址，通过访存指令访问I/O，但减少了主存容量</li></ul></li><li><p>主机与I/O交换信息的控制方式</p><ul><li>程序查询<ul><li>主机与I/O串行工作</li></ul></li><li>程序中断<ul><li>主机与I/O并行工作,主程序和信息传送串行</li></ul></li><li>DMA<ul><li>主机与I/O并行工作,主程序和信息传送并行</li></ul></li><li>通道</li><li>I/O处理机</li></ul></li><li><p>程序查询</p><ul><li>CPU启动I/O后停止现行程序，插入一段程序时刻查询I/O设备准备状况，等待I/O准备就绪时可实现信息交换，存在“踏步”现象</li></ul></li><li><p>程序中断</p><ul><li>管理（多重）中断硬件<ol><li>中断请求触发器（INT）：标志中断源向CPU提出中断请求</li><li>中断屏蔽触发器（MASK）：为“1”表示屏蔽该中断源</li><li>排队器：中断判优</li><li>向量地址形成部件：产生中断源向量地址</li><li>允许中断触发器（EINT）：为“1”允许处理中断</li><li>中断标志触发器（INTR）：标志进入中断周期</li><li>堆栈：保护现场</li><li>中断查询信号电路：每条指令执行周期结束时刻，向各中断源发查询信号</li></ol></li><li>过程：<ol><li>中断请求：CPU启动I/O设备，I/O准备就绪后向CPU提出中断请求</li><li>中断判优：中断判优逻辑选择优先级最高的中断请求，待CPU处理</li><li>中断响应：若INT（中断请求触发器）为”1”且请求中断设备未被屏蔽，系统进入中断响应周期—CPU自动执行中断隐指令[ 硬件完成：保护程序断点(即PC内容)、硬件关中断、向量地址送PC（硬件向量法）或中断识别程序入口地址送PC（软件查询法） ]</li><li>中断服务：中断响应周期结束，CPU转入取指周期，按向量地址取出无条件转移指令（或按向量地址查入口地址表）；转至向量地址对应的中断程序服务入口地址，开始执行中断服务程序[ 保护现场（PC内容—中断隐指令；寄存器内容—软件编程）、与I/O传送信息、恢复现场 ]</li><li>中断返回：中断服务程序最后一条即中断返回指令（返回程序断点）</li></ol></li><li>响应条件和时间：<ul><li>条件：EINT为“1”（即开中断）；中断请求未被屏蔽，且排队后被选中</li><li>时间：指令执行阶段的结束时刻，CPU发出中断查询信号，才能获取中断请求信号</li></ul></li><li>向量地址<ul><li>存放服务程序入口地址的存储单元地址，由硬件形成</li><li>当有中断请求且排队选中时，通过自由组合逻辑电路组成的向量地址形成部件可形成向量地址</li><li>输入：排队器；输出：中断周期送至PC；传送：<strong>数据总线</strong></li></ul></li><li>开/关中断<ul><li>EINT为“1”时，允许CPU响应中断；EINT为“0”时，CPU不能响应中断</li><li>关中断即将EINT置“0”；开中断即置“1”</li></ul></li></ul></li><li><p>多重中断(主要区别在中断服务程序)：CPU处理中断过程中出现新的中断请求，暂停现行中断处理转至处理新的中断</p><ul><li>多重中断条件<ul><li>必须重新开中断</li><li>优先级更高的中断请求才能中断现行程序（内部中断&gt;不可屏蔽中断&gt;可屏蔽中断）</li></ul></li><li>单重中断：保护现场-&gt;设备服务-&gt;恢复现场-&gt;<strong>开中断</strong>-&gt;中断返回</li><li>多重中断：保护现场-&gt;<strong>开中断</strong>-&gt;设备服务-&gt;恢复现场-&gt;中断返回</li></ul></li><li><p>中断服务程序与调用子程序区别</p><ol><li>中断服务程序与中断时CPU正在运行程序相互独立；子程序与CPU正在运行程序是同一程序的两部分</li><li>除了软中断，中断通常随机产生；子程序调用由CALL指令引起</li><li>中断服务程序入口地址可通过硬件向量法产生向量地址，再由向量地址找到入口地址；子程序调用入口地址由CALL指令地址码给出</li><li>中断需要对多个同时发生的中断进行裁决；子程序调用无此操作</li></ol><ul><li>都要保护程序断点：前者中断隐指令完成；后者CALL指令完成</li><li>都要保护寄存器内容的操作</li></ul></li><li><p>中断和DMA区别</p><ul><li>数据传送：中断靠程序传送；DMA靠硬件传送</li><li>CPU响应时间：中断在一条指令执行结束时响应；DMA在存取周期结束时响应</li><li>异常处理能力：中断有；DMA无</li><li>保护现场：中断需中断现行程序，需保护现场；DMA不需中断现行程序，无需保护现场</li><li>优先级：DMA高于中断</li></ul></li><li><p>DMA</p><ul><li>特点：<ul><li>I/O和CPU并行工作</li><li>主存和I/O接口间有一条直接数据通路</li><li>不中断现行程序，无需保护、恢复现场</li><li>DMA请求占用总线时，若采用周期挪用，CPU暂停一个存取周期访问主存，但可继续自身内部操作（如乘法），即DMA传送和主程序并行</li></ul></li><li>硬件：数据缓存寄存器、DAR、AR、WC、中断机构、DMA控制逻辑</li><li>过程：<ul><li>预处理<ol><li>指明数据传送方向输入（读）/输出（写）</li><li>设备地址送DAR（设备地址寄存器）</li><li>主存地址送AR（主存地址计数器）</li><li>传送数据字数送WC（字计数器）</li><li>启动设备</li></ol></li><li>数据传送<ol><li>主存地址送总线</li><li>数据送I/O设备（或主存）</li><li>修改主存地址和WC</li><li>重复直至数据块传送结束</li></ol></li><li>后处理<ol><li>由中断服务程序作DMA结束处理（测试传送过程是否出错、决定是否继续使用DMA传送数据）</li></ol></li></ul></li><li>DMA和CPU分时使用主存：<ul><li>停止CPU访存<ul><li>DMA在传送数据时独占主存，CPU放弃总线使用权，基本处于不工作或保持原状态，直至DMA传送结束</li></ul></li><li>周期挪用<ul><li>一旦I/O有DMA请求，由I/O设备挪用一个存取周期。此时CPU<strong>可完成自身操作，但要停止访存</strong></li></ul></li><li>DMA和CPU交替访存<ul><li>适用<strong>CPU工作周期比主存存取周期长</strong>时。CPU工作周期的上下半周期由DMA和CPU交替使用访存，使DMA传送和CPU工作效率最高，但硬件逻辑复杂</li></ul></li></ul></li></ul></li></ul><hr><h4 id="计算的运算方法"><a href="#计算的运算方法" class="headerlink" title="计算的运算方法"></a><span id="cal">计算的运算方法</span></h4><ul><li><p>判溢出</p><ul><li>定点机<ul><li>参与运算的两个操作数符号相同，结果的符号与原操作数符号不同，则溢出</li><li>求和时最高进位与次高进位异或结果为1，则溢出</li></ul></li><li>浮点机判溢出<ul><li>当阶码大于最大正阶码时，则溢出</li><li>当阶码小于最小负阶码时，则按机器零处理</li></ul></li></ul></li><li><p>进位：影响加减运算速度的关键</p><ul><li>进位链：传递进位的逻辑电路</li><li>先行进位：高位进位和低位进位同时产生<ul><li>单重分组跳跃进位<ul><li>n位全加器分若干小组，组内进位同时产生，组间串行进位</li></ul></li><li>多重分组跳跃进位<ul><li>n位全加器分若干大组，若干大组内又包含若干小组，大组内各小组进位同时产生，小组内进位同时产生，大组间串行进位</li><li>快于单重，但线路更复杂</li></ul></li></ul></li></ul></li></ul><hr><h4 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a><span id="instruct">指令系统</span></h4><ul><li>不同地址格式指令</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">地址格式</th><th style="text-align:center">访存次数</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">四地址</td><td style="text-align:center">4</td><td style="text-align:center">A4指出下条指令地址</td></tr><tr><td style="text-align:center">三地址</td><td style="text-align:center">4</td><td style="text-align:center">PC指出下条指令地址</td></tr><tr><td style="text-align:center">二地址</td><td style="text-align:center">4</td><td style="text-align:center">操作结果存回A1、A2或ACC</td></tr><tr><td style="text-align:center">一地址</td><td style="text-align:center">4</td><td style="text-align:center">ACC存放操作数和结果</td></tr></tbody></table></div><ul><li><p>数据存放方式。存储字长32位，可按字节、半字、字寻址：</p><ul><li>边界对准：数据字地址一定是4的整数倍。所存数据不满足该要求时，填充一个或多个空白字节（浪费存储空间）</li><li>边界不对准：数据字跨两个存储字时需两次访存，并对高低字节位置进行调整后才能取得数据字（影响取数时间）</li></ul></li><li><p>间址/基址/变址：可扩大寻址范围</p><ul><li>通过访存（多次间址多次访存）得到有效地址<ul><li>间址<ul><li>访存导致时间较长（T一次访存 &gt;&gt; T一次寄存器）</li></ul></li></ul></li><li>地址变换（R+A）得到有效地址<ul><li>基址<ul><li>基址寄存器内容由操作系统给定，且在程序执行过程中不可变</li><li>支持多道程序技术的应用</li></ul></li><li>变址<ul><li>变址寄存器内容由用户给定，且在程序执行过程中可变</li><li>适用于处理数组问题</li></ul></li></ul></li></ul></li><li><p>相对/堆栈寻址</p><ul><li>相对：EA = (PC) + A<ul><li>A为位移量（字节），决定寻址范围；可正可负，补码表示</li><li>便于程序浮动，用于转移指令</li></ul></li><li>堆栈：SP +/- ▲ -&gt; PC<ul><li>有效地址在SP中，指令中可少一个指令字段</li><li>▲与主存编址方式相关：按字编址，▲取1；按字节编址，字长16位时▲取2，字长32时▲取4</li></ul></li></ul></li><li><p>RISC（CISC）</p><ol><li>选用频度高简单指令，复杂指令功能由简单指令实现（指令系统复杂庞大）</li><li>指令长度固定，指令格式种类少，寻址方式种类少（不固定、多、多）</li><li>只有LOAD/STORE访存，其余指令皆在寄存器进行（可访存指令不受限制）</li><li>CPU中有多个通用寄存器（设专用寄存器）</li><li>控制器采用组合逻辑控制（微程序）</li><li>采用流水技术，大部分指令1个时钟周期内完成（各指令执行时间相差大，大部分需多个时钟周期）</li><li>采用优化的编译程序（难以用优化编译生成高效代码）</li></ol><ul><li>与CISC比较：<ul><li>提高指令执行速度</li><li>便于设计，可降低硬件设计复杂度</li><li>简化指令功能，有利于编译程序代码优化</li><li>不易实现指令系统兼容</li></ul></li></ul></li></ul><hr><h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a><span id="cpu">CPU</span></h4><ul><li><p>CPU</p><ul><li>功能<ul><li>指令控制：控制程序的顺序执行</li><li>操作控制：产生完成每条指令所需控制命令</li><li>时间控制：对各种操作加以时间上的控制</li><li>数据加工：对数据进行算术和逻辑运算</li><li>中断处理：处理计算机在运行过程中出现的异常情况和特殊请求</li></ul></li><li>组成<ul><li>寄存器<ul><li>PC：存放现行指令地址，位数取决于存储器容量</li><li>IR：存放现行指令，位数取决于指令字长</li><li>通用寄存器：存放数据和地址，位数取决于机器字长</li></ul></li><li>指令译码器 + 控制单元CU：根据指令译码在规定时间发出操作命令</li><li>ALU：算术逻辑运算</li><li>中断系统：处理中断</li></ul></li></ul></li><li><p>指令周期：取指+（间址）+执行+（中断）</p><ul><li>执行 -&gt; 中断周期 -&gt; 取值</li><li>存取周期 -&gt; DMA周期 -&gt; 存取周期（指令周期任一阶段皆可）</li></ul></li><li><p>指令流水</p><ul><li>结构相关<ul><li>硬件资源满足不了指令重叠执行的要求，发生资源冲突</li><li>如：同一时间，几条重叠的指令分别取值、取数、存数，发生访存冲突</li></ul></li><li>数据相关<ul><li>指令重叠执行，可能改变操作数的读写访问顺序，导致数据相关冲突</li><li>如：某条指令需要用到前面指令的执行结果，而这些指令在流水线中重叠执行，可能改变对操作数读写访问顺序</li></ul></li><li>控制相关<ul><li>流水线遇到分支指令或其他改变程序计数器PC的指令，造成指令执行顺序的改变</li><li>如：某条指令需等前面指令做出转移方向的决定才能进入流水线</li></ul></li></ul></li><li><p>流水线多发技术</p><ul><li>超标量流水：每个时钟周期内可同时并发多条独立指令，处理器中需配置多个功能部件和指令译码电路，以便同时执行多个操作</li><li>超流水线：在原来的时钟周期内，功能部件被使用多次</li><li>超长指令字：对编译器要求高，充分挖掘指令间潜在并行性（一个时钟周期内，各功能部件无数据相关），把能并行的指令合成一条具有多个操作码（需相应个数功能部件）的超长指令</li></ul></li><li><p>中断系统</p><ul><li>INTR 与 EINT<ul><li>INTR 中断标志触发器：指示CPU是否进入中断周期</li><li>EINT 允许中断触发器：开放或关闭中断系统<ul><li>置“1”：系统开放，允许中断（开中断指令）</li><li>置“0”：关中断（关中断指令、中断隐指令、硬件自动复位）</li></ul></li></ul></li><li>中断判优：在某一时刻可能有多个中断源（中断源请求随机）提出请求，而CPU只能响应一个，故须判优已解决响应优先次序<ul><li>硬件排队：组合逻辑电路实现</li><li>软件排队：程序按优先级（从高至低）顺序查询各中断源</li></ul></li><li>中断服务程序入口地址寻找<ul><li>硬件向量法（向量中断）：当有中断请求时，由硬件产生该中断源对应的向量地址，再由向量地址找到服务程序的入口地址，然后暂停现行程序转至中断服务程序<ul><li>排队器输出 -&gt; <strong>向量地址形成部件</strong> -&gt; 输出向量地址</li><li>向量地址寻找入口地址方式<ul><li>向量地址单元内存放一条无条件转移指令</li><li>在向量地址单元内直接存放入口地址，形成一个中断向量地址表</li></ul></li></ul></li><li>软件查询法：编写<strong>中断识别程序</strong>实现</li></ul></li><li>屏蔽<ul><li>屏蔽触发器：内容即屏蔽字，每个中断源对应一个屏蔽字，为“1”时CPU不响应该中断源请求</li><li>优先级<ul><li>响应优先级：CPU响应各中断源请求的优先次序，通常硬件线路已设置好，不便改动（不采用屏蔽时）</li><li>处理优先级：CPU实际对各中断源请求的处理优先次序（采用屏蔽）</li></ul></li><li>采用屏蔽技术的中断服务流程<ul><li>保护现场 -&gt; 置屏蔽字 -&gt; 开中断 -&gt; 中断服务 -&gt; 关中断 -&gt; 恢复现场 -&gt; 恢复屏蔽字 -&gt; 开中断 -&gt; 中断返回</li></ul></li><li>作用<ul><li>改变处理优先级</li><li>为实现多重中断，屏蔽低级别中断请求对现行中断处理程序的干扰 </li><li>封锁部分中断请求，使程序控制更灵活</li></ul></li></ul></li></ul></li></ul><hr><h4 id="控制单元"><a href="#控制单元" class="headerlink" title="控制单元"></a><span id="cu1">控制单元</span></h4><ul><li><p>控制单元CU</p><ul><li>功能：发出各种操作命令(即控制信号)</li><li>受控制：指令寄存器(操作码)、时钟、标志、系统总线控制信号(中断)</li></ul></li><li><p>多级时序</p><ul><li>指令周期：完成（取出并执行）一条指令所需的时间</li><li>机器周期：指令执行过程中一个基准时间，通常以<strong>存取周期</strong>作为机器周期（因为完成指令都需取指，而一次访存时间固定）。一个机器周期内完成若干微操作，可通过节拍控制产生每一个微操作命令</li><li>时钟周期：主频（时钟信号的频率）的倒数，也可称为节拍（时钟信号控制产生，每个节拍宽度对应一个时钟周期）。一个节拍内完成若干需同时执行的操作，是控制计算机操作的最小时间单位</li><li>三者关系：每个指令周期含若干个机器周期，可不相等；每个机器周期含若干个时钟周期（节拍），可不相等</li><li>机器速度：同主频下， 机器周期中时钟周期数和指令周期中机器周期数不同，机器速度不同。（机器周期中含时钟周期少的机器速度更快）</li></ul></li><li><p>控制方式</p><ul><li>同步控制：微操作受统一基准时标时序信号控制。存取周期不统一时，取最长存取周期作为机器周期<ul><li>采用定长的机器周期：采用完全统一、具有相同时间间隔和相同数目节拍</li><li>采用不定长的机器周期：机器周期内节拍数可不等；大多数微操作一个机器周期内完成，复杂微操作延长机器周期或增加节拍</li><li>采用中央控制和局部控制相结合的方法：大部分中央控制，少数局部控制<ul><li>局部控制每一个节拍T*宽度与中央控制节拍宽度相同</li><li>局部控制节拍作为中央控制中机器节拍的延续，插入中央控制的执行周期</li></ul></li></ul></li><li>异步控制：不存在基准时标信号，微操作时序由专用的应答线路控制。控制器发出某一个微操作命令后，等待执行部件完成该操作时所发回的应答信号，再开始执行下一个操作</li><li>联合控制：同步与异步结合。即大多数微操作在同步时序信号控制下进行，而对时间难以确定的微操作（如I/O相关）采用异步控制</li></ul></li></ul><hr><h4 id="控制单元设计"><a href="#控制单元设计" class="headerlink" title="控制单元设计"></a><span id="cu2">控制单元设计</span></h4><ul><li><p>组合逻辑控制器</p><ul><li>采用硬连线逻辑：一个微操作命令对于一个逻辑电路</li><li>思路清晰，简单明了</li><li>结构复杂，线路复杂。一旦构成，除非物理上重新连线，否则无法增加新的控制功能</li></ul></li><li><p>组合逻辑与微程序控制组成异同</p><ul><li>同：均有PC、IR、时序电路、中断系统、状态条件</li><li><p>异：</p><ul><li>微操作命令序列形成部件不同。组合逻辑核心部件—门电路；微程序核心部件—控制存储器ROM(存放全部微程序)</li><li><p>微操作命令及节拍安排的主要差别：</p><ul><li><p>取指阶段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OP(IR) -&gt; ID    //组合逻辑：指令操作码送指令译码器</span><br><span class="line">OP(IR) -&gt; 微地址形成部件   //微程序：指令操作码送微地址形成部件</span><br></pre></td></tr></table></figure></li><li><p>微程序每条指令都要增加一个将微指令下地址字段送CMAR的微操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ad(CMDR) -&gt; CMAR</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul><ul><li>微程序控制器<ul><li>采用存储逻辑：每条机器指令编写成一个微程序，每一个微程序包含若干条微指令（操作控制字段+顺序控制字段），每一条微指令对应一个或几个微操作命令</li><li>优点：规整形、灵活性、可维护性</li><li>控制器中微程序个数 = 机器指令数 + 3（取指/间址/中断周期)</li><li>组成<ul><li>控存：存放全部微程序</li><li>CMAR（控存地址寄存器）：存放欲读出微指令地址。采用增量计数器法形成后续微指令地址时，有计数功能</li><li>CMDR（控存数据寄存器）：存放取出的微指令</li><li>顺序逻辑：控制微指令序列</li><li>输入：微地址形成部件、微指令下地址字段、外来标志</li><li>输出：CPU内部和系统总线的控制信号</li></ul></li><li>微指令编码方式<ul><li>直接编码（直接控制）：操作控制字段每一位代表一个微命令<ul><li>简单直观，输出直接用于控制，执行速度快</li><li>微指令字较长，使控存容量大</li></ul></li><li>字段直接编码（显示编码）：操作控制字段分段，每个字段经译码发出微操作命令，且互斥<ul><li>缩短字长，以较少二进制信息表示较多微命令信号</li><li>增加译码电路，执行速度降低</li></ul></li><li>字段间接编码（隐式编码）：一个字段某些命令需由另一字段某些微命令解释<ul><li>更能缩短微指令字长，但速度更慢</li></ul></li></ul></li><li>微指令序列地址形成<ol><li>直接由微指令的下地址字段给出</li><li>根据机器指令的操作码形成</li><li>增量计数器法，即 （CMAR）+ 1 -&gt; CMAR</li><li>根据各钟标志决定微指令分支转移的地址</li><li>测试网络形成</li><li>硬件直接产生微程序入口地址 </li></ol></li><li>微指令格式<ul><li>水平型：一次能定义<strong>多个并行操作</strong>的微命令。直接编码、字段直接编码、字段间接编码以及直接及混合编码都属于水平型指令格式<ul><li>大多数微命令可直接控制对象，故每条微指令执行时间短</li><li>微指令字长较长，故可用较少微指令数实现一条机器指令的功能</li></ul></li><li>垂直型：采用类似机器指令操作码方式，在微指令中设置<strong>微操作码</strong>字段，由微操作码规定微指令功能<ul><li>经过译码控制对象，影响执行时间</li><li>微指令字长较短，实现一条机器指令微程序比水平型微指令长的多，以较长微程序结构换取较短微指令结构</li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计组 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
