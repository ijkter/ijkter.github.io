<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SQL基础速览]]></title>
    <url>%2F2019%2F07%2F02%2Fsql%2F</url>
    <content type="text"><![CDATA[[Updating] 本文梳理了 SQL 相关基础知识（基于《SQL基础教程》） SQL 基础数据库和SQL数据库是什么数据集合 Why DBMS若以文本文件或电子制表软件（如 Excel）存储文件有以下缺点： 无法多人共享数据 无法提供操作大量数据所需格式 需要编程实现自动化读写 无法保证数据安全（数据丢失、数据窃取） DBMS 可以实现多个用户同事安全简单地操作大量数据 DBMS 种类关系数据库（Relational Database， RDB） 由行和列组成的二维表来管理数据 用专门的 SQL（Structured Query Language，结构化查询语言）对数据进行操作 常见 RDB：Oracle、SQL Server、MySQL 键值存储系统（Key-Value Store， KVS） 单纯保存查询所使用的主键（Key）和值（Value）的组合（类似 hash） 适合大量数据超高速查询 常见 KVS：Redis 面向对象数据库（Object Oriented Database， OODB）面向对象程序设计中保存对象（数据及其操作的集合）的数据库 XML 数据库（XML Database， XMLDB） XML：使用类似 HTML 标签来表现数据结构的语言 XML 数据库常用于存储网络交互数据，可以对 XML 形式的大量数据进行高速处理 层次数据库（Hierarchical Database， HDB） 把数据通过层次结构（树形结构）的方式表现出来 曾经主流，现已少用 数据库的结构RDBMS的常见系统结构表的结构SQL 概要标准 SQL国际标准化组织（ISO）为 SQL 制定的相应标准，适用于各种 RDBMS SQL 语句及其种类由关键字、表名、列名等组合而成一条 SQL 语句描述操作的内容 DDL（Data Definition Language，数据定义语言）用来创建或者删除存储数据用的数据库以及数据库中的表等对象。包含指令： CREATE： 创建数据库和表等对象 DROP： 删除数据库和表等对象 ALTER： 修改数据库和表等对象的结构 DML（Data Manipulation Language，数据操纵语言）用来查询或者变更表中的记录。包含指令： SELECT：查询表中的数据 INSERT：向表中插入新数据 UPDATE：更新表中的数据 DELETE：删除表中的数据 DCL（Data Control Language，数据控制语言）用来确认或者取消对数据库中的数据进行的变更。除此之外，还可以对 RDBMS 的用户是否有权限操作数据库中的对象（数据库表等）进行设定。包含指令： COMMIT： 确认对数据库中的数据进行的变更 ROLLBACK： 取消对数据库中的数据进行的变更 GRANT： 赋予用户操作权限 REVOKE： 取消用户的操作权限 SQL 的基本书写规则 以分号（；）结尾 SQL 不区分关键字大小写；表中数据区分大小写 SQL 一般书写原则： 关键字大写 表名首字母大写 其余（列名）小写 SQL 子句的顺序不能改变，也不能互相替换 表的创建数据库的创建（CREATE DATABASE语句）1CREATE DATABASE &lt;数据库名&gt;; 表的创建（CREATE TABLE语句）123456CREATE TABLE &lt;表名&gt;(&lt;列名1&gt; &lt;数据类型&gt; &lt;该列所需约束&gt;, &lt;列名2&gt; &lt;数据类型&gt; &lt;该列所需约束&gt;, …… &lt;列名n&gt; &lt;数据类型&gt; &lt;该列所需约束&gt;, &lt;该表约束1&gt;, &lt;该表约束2&gt;, ……); NOT NULL 约束只能以列为单位进行设置 列的数据类型必须指定 列的约束可以定义时设置，也可以语句末尾设置 命名规则 数据库/表/列名：半角英文字母、数字、下划线(_) 标准 SQL 中名称必须以半角英文字母开头 名称不能重复 数据类型的指定 INTEGER：整数 CHAR：定长字符串 括号中指定可存储字符串长度 超出部分无法输入到列中 不足部分由半角空格进行补足。如：char(10)存”123”，存储字符占10个字节。取数据的时候，char类型的要用trim()去掉多余的空格 比 VARCHAR 效率高，空间换时间 VARCHAR：可变长字符串 括号指定最大长度 不足部分不会使用半角空格进行补足，会自动裁剪。如：varchar(10)存”123”，存储字符占3个字节 比 CHAR 节省空间 DATE：日期 含年/月/日 Oracle 中 DATE 型还包含时分秒 约束的设置 键：指定特定数据时使用的列的组合 主键（primary key）：可以唯一确定一行数据的列（故无法重复） 表的删除和更新表的删除（DROP TABLE语句）1DROP TABLE &lt;表名&gt;; 删除表无法回复，只能重建 避免到需要恢复数据的场景 表定义的更新（ALTER TABLE语句）添加列 1ALTER TABLE &lt;表名&gt; ADD COLUMN &lt;列的定义&gt;; 删除列 1ALTER TABLE &lt;表名&gt; DROP COLUMN &lt;列名&gt;; 表定义变更（ALTER TABLE）之后无法恢复 不同数据库提供不同变更表名（RENAME）（非标准 SQL）指令。如：MySQL 中， 1RENAME TABLE &lt;原表名&gt; to &lt;新表名&gt;; 查询基础SELECT语句基础列的查询12SELECT &lt;列名&gt;，…… FROM &lt;表名&gt;； &lt; * &gt; 按表定义列的顺序列出所有列 不建议使用 &lt; * &gt;；建议列出所有列名，以提高 SQL 可读性 为列设定别名123SELECT 列名1 AS 别名1, 列名2 AS 别名2 FROM 表名; 别名可使用中文，使用时将中文用双引号 &lt;” “&gt; 括起来 别名中空格建议用下划线取代。使用双引号可以设定包含空格的别名，但若忘记使用双引号可能导致错误 从结果中删除重复行使用 DISTINCT 实现删除由选择列出的列合成的数据中的重复行 12SELECT DISTINCT &lt;列名&gt;, …… FROM Product; 使用 DISTINCT 时， NULL 也被视为一类数据（显示为空白） DISTINCT 关键字只能用在第一个列名之前 通过 WHERE 子句来指定查询数据的条件123SELECT &lt;列名&gt;, …… FROM &lt;表名&gt; WHERE &lt;条件表达式&gt;; 书写顺序：WHERE 子句必须紧跟在 FROM 子句之后，否则会造成执行错误 执行顺序：首先通过 WHERE 子句查询出符合指定条件的记录，然后再选取出 SELECT 语句指定的列 注释的书写方法 英汉字皆可 单行注释：书写在 “–” 之后 多行注释：书写在 “/“ 和 “/“ 之间 算术运算符和比较运算符算术运算符SELECT 子句中可以使用常数或者表达式：+ - * ÷ () 所有包含 NULL 的计算，结果肯定是 NULL（包括“NULL/0”的情况，不会报错） FROM 子句在 SELECT 语句中并不是必不可少的，只使用SELECT子句进行计算也是可以的，但使用场景很少。如： 1SELECT (1 + 2) * 3 AS calculation; 存在不允许省略 SELECT 语句中的 FROM 子句的 RDBMS。如：Oracle 比较运算符 =、&lt;、&gt;：等于、小于、大于 &lt;&gt;:不相等。“!=” 非标准 SQL，考虑可移植性和安全问题 , 不建议使用 &lt;=、&gt;=：不大于、不小于。必须不等号在左，等号在右 字符串类型的数据原则上按照字典顺序进行排序。该规则对定长字符串和可变长字符串都适用 SQL 用“IS NULL”和“IS NOT NULL”判断数据是否为NULL。因为SQL 不识别“= NULL”和“&lt;&gt; NULL”，所以不能对 NULL 使用比较运算符 逻辑运算符NOT运算符 NOT 不能单独使用，必须组合其他查询条件表“不是该条件” 为保持程序清晰可读，不滥用 NOT AND 运算符和 OR 运算符 AND 运算符在其两侧的查询条件都成立时整个查询条件才成立，其意思相当于“并且” OR 运算符在其两侧的查询条件有一个成立时整个查询条件都成立，其意思相当于“或者” AND 运算符的优先级高于 OR 运算符 建议使用括号强化优先级，使语句更清晰可读 真值 真值：值为真（TRUE） 或假（FALSE） 其中之一的值 AND 运算的结果与乘法运算（积）的结果一样，称逻辑积 OR 运算的结果与加法运算（和）的结果一样，称逻辑和 SQL 特有情况 – 三值逻辑：除真值外，还存在“不确定”（UNKNOWN）这样的值： P Q P AND Q P OR Q 真 不确定 不确定 真 假 不确定 假 不确定 不确定 真 不确定 真 不确定 假 假 不确定 不确定 不确定 不确定 不确定 建议尽量不使用 NULL，为列设置 NOT NULL 约束，以避免繁琐的条件判断 聚合与排序对表进行聚合查询聚合函数将多行输入汇总为一行输出 COUNT： 计算表中的记录数（行数） COUNT() 特性：不会排除 NULL。故 COUNT()会得到包含 NULL 的数据行数，而 COUNT(&lt;列名&gt;) 会得到 NULL 之外的数据行数 所有的聚合函数，如果以列名为参数，那么在计算之前会把 NULL 排除在外，与“等价为 0”并不相同 SUM： 计算表中 数值列 中数据的合计值 AVG： 计算表中 数值列 中数据的平均值 会事先删除 NULL 同时减少相应数据条数再计算。但也可以选择将 NULL 改变为 0 进行计算 MAX： 求出表中 任意列（如日期） 中数据的最大值 MIN： 求出表中 任意列（如日期）中 数据的最小值 使用聚合函数删除重复值（关键字DISTINCT）12SELECT COUNT(DISTINCT &lt;列名&gt;) FROM &lt;表名&gt;; DISTINCT 必须写在聚合函数参数（即括号）中，因为必须要在执行之前删除列中的重复数据 计算值的种类：在 COUNT() 的参数中使用 DISTINCT 对表进行分组GROUP BY1234SELECT &lt;列名1&gt;, &lt;列名2&gt;, &lt;列名3&gt;, …… FROM &lt;表名&gt; WHERE GROUP BY &lt;列名1&gt;, &lt;列名2&gt;, &lt;列名3&gt;, ……; 聚合键/分组列：GROUP BY 子句中指定的列 书写顺序：SELECT → FROM → WHERE → GROUP BY 执行顺序：FROM → WHERE → GROUP BY → SELECT 聚合键中包含 NULL 时，在结果中会以“不确定”行（空行）的形式表现出来 使用聚合函数和 GROUP BY 注意事项 使用聚合函数时， SELECT 子句中只能存在以下三种元素： 常数 聚合函数 GROUP BY 子句中指定的列名（也就是聚合键） 虽然 MySQL 支持使用GROUP BY子句时， SELECT 子句中出现聚合键之外的列名，但是 MySQL 以外的 DBMS 都不支持这样的语法，因此不建议使用 在 GROUP BY子 句中不能使用 SELECT 子句中定义的别名。根据执行顺序，执行 GROUP BY 子句时，DBMS 还不知道 SELECT 子句中定义的别名 GROUP BY子句结果的显示是无序的。可在 SELECT 语句中进行指定特定顺序 只有 SELECT 子句和 HAVING 子句（以及 ORDER BY 子句）中能够使用聚合函数 DISTINCT 和 GROUP BY：都是通过数据的内部排序处理实现的（执行速度相近），可删除重复数据。根据使用场景，选择能清晰表明语义的写法 为聚合结果指定条件HAVING 子句WHERE 子句只能指定记录（行）的条件，而不能用来指定组的条件。对集合指定条件使用 HAVING 子句： 1234SELECT &lt;列名1&gt;, &lt;列名2&gt;, &lt;列名3&gt;, …… FROM &lt;表名&gt;GROUP BY &lt;列名1&gt;, &lt;列名2&gt;, &lt;列名3&gt;, ……HAVING &lt;分组结果对应的条件&gt; 书写顺序：SELECT → FROM → WHERE → GROUP BY → HAVING 执行顺序：FROM → WHERE → GROUP BY → SELECT HAVING 注意事项 HAVING 子句中只能存在以下三种元素： 常数 聚合函数 GROUP BY 子句中指定的列名（即聚合键） 聚合键所对应的条件应该书写在 WHERE 子句当中，而不应该书写在 HAVING 子句当中。理由如下： HAVING 子句是用来指定“组”的条件的。因此，“行”所对应的条件还是应该写在 WHERE 子句当中，便于理解区分功能 通常情况下，为了得到相同的结果，将条件写在 WHERE 子句中要比写在 HAVING 子句中的处理速度更快，返回结果所需的时间更短 为了理解其中原因，就要从 DBMS 的内部运行机制来考虑。使用 COUNT 函数等对表中的数据进行聚合操作时，DBMS 内部就会进行排序处理。排序处理是会大大增加机器负担的高负荷的处理 A。因此，只有尽可能减少排序的行数，才能提高处理速度。通过 WHERE 子句指定条件时，由于排序之前就对数据进行了过滤，因此能够减少排序的数据量。但 HAVING 子句是在排序之后才对数据进行分的，因此与在 WHERE 子句中指定条件比起来，需要排序的数据量就会多得多。虽然 DBMS 的内部处理不尽相同，但是对于排序处理来说，基本上都是一样的。此外， WHERE 子句更具速度优势的另一个理由是，可以对 WHERE 子句指定条件所对应的列创建索引，这样也可以大幅提高处理速度。创建索引是一种非常普遍的提高 DBMS 性能的方法，效果也十分明显，这对 WHERE 子句来说也十分有利。 对查询结果进行排序ORDER BY子句123SELECT &lt;列名1&gt;, &lt;列名2&gt;, &lt;列名3&gt;, …… FROM &lt;表名&gt; ORDER BY &lt;排序基准列1&gt;, &lt;排序基准列2&gt;, ……; 书写顺序：SELECT → FROM → WHERE → GROUP BY → HAVING → ORDER BY ORDER BY 子句通常写在 SELECT 语句的末尾 未指定 ORDER BY子句中排列顺序时会默认使用升序进行排列；使用 DESC 关键字降序排列 ORDER BY 注意事项 多键排序规则：优先使用左侧的键，如果该列存在相同值的话，再接着参考右侧的键 排序键中包含 NULL 时，会在开头或末尾进行汇总（因为不能对 NULL 使用比较运算符） 在 ORDER BY 子句中可以使用 SELECT 子句中定义的别名。因为 SELECT 子句的执行顺序在 GROUP BY 子句之后， ORDER BY 子句之前 在 ORDER BY 子句中可以使用 SELECT 子句中未使用的列和聚合函数 不要使用列编号指定排序键： 可读性差 SQL-92A 中明确该功能将来会被删除 列编号 – SELECT 子句中的列按照从左到右的顺序进行排列时所对应的编号（1, 2, 3, …） 数据更新数据的插入（INSERT语句的使用方法）INSERT 语句1INSERT INTO &lt;表名&gt; (列1, 列2, 列3, ……) VALUES (值1, 值2, 值3, ……); 原则上，执行一次INSERT语句会插入一行数据,表名后面的列清单和 VALUES 子句中的值清单的列数必须保持一致 很多 RDBMS 都支持多行 INSERT： 1INSERT INTO &lt;表名&gt; (列1, 列2, 列3, ……) VALUES (值1, 值2, 值3, ……), (值1, 值2, 值3, ……) …… ; 列清单的省略 1INSERT INTO &lt;表名&gt; VALUES (值1, 值2, 值3, ……), (值1, 值2, 值3, ……) …… ; 插入NULL：插入 NOT NULL 约束的列会报错 INSERT， DELETE 和 UPDATE 等更新语句也一样，SQL 语句执行失败时都不会对表中数据造成影响 默认插入值在创建表的 CREATE TABLE 语句中设置 DEFAULT 约束来设定默认值： 1234CREATE TABLE ProductIns(&lt;列名&gt; CHAR(4) NOT NULL, &lt;列名&gt; INTEGER DEFAULT 0, -- 销售单价的默认值设定为0;……); 显式方法插入默认值：在 VALUES 中指定 DEFAULT 关键字 1INSERT INTO &lt;表名&gt; (&lt;列名1&gt;, &lt;列名2&gt;, ……) VALUES (DEFAULT, DEFAULT, ……); 隐式方法插入默认值：在列清单和 VALUES 中省略要设定默认值的列 1INSERT INTO &lt;表名&gt; (&lt;列名1&gt;, &lt;列名3&gt;, ……) VALUES (DEFAULT, DEFAULT, ……); -- 列2设定默认值 从其他表中复制数据 创建一张结构一样的表 旧表数据插入新表： 123INSERT INTO 旧表 (&lt;列名1&gt;, &lt;列名2&gt;, ……)SELECT &lt;列名1&gt;, &lt;列名2&gt;, ……FROM 新表; INSERT 语句的 SELECT 语句中，可以使用 WHERE 子句或者 GROUP BY 子句等何 SQL 语法（除 ORDER BY） 指定 ORDER BY 子句也没有任何意义，因为无法保证表内部记录的排列顺序 数据的删除（DELETE语句的使用方法）DELETE语句1234DELETE FROM &lt;表名&gt;; -- 保留数据表，清空表全部数据DELETE FROM &lt;表名&gt; -- 删除表中指定条件数据 WHERE &lt;条件&gt;; 注意事项 DELETE 语句中只能使用 WHERE，而不能使用 GROUP BY、HAVING 和 ORDER BY。因为： GROUP BY 和 HAVING 是从表中选取数据时用来改变抽取数据形式的 ORDER BY 是用来指定取得结果显示顺序的 TRUNCATE：删除表中全部数据1TRUNCATE &lt;表名&gt;; 非标准SQL；Oracle、 SQL Server、PostgreSQL、MySQL 和 DB2 不能通过 WHERE 子句指定条件来删除部分数据 数据的更新（UPDATE语句的使用方法）UPDATE 语句123UPDATE &lt;表名&gt; SET &lt;列名&gt; = &lt;表达式/NULL&gt; -- NULL 只限于未设置 NOT NULL 约束的列 WHERE &lt;条件&gt;; 多列更新 法一：所有 DBMS 通用 12345-- 使用逗号对列进行分隔排列UPDATE &lt;表名&gt; SET &lt;列名1&gt; = &lt;表达式1&gt;, &lt;列名2&gt; = &lt;表达式2&gt; WHERE &lt;条件&gt;; 法二：非通用 1234-- 将列用()括起来的清单形式UPDATE Product SET (列名1, 列名2) = (表达式1, 表达式2) WHERE &lt;条件&gt;; 事务什么是事务需要在同一个处理单元中执行的一系列更新处理的集合。例如： 现要求完成往表1插入新数据并更新一些旧数据的任务。要完成该任务，插入和更新两种操作都要完成，则一定要使用事务进行处理（将一起要完成的操作打包进一个事务中进行处理） 创建事务12345事务开始语句;DML语句①;DML语句②;……事务结束语句（ COMMIT或者ROLLBACK） ; 在标准 SQL 中并没有定义事务的开始语句，而是由各个 DBMS 自己来定义的 SQL Server、PostgreSQL： BEGIN TRANSACTIONBEGIN TRANSACTION MySQL： START TRANSACTION Oracle、DB2：无 实际上，几乎所有的数据库产品的事务都无需开始指令。因为大部分情况下，事务在数据库连接建立时就已经开始，并不需要用户再明确发出开始指令 事务结束语句在所有的 RDBMS 中都是通用，只有 COMMIT 和 ROLLBACK 两种： COMMIT – 是提交事务包含的全部更新处理的结束指令，相当于文件处理中的覆盖保存。一旦提交，就无法恢复到事务开始前的状态了 ROLLBACK – 是取消事务包含的全部更新处理的结束指令，相当于文件处理中的放弃保存。一旦回滚，数据库就会恢复到事务开始之前的状态 在不使用指令而悄悄开始事务的情况下，区分各个事务有以下两种模式（通常 DBMS 都可以设置任选其一）： 自动提交模式 – 每条SQL语句就是一个事务（MySQL、SQL Server 和 PostgreSQL 默认使用） 直到用户执行 COMMIT 或者 ROLLBACK 为止算作一个事务（Oracle 默认使用） 若使用 DELETE 语句删除了数据表： 自动提交模式下，无法回滚恢复 非自动提交模式下，可以通过 ROLLBACK 命令取消该事务的处理，恢复表中的数据。但这仅限于明示开始事务，或者关闭自动提交的情况 ACID特性 原子性（Atomicity） 原子性是指在事务结束时，其中所包含的更新处理要么都执行，要么都不执行 一致性（Consistency）/完整性 一致性指的是事务中包含的处理要满足数据库提前设置的约束 隔离性（Isolation） 隔离性指的是保证不同事务之间互不干扰的特性。该特性保证了事务之间不会互相嵌套。此外，在某个事务中进行的更改，在该事务结束之前，对其他事务而言是不可见的 持久性（Durability） 持久性指的是在事务（不论是提交还是回滚）结束后， DBMS 能够保证该时间点的数据状态会被保存的特性。即使由于系统故障导致数据丢失，数据库也一定能通过某种手段进行恢复，如日志系统 复杂查询视图视图：保存好的 SELECT 语句 视图和表区别：表中存储的是实际数据，而视图中保存的是从表中取出数据所使用的SELECT语句 视图的优点： 无需保存数据，节省存储设备的容量 将频繁使用的 SELECT 语句保存成视图，不用重写重新执行，以提高效率 创建视图123CREATE VIEW 视图名称(&lt;视图列名1&gt;, &lt;视图列名2&gt;, ……)AS&lt;SELECT语句&gt; SELECT 语句中列的排列顺序和视图中列的排列顺序相同 多重视图：以视图为基础创建视图。多重视图会降低 SQL 的性能应尽量避免 使用视图查询 首先执行定义视图的 SELECT 语句 根据得到的结果，再执行在 FROM 子句中使用视图的 SELECT 语句 视图的限制 定义视图时不能使用 ORDER BY 子句 视图和表一样， 数据行都是没有顺序的 对视图进行更新 标准 SQL 中规定，想要视图可以被更新，定义视图的 SELECT 语句需要满足某些条件（非通过汇总）： SELECT 子句中未使用 DISTINCT FROM 子句中只有一张表 未使用 GROUP BY 子句 未使用 HAVING 子句 原因：视图和表需要同时进行更新，以保持数据一致性，因此通过汇总得到的视图无法进行更新 删除视图1DROP VIEW 视图名称(&lt;视图列名1&gt;, &lt;视图列名2&gt;, ……)； 子查询子查询和视图子查询就是将用来定义视图的 SELECT 语句直接用于 FROM 子句当中（为查询结果命别名） 子查询作为内层查询会首先执行 原则上子查询必须设定名称（使用 AS 关键字） 标量子查询标量子查询就是返回单一值的子查询 优点：返回的是单一值，可以用在 = 或者 &lt;&gt; 等比较运算符之中 书写位置：能够使用常数或者列名的地方 注意事项：子查询中只能返回单一值 关联子查询（建议刷题理解）与普通的子查询的区别在子查询中添加的 WHERE 子句的条件 为区别表对应不同的场景，在表所对应的列名之前加上表的别名，形式为“&lt;表名&gt;.&lt;列名&gt;” 适合在细分的组内进行比较时使用 结合条件一定要写在子查询中 函数、谓词、CASE表达式各种各样的函数函数的种类算术函数字符串函数日期函数转换函数 谓词什么是谓词LIKE谓词——字符串的部分一致查询BETWEENT谓词——范围查询IS NULL、IS NOT NULL——判断是否为NULLIN谓词——OR的简便用法使用子查询作为IN谓词的参数EXIST谓词 CASE表达式什么是CASE表达式CASE表达式的语法CASE表达式的使用方法 集合运算表的加减法什么是集合运算表的加法——UNION集合运算的注意事项包含重复行的集合运算——ALL选项选取表中公共部分——INTERSECT记录的减法——EXCEPT 联结（以列为单位对表进行联结）什么是联结内联结——INNER JOIN外联结——OUTER JOIN3张以上表的联结交叉联结——CROSS JOIN特定的联结语句和过时的语法 SQL 高级处理窗口函数什么是窗口函数窗口函数的语法语法的基本使用方法——使用RANK函数无须指定PARTITION BY专用窗口函数的种类窗口函数的适用范围作为窗口函数使用的聚合函数计算移动平均两个ORDER BY GROUPING运算符同时计算出合计值ROLLUP——同时计算出合计值和小计值GROUPING函数——让NULL更加容易分辨CUBE——用数据来搭积木GROUPING SETS——取得期望的积木]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + NexT 的问题]]></title>
    <url>%2F2019%2F06%2F30%2Fhexo_problem_list%2F</url>
    <content type="text"><![CDATA[[Updating] 本文记录了 Hexo + NexT 使用过程中的一些问题 版本声明 hexo: 3.9.0 next: 7.0.1 local_search 不能用打开首页（本地or线上），打开浏览器开发工具 Network 选项卡，点击首页“搜索”按钮，观察 search.xml 状态： 200 问题：Algolia 问题 解决：主题配置文件中关闭 Algolia 404 其他 问题：存在非法字符 解决：sublime 排查 .md 文件中所存在非法字符 post_meta 不显示更新时间修改主题配置文件，post_meta 模块中设置： 123updated: enable: true anotherday: false]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github + Hexo 搭建博客]]></title>
    <url>%2F2019%2F05%2F30%2Fhexo%2F</url>
    <content type="text"><![CDATA[[Updating] 本文记录了使用Github和Hexo搭建该博客的过程 环境 系统：ubuntu 18.04 nodejs:： Hexo 的安装Node.js 的安装Hexo 的安装Git 的安装初步优化]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理]]></title>
    <url>%2F2018%2F01%2F06%2Fcomputer-struct%2F</url>
    <content type="text"><![CDATA[[Updated] 本文梳理了《计算机组成原理》的基础知识 目录 Chapter 1 Chapter 2 Chapter 3 Chapter 4 Chapter 5 Chapter 6 Chapter 7 Chapter 8 总线 存储器 I/O 计算的运算方法 指令系统 CPU 控制单元 控制单元的设计 总线 判优控制 ！当总线上各个主设备同时请求占用总线时，总线控制器按一定优先等级确定某个设备可以占用总线。 ？总线特点为某一刻时刻只允许一个设备向总线发送信息，若两个以上部件同时向总线发送信息，势必导致信号冲突传输无效。 链式查询 1 BR、1 BS、1 BG 优：优先级固定；结构简单、易扩充 缺：电路故障敏感，第i个有故障，第i个以后皆无法工作 计数器定时查询 1 BR、1 BS、1bN设备地址线 优：优先级可不固定；电路故障不如链式查询敏感 缺：控制比链式查询复杂 独立请求 N BR、N BS、N BG 优：响应速度快；优先级控制灵活，可预先固定，也可通过程序改变；可屏蔽设备请求 缺：仲裁线路复杂 通信控制 ！解决通信双方如何获知传输开始和传输结束，以及通信双方如何协调配合。 ？因为总线由众多部件共享，在传送时间上只能用分时方式解决，故通信双方必须按某种约定的方式进行通信。 同步通信 采用公共时钟信号控制，统一传输周期（必须按最慢速度部件设计） 适用：总线长度较短，各部件存取时间相较一致 异步通信 没有公共时钟，采用应答式通信，无固定传输周期 全互锁（完全制约，可靠性最高）/半互锁（简单制约）/不互锁（无制约） 适用：总线各部件速度不一致 分离式通信 总线传输周期分为两个子周期供不同模块占用，总线上无等待时间，最充分发挥了总线的有效占用 半同步通信 既有公共时钟，又允许速度不同的模块和谐工作，采用插入等待周期的措施协调通信双方的配合问题 串行传输与并行传输 串行传输 数据在一条线路上按位依次传输 成本低，但速度慢，适合远距离的传输 并行传输 每个数据位都有一条独立传输线路，所有数据按位同时传输 成本高，速度快，适合近距离、高速传输 总线复用 不同信号（数据/地址）共用同一组物理线路，分时使用 需先给地址信号，然后用地址锁存信号将其保存 总线带宽（MBps）：单位时间总线上可传输数据位数，也称“数据传输率” 影响因素：总线宽度、传输距离、主频 总线带宽 = 一个传输周期传输字节数/时钟周期 | 一个传输周期传输字节数*时钟频率 存储器 芯片：16K×8位/16KB 地址线 = 14根 数据线 = 32根 引出线最少数目 = 数据线+地址线+2 多体结构存储器 将存储器分成若干个（n个）独立的模块，每个模块的容量和存取周期均相等，且可独立进行读写操作。将独立模块： 高位交叉编址 各模块分别响应不同请求源，实现多体并行 高位–存体号，低位–选择存储体内的字 低位交叉编址， 不改变存取周期的前提下，增加存储器带宽，n个模块则带宽提高至n倍 高位–选择存储体内的字，低位–存体号 存取周期T，总线传输周期t，连续读取n个字时间=T+（n-1）t 提高访存的措施 采用高速器件，选用存取周期短的芯片，提高存储器速度 采用缓存，CPU将近期要用的信息先调入缓存，而缓存速度比主存快得多，CPU从缓存存取信息则缩短访存时间，提高了访存速度 调整主存结构，如采用单体多字结构或多体结构（都增加存储器带宽） 程序访问的局部性原理 由于指令和数据在主存的地址分布不是随机的，而是相对地聚簇，故程序执行时对存储器的访问使不均匀的 利用该原理：对缓存-主存，把CPU最近期执行的程序放在容量较小速度较高的缓存中；对主存-辅存，把程序中访问频度高、比较活跃的部分放在主存中。既提高了访存速度又扩大了存储器容量 地址映射（硬件完成） 直接 假设C块缓存，每个主存块j只与一个缓存块i对应：i = j mod C 映射简单，但主存块只能固定对应某个缓存块，不够灵活、命中率低 全相联 主存任一块都可以映射到缓存中的任一块上 灵活、命中率高，但所需电路多、成本高 组相联 把缓存分Q组，组内分R块，主存块号j映射到缓存组号i内任一块：i = j mod Q，缓存内1~R任一块 比直接灵活、命中率高，比全相联成本低，是两者的折中，广泛应用 三级存储系统（平衡–速度、容量、价格） 高速缓存 解决：CPU和主存速度匹配，提高访存速度缓存 管理：硬件和操作系统完成 地址对用户透明 虚存 解决：扩大存储容量 管理：硬件和操作系统完成 CPU不直接访问二级存储器 RAM刷新 方式：集中/分散/异步 原因：存储电荷电容放电 I/O I/O编址方式 独立编址：I/O地址与主存地址分开，不占主存容量，但需要专用I/O指令访I/O 统一编址：在主存地址划出一定范围作I/O地址，通过访存指令访问I/O，但减少了主存容量 主机与I/O交换信息的控制方式 程序查询 主机与I/O串行工作 程序中断 主机与I/O并行工作,主程序和信息传送串行 DMA 主机与I/O并行工作,主程序和信息传送并行 通道 I/O处理机 程序查询 CPU启动I/O后停止现行程序，插入一段程序时刻查询I/O设备准备状况，等待I/O准备就绪时可实现信息交换，存在“踏步”现象 程序中断 管理（多重）中断硬件 中断请求触发器（INT）：标志中断源向CPU提出中断请求 中断屏蔽触发器（MASK）：为“1”表示屏蔽该中断源 排队器：中断判优 向量地址形成部件：产生中断源向量地址 允许中断触发器（EINT）：为“1”允许处理中断 中断标志触发器（INTR）：标志进入中断周期 堆栈：保护现场 中断查询信号电路：每条指令执行周期结束时刻，向各中断源发查询信号 过程： 中断请求：CPU启动I/O设备，I/O准备就绪后向CPU提出中断请求 中断判优：中断判优逻辑选择优先级最高的中断请求，待CPU处理 中断响应：若INT（中断请求触发器）为”1”且请求中断设备未被屏蔽，系统进入中断响应周期–CPU自动执行中断隐指令[ 硬件完成：保护程序断点(即PC内容)、硬件关中断、向量地址送PC（硬件向量法）或中断识别程序入口地址送PC（软件查询法） ] 中断服务：中断响应周期结束，CPU转入取指周期，按向量地址取出无条件转移指令（或按向量地址查入口地址表）；转至向量地址对应的中断程序服务入口地址，开始执行中断服务程序[ 保护现场（PC内容–中断隐指令；寄存器内容–软件编程）、与I/O传送信息、恢复现场 ] 中断返回：中断服务程序最后一条即中断返回指令（返回程序断点） 响应条件和时间： 条件：EINT为“1”（即开中断）；中断请求未被屏蔽，且排队后被选中 时间：指令执行阶段的结束时刻，CPU发出中断查询信号，才能获取中断请求信号 向量地址 存放服务程序入口地址的存储单元地址，由硬件形成 当有中断请求且排队选中时，通过自由组合逻辑电路组成的向量地址形成部件可形成向量地址 输入：排队器；输出：中断周期送至PC；传送：数据总线 开/关中断 EINT为“1”时，允许CPU响应中断；EINT为“0”时，CPU不能响应中断 关中断即将EINT置“0”；开中断即置“1” 多重中断(主要区别在中断服务程序)：CPU处理中断过程中出现新的中断请求，暂停现行中断处理转至处理新的中断 多重中断条件 必须重新开中断 优先级更高的中断请求才能中断现行程序（内部中断&gt;不可屏蔽中断&gt;可屏蔽中断） 单重中断：保护现场-&gt;设备服务-&gt;恢复现场-&gt;开中断-&gt;中断返回 多重中断：保护现场-&gt;开中断-&gt;设备服务-&gt;恢复现场-&gt;中断返回 中断服务程序与调用子程序区别 中断服务程序与中断时CPU正在运行程序相互独立；子程序与CPU正在运行程序是同一程序的两部分 除了软中断，中断通常随机产生；子程序调用由CALL指令引起 中断服务程序入口地址可通过硬件向量法产生向量地址，再由向量地址找到入口地址；子程序调用入口地址由CALL指令地址码给出 中断需要对多个同时发生的中断进行裁决；子程序调用无此操作 都要保护程序断点：前者中断隐指令完成；后者CALL指令完成 都要保护寄存器内容的操作 中断和DMA区别 数据传送：中断靠程序传送；DMA靠硬件传送 CPU响应时间：中断在一条指令执行结束时响应；DMA在存取周期结束时响应 异常处理能力：中断有；DMA无 保护现场：中断需中断现行程序，需保护现场；DMA不需中断现行程序，无需保护现场 优先级：DMA高于中断 DMA 特点： I/O和CPU并行工作 主存和I/O接口间有一条直接数据通路 不中断现行程序，无需保护、恢复现场 DMA请求占用总线时，若采用周期挪用，CPU暂停一个存取周期访问主存，但可继续自身内部操作（如乘法），即DMA传送和主程序并行 硬件：数据缓存寄存器、DAR、AR、WC、中断机构、DMA控制逻辑 过程： 预处理 指明数据传送方向输入（读）/输出（写） 设备地址送DAR（设备地址寄存器） 主存地址送AR（主存地址计数器） 传送数据字数送WC（字计数器） 启动设备 数据传送 主存地址送总线 数据送I/O设备（或主存） 修改主存地址和WC 重复直至数据块传送结束 后处理 由中断服务程序作DMA结束处理（测试传送过程是否出错、决定是否继续使用DMA传送数据） DMA和CPU分时使用主存： 停止CPU访存 DMA在传送数据时独占主存，CPU放弃总线使用权，基本处于不工作或保持原状态，直至DMA传送结束 周期挪用 一旦I/O有DMA请求，由I/O设备挪用一个存取周期。此时CPU可完成自身操作，但要停止访存 DMA和CPU交替访存 适用CPU工作周期比主存存取周期长时。CPU工作周期的上下半周期由DMA和CPU交替使用访存，使DMA传送和CPU工作效率最高，但硬件逻辑复杂 计算的运算方法 判溢出 定点机 参与运算的两个操作数符号相同，结果的符号与原操作数符号不同，则溢出 求和时最高进位与次高进位异或结果为1，则溢出 浮点机判溢出 当阶码大于最大正阶码时，则溢出 当阶码小于最小负阶码时，则按机器零处理 进位：影响加减运算速度的关键 进位链：传递进位的逻辑电路 先行进位：高位进位和低位进位同时产生 单重分组跳跃进位 n位全加器分若干小组，组内进位同时产生，组间串行进位 多重分组跳跃进位 n位全加器分若干大组，若干大组内又包含若干小组，大组内各小组进位同时产生，小组内进位同时产生，大组间串行进位 快于单重，但线路更复杂 指令系统 不同地址格式指令 地址格式 访存次数 备注 四地址 4 A4指出下条指令地址 三地址 4 PC指出下条指令地址 二地址 4 操作结果存回A1、A2或ACC 一地址 4 ACC存放操作数和结果 数据存放方式。存储字长32位，可按字节、半字、字寻址： 边界对准：数据字地址一定是4的整数倍。所存数据不满足该要求时，填充一个或多个空白字节（浪费存储空间） 边界不对准：数据字跨两个存储字时需两次访存，并对高低字节位置进行调整后才能取得数据字（影响取数时间） 间址/基址/变址：可扩大寻址范围 通过访存（多次间址多次访存）得到有效地址 间址 访存导致时间较长（T一次访存 &gt;&gt; T一次寄存器） 地址变换（R+A）得到有效地址 基址 基址寄存器内容由操作系统给定，且在程序执行过程中不可变 支持多道程序技术的应用 变址 变址寄存器内容由用户给定，且在程序执行过程中可变 适用于处理数组问题 相对/堆栈寻址 相对：EA = (PC) + A A为位移量（字节），决定寻址范围；可正可负，补码表示 便于程序浮动，用于转移指令 堆栈：SP +/- ▲ -&gt; PC 有效地址在SP中，指令中可少一个指令字段 ▲与主存编址方式相关：按字编址，▲取1；按字节编址，字长16位时▲取2，字长32时▲取4 RISC（CISC） 选用频度高简单指令，复杂指令功能由简单指令实现（指令系统复杂庞大） 指令长度固定，指令格式种类少，寻址方式种类少（不固定、多、多） 只有LOAD/STORE访存，其余指令皆在寄存器进行（可访存指令不受限制） CPU中有多个通用寄存器（设专用寄存器） 控制器采用组合逻辑控制（微程序） 采用流水技术，大部分指令1个时钟周期内完成（各指令执行时间相差大，大部分需多个时钟周期） 采用优化的编译程序（难以用优化编译生成高效代码） 与CISC比较： 提高指令执行速度 便于设计，可降低硬件设计复杂度 简化指令功能，有利于编译程序代码优化 不易实现指令系统兼容 CPU CPU 功能 指令控制：控制程序的顺序执行 操作控制：产生完成每条指令所需控制命令 时间控制：对各种操作加以时间上的控制 数据加工：对数据进行算术和逻辑运算 中断处理：处理计算机在运行过程中出现的异常情况和特殊请求 组成 寄存器 PC：存放现行指令地址，位数取决于存储器容量 IR：存放现行指令，位数取决于指令字长 通用寄存器：存放数据和地址，位数取决于机器字长 指令译码器 + 控制单元CU：根据指令译码在规定时间发出操作命令 ALU：算术逻辑运算 中断系统：处理中断 指令周期：取指+（间址）+执行+（中断） 执行 -&gt; 中断周期 -&gt; 取值 存取周期 -&gt; DMA周期 -&gt; 存取周期（指令周期任一阶段皆可） 指令流水 结构相关 硬件资源满足不了指令重叠执行的要求，发生资源冲突 如：同一时间，几条重叠的指令分别取值、取数、存数，发生访存冲突 数据相关 指令重叠执行，可能改变操作数的读写访问顺序，导致数据相关冲突 如：某条指令需要用到前面指令的执行结果，而这些指令在流水线中重叠执行，可能改变对操作数读写访问顺序 控制相关 流水线遇到分支指令或其他改变程序计数器PC的指令，造成指令执行顺序的改变 如：某条指令需等前面指令做出转移方向的决定才能进入流水线 流水线多发技术 超标量流水：每个时钟周期内可同时并发多条独立指令，处理器中需配置多个功能部件和指令译码电路，以便同时执行多个操作 超流水线：在原来的时钟周期内，功能部件被使用多次 超长指令字：对编译器要求高，充分挖掘指令间潜在并行性（一个时钟周期内，各功能部件无数据相关），把能并行的指令合成一条具有多个操作码（需相应个数功能部件）的超长指令 中断系统 INTR 与 EINT INTR 中断标志触发器：指示CPU是否进入中断周期 EINT 允许中断触发器：开放或关闭中断系统 置“1”：系统开放，允许中断（开中断指令） 置“0”：关中断（关中断指令、中断隐指令、硬件自动复位） 中断判优：在某一时刻可能有多个中断源（中断源请求随机）提出请求，而CPU只能响应一个，故须判优已解决响应优先次序 硬件排队：组合逻辑电路实现 软件排队：程序按优先级（从高至低）顺序查询各中断源 中断服务程序入口地址寻找 硬件向量法（向量中断）：当有中断请求时，由硬件产生该中断源对应的向量地址，再由向量地址找到服务程序的入口地址，然后暂停现行程序转至中断服务程序 排队器输出 -&gt; 向量地址形成部件 -&gt; 输出向量地址 向量地址寻找入口地址方式 向量地址单元内存放一条无条件转移指令 在向量地址单元内直接存放入口地址，形成一个中断向量地址表 软件查询法：编写中断识别程序实现 屏蔽 屏蔽触发器：内容即屏蔽字，每个中断源对应一个屏蔽字，为“1”时CPU不响应该中断源请求 优先级 响应优先级：CPU响应各中断源请求的优先次序，通常硬件线路已设置好，不便改动（不采用屏蔽时） 处理优先级：CPU实际对各中断源请求的处理优先次序（采用屏蔽） 采用屏蔽技术的中断服务流程 保护现场 -&gt; 置屏蔽字 -&gt; 开中断 -&gt; 中断服务 -&gt; 关中断 -&gt; 恢复现场 -&gt; 恢复屏蔽字 -&gt; 开中断 -&gt; 中断返回 作用 改变处理优先级 为实现多重中断，屏蔽低级别中断请求对现行中断处理程序的干扰 封锁部分中断请求，使程序控制更灵活 控制单元 控制单元CU 功能：发出各种操作命令(即控制信号) 受控制：指令寄存器(操作码)、时钟、标志、系统总线控制信号(中断) 多级时序 指令周期：完成（取出并执行）一条指令所需的时间 机器周期：指令执行过程中一个基准时间，通常以存取周期作为机器周期（因为完成指令都需取指，而一次访存时间固定）。一个机器周期内完成若干微操作，可通过节拍控制产生每一个微操作命令 时钟周期：主频（时钟信号的频率）的倒数，也可称为节拍（时钟信号控制产生，每个节拍宽度对应一个时钟周期）。一个节拍内完成若干需同时执行的操作，是控制计算机操作的最小时间单位 三者关系：每个指令周期含若干个机器周期，可不相等；每个机器周期含若干个时钟周期（节拍），可不相等 机器速度：同主频下， 机器周期中时钟周期数和指令周期中机器周期数不同，机器速度不同。（机器周期中含时钟周期少的机器速度更快） 控制方式 同步控制：微操作受统一基准时标时序信号控制。存取周期不统一时，取最长存取周期作为机器周期 采用定长的机器周期：采用完全统一、具有相同时间间隔和相同数目节拍 采用不定长的机器周期：机器周期内节拍数可不等；大多数微操作一个机器周期内完成，复杂微操作延长机器周期或增加节拍 采用中央控制和局部控制相结合的方法：大部分中央控制，少数局部控制 局部控制每一个节拍T*宽度与中央控制节拍宽度相同 局部控制节拍作为中央控制中机器节拍的延续，插入中央控制的执行周期 异步控制：不存在基准时标信号，微操作时序由专用的应答线路控制。控制器发出某一个微操作命令后，等待执行部件完成该操作时所发回的应答信号，再开始执行下一个操作 联合控制：同步与异步结合。即大多数微操作在同步时序信号控制下进行，而对时间难以确定的微操作（如I/O相关）采用异步控制 控制单元设计 组合逻辑控制器 采用硬连线逻辑：一个微操作命令对于一个逻辑电路 思路清晰，简单明了 结构复杂，线路复杂。一旦构成，除非物理上重新连线，否则无法增加新的控制功能 组合逻辑与微程序控制组成异同 同：均有PC、IR、时序电路、中断系统、状态条件 异： 微操作命令序列形成部件不同。组合逻辑核心部件–门电路；微程序核心部件–控制存储器ROM(存放全部微程序) 微操作命令及节拍安排的主要差别： 取指阶段 12OP(IR) -&gt; ID //组合逻辑：指令操作码送指令译码器OP(IR) -&gt; 微地址形成部件 //微程序：指令操作码送微地址形成部件 微程序每条指令都要增加一个将微指令下地址字段送CMAR的微操作 1Ad(CMDR) -&gt; CMAR 微程序控制器 采用存储逻辑：每条机器指令编写成一个微程序，每一个微程序包含若干条微指令（操作控制字段+顺序控制字段），每一条微指令对应一个或几个微操作命令 优点：规整形、灵活性、可维护性 控制器中微程序个数 = 机器指令数 + 3（取指/间址/中断周期) 组成 控存：存放全部微程序 CMAR（控存地址寄存器）：存放欲读出微指令地址。采用增量计数器法形成后续微指令地址时，有计数功能 CMDR（控存数据寄存器）：存放取出的微指令 顺序逻辑：控制微指令序列 输入：微地址形成部件、微指令下地址字段、外来标志 输出：CPU内部和系统总线的控制信号 微指令编码方式 直接编码（直接控制）：操作控制字段每一位代表一个微命令 简单直观，输出直接用于控制，执行速度快 微指令字较长，使控存容量大 字段直接编码（显示编码）：操作控制字段分段，每个字段经译码发出微操作命令，且互斥 缩短字长，以较少二进制信息表示较多微命令信号 增加译码电路，执行速度降低 字段间接编码（隐式编码）：一个字段某些命令需由另一字段某些微命令解释 更能缩短微指令字长，但速度更慢 微指令序列地址形成 直接由微指令的下地址字段给出 根据机器指令的操作码形成 增量计数器法，即 （CMAR）+ 1 -&gt; CMAR 根据各钟标志决定微指令分支转移的地址 测试网络形成 硬件直接产生微程序入口地址 微指令格式 水平型：一次能定义多个并行操作的微命令。直接编码、字段直接编码、字段间接编码以及直接及混合编码都属于水平型指令格式 大多数微命令可直接控制对象，故每条微指令执行时间短 微指令字长较长，故可用较少微指令数实现一条机器指令的功能 垂直型：采用类似机器指令操作码方式，在微指令中设置微操作码字段，由微操作码规定微指令功能 经过译码控制对象，影响执行时间 微指令字长较短，实现一条机器指令微程序比水平型微指令长的多，以较长微程序结构换取较短微指令结构]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计组</tag>
      </tags>
  </entry>
</search>
